<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>大三操作系统笔记 | Alley的博客</title><meta name="author" content="Alley"><meta name="copyright" content="Alley"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 导论1.操作系统做什么 计算机系统组成部分：计算机硬件、操作系统、系统程序与应用程序、用户  硬件——CPU、内存、I&#x2F;O设备：提供基本计算资源  应用程序——字处理成虚、编译器、浏览器：规定用户如何使用资源  操作系统：控制和协调用户的应用程序对硬件的使用  不实现任何功能，但为其他程序提供了一个有用的工作环境   用户视角的操作系统  操作系统：优化用户的工作 主要是为了操作">
<meta property="og:type" content="article">
<meta property="og:title" content="大三操作系统笔记">
<meta property="og:url" content="http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Alley的博客">
<meta property="og:description" content="第一章 导论1.操作系统做什么 计算机系统组成部分：计算机硬件、操作系统、系统程序与应用程序、用户  硬件——CPU、内存、I&#x2F;O设备：提供基本计算资源  应用程序——字处理成虚、编译器、浏览器：规定用户如何使用资源  操作系统：控制和协调用户的应用程序对硬件的使用  不实现任何功能，但为其他程序提供了一个有用的工作环境   用户视角的操作系统  操作系统：优化用户的工作 主要是为了操作">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-05-21T11:00:36.000Z">
<meta property="article:modified_time" content="2024-05-21T11:03:57.185Z">
<meta property="article:author" content="Alley">
<meta property="article:tag" content="大三课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '大三操作系统笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-21 19:03:57'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Alley的博客"><span class="site-name">Alley的博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">大三操作系统笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-05-21T11:00:36.000Z" title="Created 2024-05-21 19:00:36">2024-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-05-21T11:03:57.185Z" title="Updated 2024-05-21 19:03:57">2024-05-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="大三操作系统笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><h5 id="1-操作系统做什么"><a href="#1-操作系统做什么" class="headerlink" title="1.操作系统做什么"></a>1.操作系统做什么</h5><ul>
<li><p>计算机系统组成部分：计算机硬件、操作系统、系统程序与应用程序、用户</p>
</li>
<li><p>硬件——CPU、内存、I&#x2F;O设备：提供基本计算资源</p>
</li>
<li><p>应用程序——字处理成虚、编译器、浏览器：规定用户如何使用资源</p>
</li>
<li><p>操作系统：控制和协调用户的应用程序对硬件的使用</p>
<ul>
<li>不实现任何功能，但为其他程序提供了一个有用的工作环境</li>
</ul>
</li>
<li><p>用户视角的操作系统</p>
<ul>
<li>操作系统：优化用户的工作<ul>
<li>主要是为了操作方便和性能、不在乎资源使用率</li>
<li>单用户使用</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机视角的操作系统</p>
<ul>
<li>操作系统：资源分配器<ul>
<li>管理资源、决定程序和用户的资源分配、处理冲突的资源请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-计算机系统组织"><a href="#2-计算机系统组织" class="headerlink" title="2.计算机系统组织"></a>2.计算机系统组织</h5><ul>
<li><p>计算机系统图</p>
</li>
<li><p>引导程序：计算机开始运行时的初始化程序</p>
<ul>
<li>存储在ROM中（不改变）称为固件</li>
<li>初始化系统所有部分如CPU寄存器,设备控制器,内存</li>
</ul>
</li>
<li><p>中断：代表事件的发生</p>
<ul>
<li>硬件可以随时通过系统总线向CPU发信号触发中断</li>
<li>软件通过执行特别操作如系统调用触发中断</li>
<li>CPU暂停当前的事去执行中断，执行完后重新执行原先被中断的计算</li>
<li>中断向量：定位中断处理子程序的地址</li>
</ul>
</li>
<li><p>存储结构</p>
<ul>
<li>内存——动态随机访问内存DRAM<ul>
<li>load：data内存移进寄存器</li>
<li>store：data寄存器移进内存</li>
<li>流程：内存取指令、解码执行、结果保存回内存</li>
</ul>
</li>
<li>辅存——对内存的扩充<ul>
<li>常见为磁盘</li>
</ul>
</li>
<li>存储结构<ul>
<li>寄存器—cache—内存—磁盘—光盘—磁带</li>
</ul>
</li>
</ul>
</li>
<li><p>I&#x2F;O结构</p>
<ul>
<li>系统由CPU+多个设备控制器组成、靠总线连接<ul>
<li>每个控制器负责特定类型的设备，可以和多个设备相连</li>
</ul>
</li>
<li>设备控制器有一定量本地存储和寄存器，负责外部设备和本地缓存之间数据传递<ul>
<li>每个设备控制器有一个驱动程序</li>
<li>控制器先向缓冲区传输数据、完成后中断通知驱动 驱动返回获得的操作系统控制</li>
</ul>
</li>
<li>DMA:直接内存访问<ul>
<li>一整块再产生一次中断、提高效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-计算机体系结构"><a href="#3-计算机体系结构" class="headerlink" title="3.计算机体系结构"></a>3.计算机体系结构</h5><ul>
<li>单处理器系统<ul>
<li>主CPU<ul>
<li>执行一个通用指令集</li>
<li>具体的操作如“磁盘调度”会交给专用设备处理器<ul>
<li>是硬件的低级部件，不算在处理器数量里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多处理器系统<ul>
<li>多个紧密通信的CPU、共享总线、时钟、内存外设</li>
<li>优点<ul>
<li>增加吞吐量：更短时间做更多的事、加速比比N略小因为调度以及资源竞争会有额外开销</li>
<li>规模经济：共享外设存储和电源</li>
<li>可靠：一个失灵只会变慢不会停止（容错）</li>
</ul>
</li>
<li>类型<ul>
<li>非对称多处理：每个处理器有个值特定的任务，主处理器调度从处理器并安排工作</li>
<li>对称多处理：每个处理器都要完成所有任务</li>
</ul>
</li>
<li>刀片服务器<ul>
<li>把多处理器板、I&#x2F;O版和网络板置于同一地板</li>
<li>每个刀片处理器独立启动，运行各自的操作系统，包括了多个独立的多处理器系统</li>
</ul>
</li>
</ul>
</li>
<li>集群系统<ul>
<li>由两个或者多个CPU集中起来完成计算任务</li>
<li>可以提供高可用性服务<ul>
<li>一个或者多个系统出错也可以继续服务</li>
<li>集群软件运行在集群节点上，每个都能监视一个或者多个节点，当监视的机器失效时监视的机器取代存储拥有权并重启失效的应用程序</li>
</ul>
</li>
<li>可以是对称的也可以是非对称的<ul>
<li>非对称的一台机器运行一台机器进行监视（热备份模式）如果运行机器失效监视机器会变为现行服务器</li>
<li>对称会都运行应用程序并互相监视</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-操作系统结构"><a href="#4-操作系统结构" class="headerlink" title="4.操作系统结构"></a>4.操作系统结构</h5><ul>
<li>多道程序设计<ul>
<li>通过组织作业让CPU总有一个作业可执行，提高CPU利用率</li>
<li>多个任务保存在内存中，OS选择一个进行执行，当他需要I&#x2F;O时OS回切换到另一个作业，当I&#x2F;O完成时重新获得CPU</li>
<li>分时系统是多道程序的进一步延伸，用户可以和系统直接通信<ul>
<li>允许多用户同时共享计算机，因为每个动作&#x2F;命令时间较短因此CPU事件很少，快速切换可以起到多个系统同时运作的效果</li>
</ul>
</li>
<li>装入到内存并执行的程序称为<em>进程</em></li>
</ul>
</li>
<li>主存存储不了很多任务，一开始会存在磁盘的作业池<ul>
<li>当多个作业需要调入内存但是内存不足时需要进行<em>作业调度</em></li>
<li>当多个任务需要同时执行必须要CPU选择时需要进行<em>CPU调度</em></li>
</ul>
</li>
</ul>
<h5 id="5-操作系统操作"><a href="#5-操作系统操作" class="headerlink" title="5.操作系统操作"></a>5.操作系统操作</h5><ul>
<li>双重模式操作<ul>
<li><p>保证系统正常运行，必须区分操作系统代码和用户自定义代码</p>
</li>
<li><p>定义用户模式和监督程序模式</p>
</li>
<li><p>操作系统获得对计算机的控制——内核模式、运行用户程序——用户模式</p>
</li>
<li><p>保护操作系统和用户程序不受到错误用户程序的印象</p>
<ul>
<li>将能引起损害的指令作为特权指令，如果试图执行这回拒绝并以陷阱形式通知操作系统</li>
</ul>
</li>
<li><p>系统调用：用户请求操作系统完成任务</p>
<ul>
<li>硬件发出中断、控制权回归操作系统的中断处理程序、调整模式位，进行结束后控制返回</li>
</ul>
</li>
</ul>
</li>
<li>定时器<ul>
<li>确保OS对CPU的控制、防止用户死循环或不返回控制权给OS</li>
<li>操作系统移交控制权前先设定计时器操作，一般是设置为程序大致的运行时间，如果超时操作系统会中断</li>
</ul>
</li>
</ul>
<h5 id="6-进程管理"><a href="#6-进程管理" class="headerlink" title="6.进程管理"></a>6.进程管理</h5><ul>
<li>执行中的程序称为进程，可以粗略的定义为任务<ul>
<li>进程需要一定资源，可以在任意时刻分配给进程，还可以接受传输过来的初始化数据（输入），在进程中止时操作系统回收所有可再用资源</li>
<li><em>程序是被动实体，进程是活动实体</em></li>
<li>进程有一个程序计数器标识下一个执行的指令，任何时候最多有一个指令代表进程被执行，如果有多个进程，即使是关联一个程序也有各自的执行顺序，有多个程序计数器</li>
</ul>
</li>
<li>进程是系统的工作单元<ul>
<li>系统由多个进程组成，可以是操作系统进程可以是用户进程，所有进程潜在的并发进行</li>
</ul>
</li>
</ul>
<h5 id="7-内存管理"><a href="#7-内存管理" class="headerlink" title="7.内存管理"></a>7.内存管理</h5><ul>
<li>提高利用率和响应速度，计算机需要在内存中保留多个程序，不同的管理方法需要特定的硬件支持</li>
<li>操作系统需要内存管理的活动<ul>
<li>记录内存哪部分正在被谁使用</li>
<li>决定哪些进程可以装入内存</li>
<li>根据需要分配和释放内存空间</li>
</ul>
</li>
</ul>
<h5 id="8-存储管理"><a href="#8-存储管理" class="headerlink" title="8.存储管理"></a>8.存储管理</h5><ul>
<li>文件管理系统<ul>
<li>文件是由创建者定义的一组相关信息的集合<ul>
<li>通常表示程序和数据</li>
</ul>
</li>
<li>操作系统需要文件管理的活动<ul>
<li>创建和删除文件</li>
<li>创建和删除目录来阻止文件</li>
<li>提供操作文件和目录的原语</li>
<li>将文件映射到二级存储上</li>
<li>在稳定存储介质上备份文件</li>
</ul>
</li>
</ul>
</li>
<li>大容量存储管理<ul>
<li>操作系统需要硬盘管理的活动<ul>
<li>空闲空间管理</li>
<li>存储空间分配</li>
<li>硬盘调度</li>
</ul>
</li>
</ul>
</li>
<li>Cache管理<ul>
<li>运算时由于数据需要从底层存储一步步传递到运算器再传递回去，如果有多个进程访问数据时有可能数据还没完成更新</li>
<li>必须确保cache中对值的更新马上反应在所有其他该数据所在的缓存中，称为高速缓存一致性</li>
</ul>
</li>
<li>I&#x2F;O系统<ul>
<li>操作系统会对用户隐藏具体硬件设备的特性</li>
<li>只有设备驱动程序知道I&#x2F;O子系统被付给特定设备的特性</li>
</ul>
</li>
</ul>
<h5 id="9-保护和安全"><a href="#9-保护和安全" class="headerlink" title="9.保护和安全"></a>9.保护和安全</h5><ul>
<li>保护是控制进程或用户对于计算机系统资源的访问的机制<ul>
<li>是强制执行方法和强制提供规格说明方法</li>
</ul>
</li>
<li>安全是防止系统不受外部或者内部攻击<ul>
<li>有些需要操作系统，有些需要采用策略或者软件阻止方法</li>
</ul>
</li>
<li>保护和安全需要用户ID，对于用户唯一<ul>
<li>组标识可以定义用户集</li>
<li>特权ID可以让用户访问受限设备</li>
</ul>
</li>
</ul>
<h5 id="10-分布式系统"><a href="#10-分布式系统" class="headerlink" title="10.分布式系统"></a>10.分布式系统</h5><ul>
<li>将物理上分开的计算机通过翻落联系在一起，为用户提供系统所维护的各种资源的计算机的集合</li>
<li>访问共享资源增加了计算速度、功能、数据可用性和可靠性</li>
<li>网络操作系统：只提供比网络连接更进一步的网络和分布式系统的概念<ul>
<li>提供跨网络文件分享</li>
<li>自洽的，不同的操作系统紧密相连好像是一个操作系统在控制网络一样</li>
</ul>
</li>
</ul>
<h5 id="11-专用系统"><a href="#11-专用系统" class="headerlink" title="11.专用系统"></a>11.专用系统</h5><ul>
<li>实时嵌入式系统<ul>
<li>有特定任务，运行的系统简单，提供的功能有限，用户接口很少甚至没有，主要用于监视和管理硬件设备</li>
<li>比如汽车引擎</li>
<li>一般都运行实时操作系统，对于每一个操作和数据流动都有着严格的时间管理否则系统会失败</li>
</ul>
</li>
<li>多媒体系统<ul>
<li>多媒体数据：声音和图像数据</li>
<li>需要根据确定的时间限制（如1秒30帧）来传输</li>
</ul>
</li>
<li>手持系统<ul>
<li>内存很小因此需要操作系统有效的管理内存</li>
<li>处理器速度与电源挂钩，操作系统和应用程序需要减轻处理器的负担</li>
</ul>
</li>
</ul>
<h5 id="12-计算环境"><a href="#12-计算环境" class="headerlink" title="12.计算环境"></a>12.计算环境</h5><ul>
<li>传统计算<ul>
<li>不能远程访问、不能移动、联网通过调制解调器、防火墙、系统是批处理</li>
</ul>
</li>
<li><h2 id="客户机-服务器计算"><a href="#客户机-服务器计算" class="headerlink" title="客户机-服务器计算"></a>客户机-服务器计算</h2><ul>
<li>计算机服务器系统提供借口接受用户的请求，并将操作结果返回给客户机</li>
<li>文件服务器系统提供文件系统接口让客户机创建、更新、访问、删除文件</li>
</ul>
</li>
<li>对等计算<ul>
<li>P2P模式下，客户机和服务器没有区别，每台机子都可以是两者，取决于提供服务还是请求服务</li>
<li>没有C-S系统的服务器瓶颈问题，多个节点都可以提供服务</li>
</ul>
</li>
<li>基于Web的计算<ul>
<li>web能被多种设备访问、增加了网络的重要性，也导致了新一类设备的出现</li>
</ul>
</li>
</ul>
<h2 id="第二章-操作系统结构"><a href="#第二章-操作系统结构" class="headerlink" title="第二章 操作系统结构"></a>第二章 操作系统结构</h2><h5 id="1-操作系统服务"><a href="#1-操作系统服务" class="headerlink" title="1.操作系统服务"></a>1.操作系统服务</h5><ul>
<li>操作系统提供的函数<ul>
<li>用户界面：如命令行界面CLI、图形用户界面GUI</li>
<li>程序执行：运行&#x2F;结束程序</li>
<li>I&#x2F;O操作：用户不能直接控制色别，需要操作系统提供方法</li>
<li>文件操作系统：程序需要增删改查文件</li>
<li>通信：进程之间交换信息（共享内存）</li>
<li>错误检测：知道可能的错误并采取相应的动作</li>
<li>资源分配：管理不同类型的资源</li>
<li>统计：记录哪些用户使用了多少什么类型的资源，可用于重新配置系统来提高计算服务能力</li>
<li>保护和安全：保护多用户或网络连接的计算机系统的信息</li>
</ul>
</li>
</ul>
<h5 id="2-操作系统的用户界面"><a href="#2-操作系统的用户界面" class="headerlink" title="2.操作系统的用户界面"></a>2.操作系统的用户界面</h5><ul>
<li>命令解释程序<ul>
<li>也称为外壳</li>
<li>获取并执行用户指定的下一条命令比如创建、删除、列出、打印、复制、执行等<ul>
<li>执行的方法<ol>
<li>命令解释程序本身包含代码来执行命令，则自带命令决定了命令解释程序等大小</li>
<li>系统程序实现大部分命令，这命令解释程序不必理解命令，只需要用命令来识别文件装入内存并执行就可以了</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>图形用户界面<ul>
<li>用户友好、提供了窗口菜单作为借口、提供了桌面的概念</li>
</ul>
</li>
</ul>
<h5 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3.系统调用"></a>3.系统调用</h5><ul>
<li>系统调用提供了操作系统提供的有效服务界面<ul>
<li>可以理解为系统内置函数</li>
</ul>
</li>
<li>API：应用程序接口<ul>
<li>一系列适用于应用程序员的函数，包括传递给每个函数的参数以及返回的结果</li>
<li>API是封装好的一系列系统调用</li>
</ul>
</li>
</ul>
<h5 id="4-系统调用类型"><a href="#4-系统调用类型" class="headerlink" title="4.系统调用类型"></a>4.系统调用类型</h5><ul>
<li>进程控制<ul>
<li>进程需要能正常&#x2F;不正常的中断其执行</li>
<li>非正常中断会转写到磁盘并被调试器检查</li>
<li>只要中断控制会被转移给命令解释器去读取下一个命令（认为用户会处理错误）</li>
<li>控制卡：批处理概念，允许程序发现错误并退出时定义一个错误级别，命令解释程序和下一个程序能利用错误级别来决定下一个动作</li>
<li>单任务系统MS-DOS<ul>
<li>执行程序不创建新进程</li>
<li>把程序装入内存，改写自己的部分为新程序提供空间，然后将指令指针设置为程序的第一条指令</li>
<li>运行到错误中断或者系统调用中止，错误代码会保存到系统内存中</li>
<li>命令程序中尚未改写的部分开始执行，装入命令解释器的其他部分，完成任务时命令解释器会向用户或者下一个程序提供上一次错误代码</li>
</ul>
</li>
<li>多任务系统FreeBSD<ul>
<li>用户登录后从选择的shell中开始执行</li>
<li>解释程序在执行别的程序时可以照常执行</li>
<li>shell执行fork（）启动新进程，程序通过exec（）装入内存，程序开始执行</li>
<li>执行exit（）系统调用来中止</li>
</ul>
</li>
</ul>
</li>
<li>文件管理<ul>
<li>文件需要的系统调用：创建删除文件、打开使用、读写重定位、关闭文件、组织目录、确定属性、文件移动复制</li>
</ul>
</li>
<li>设备管理<ul>
<li>不同的资源都可以看作设备</li>
<li>用户需要请求设备以及释放设备</li>
</ul>
</li>
<li>信息维护<ul>
<li>维护当前时间、日期、用户数量、版本、内存、磁盘</li>
<li>维护进程的信息</li>
</ul>
</li>
<li>通信<ul>
<li>消息传递模型<ul>
<li>通信进程通过共同邮箱来交换信息</li>
<li>打开连接、获得名称、系统调用</li>
</ul>
</li>
<li>共享内存模型<ul>
<li>多个进程取消跨界访问的限制，可以通过读写公共区域来交换信息，数据的形式和位置不受操作系统控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-系统程序"><a href="#5-系统程序" class="headerlink" title="5.系统程序"></a>5.系统程序</h5><ul>
<li>系统程序的分类<ul>
<li>文件管理：创建、删除、复制、改名、打印、转储、列出、操作文件和目录</li>
<li>状态信息：程序获得日期、时间、可用内存、磁盘空间、用户数量，甚至详细性能、登陆和调试信息</li>
<li>文件修改：多个编辑器创建修改存储设备的文件内容或用于查找文件内容完成文本转换</li>
<li>程序语言支持：常用程序设计语言的编译、汇编、调试、解释程序</li>
<li>程序装入和执行：绝对加载程序、重定位加载、链接编辑器和覆盖式加载程序、高级语言调试程序</li>
<li>通信：提供了在进程、用户、计算机系统之间创建虚拟连接的机制</li>
</ul>
</li>
</ul>
<h5 id="6-操作系统设计和实现"><a href="#6-操作系统设计和实现" class="headerlink" title="6.操作系统设计和实现"></a>6.操作系统设计和实现</h5><ul>
<li>设计目标<ul>
<li>用户目标：易于使用、学习、可靠、安全、快速</li>
<li>系统目标：容易设计、实现、维护</li>
</ul>
</li>
<li>机制与策略<ul>
<li>机制决定如何做、策略决定什么</li>
<li>策略和机制的区分对于灵活性很重要</li>
</ul>
</li>
<li>实现<ul>
<li>使用高级语言</li>
<li>更好的数据结构和算法</li>
</ul>
</li>
</ul>
<h5 id="7-操作系统结构"><a href="#7-操作系统结构" class="headerlink" title="7.操作系统结构"></a>7.操作系统结构</h5><ul>
<li><p>简单结构</p>
</li>
<li><p>分层方法</p>
<ul>
<li>每层由数据结构和可由上层调用的子程序的集合组成</li>
<li>构造和调试简单化，每层只利用较低层所提供的功能实现</li>
<li>对于层的定义比较困难而且效率稍差</li>
</ul>
</li>
<li><p>微内核</p>
<ul>
<li>把非基本部分从内核移走并使纤维系统程序&#x2F;用户程序，只保留最小的进程和内存管理以及通信功能</li>
<li>主要功能是使用户程序和运行在用户空间的服务之间通信</li>
<li>优点：便于扩充操作系统，不用修改内核，更好的安全性</li>
<li>缺点：系统功能总开销增加导致系统性能下降</li>
</ul>
</li>
<li><p>模块</p>
<ul>
<li>像一个分层系统但更灵活 任意模块可由调用其他模块但更为高效</li>
</ul>
</li>
</ul>
<h5 id="8-虚拟机"><a href="#8-虚拟机" class="headerlink" title="8.虚拟机"></a>8.虚拟机</h5><ul>
<li><p>把硬件抽象为几个不同的执行部件，仿佛多个独立的执行环境</p>
<ul>
<li>虚拟磁盘来充当磁盘驱动器</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li>实现虚拟用户模式和虚拟内核模式（都运行在用户模式）但效率会不可控的变低</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>每个虚拟机完全独立因此没有安全问题</li>
<li>资源共享方法：1、通过小型磁盘 2、通过虚拟机网络</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>VMware、Java虚拟机JVM</li>
</ul>
</li>
</ul>
<h5 id="9-系统生成"><a href="#9-系统生成" class="headerlink" title="9.系统生成"></a>9.系统生成</h5><ul>
<li>对于某个特定的计算机场所需要配置和生成系统</li>
<li>可以针对特定的环境可以手动改系统代码&#x2F;创建模块来选择&#x2F;完全由表来驱动</li>
</ul>
<h5 id="10-系统启动"><a href="#10-系统启动" class="headerlink" title="10.系统启动"></a>10.系统启动</h5><ul>
<li>从引导程序开始执行、诊断程序确认机器状态、初始化系统，引导系统一般存储在ROM中</li>
</ul>
<h2 id="第三章-进程"><a href="#第三章-进程" class="headerlink" title="第三章 进程"></a>第三章 进程</h2><h5 id="1-进程概念"><a href="#1-进程概念" class="headerlink" title="1.进程概念"></a>1.进程概念</h5><ul>
<li><p>进程</p>
<ul>
<li>进程包括<em>文本段</em>（程序代码）、<em>堆栈段</em>（临时参数）、<em>数据段</em>（全局变量）</li>
<li>程序不是进程，即使两个进程和同一程序相关但还是当作两个独立的执行序列</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;进程状态&#x3D;&#x3D;</p>
<ul>
<li>新的、运行、等待、就绪、中止</li>
<li>一次只能有一个进程可以在处理器上运行、但是可以有多个进程处于等待或者就绪状态</li>
</ul>
</li>
<li><p>进程控制块PCB</p>
<ul>
<li>包含许多与一个特定进程相关的信息<ul>
<li><p>进程状态：新的、就绪、运行、等待、停止</p>
</li>
<li><p>程序计数器：进程要执行的下个指令的地址</p>
</li>
<li><p>CPU寄存器：累加器、索引寄存器、堆栈指针、通用寄存器、其他条件码信息寄存器</p>
</li>
<li><p>CPU调度信息：进程优先级、调度队列指针、其他调度参数</p>
</li>
<li><p>内存管理信息：基址和界限寄存器的值、段表或页表</p>
</li>
<li><p>记账信息：CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量</p>
</li>
<li><p>I&#x2F;O状态信息：I&#x2F;O设备列表、打开的文件列表</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li>让一个运行的程序内也可以同时执行多任务</li>
</ul>
</li>
</ul>
<h5 id="2-进程调度"><a href="#2-进程调度" class="headerlink" title="2.进程调度"></a>2.进程调度</h5><ul>
<li><p>调度队列</p>
<ul>
<li>进程进入系统时会加入<em>作业队列</em>、就绪和等待运行的进程保存在<em>就绪队列</em>（链表），链表头节点指向链表第一个和最后一个PCB块的指针，每个PCB快包括一个指向下一个PCB的指针</li>
<li><em>设备队列</em>：一个I&#x2F;O设备（比如磁盘）正在忙碌时，等待该设备的进程的队列</li>
<li>新进程初始处于就绪队列直到被选中执行，当进程分配到CPU并执行时<ul>
<li>进程发出I&#x2F;O请求，加入I&#x2F;O队列</li>
<li>进程创建新的进程，等到新进程结束</li>
<li>中断而强制释放，回到就绪队列</li>
</ul>
</li>
</ul>
</li>
<li><p>调度程序</p>
<ul>
<li>进程在各个调度队列中迁移依赖的是调度程序</li>
<li>短期调度程序&#x2F;CPU调度程序：从准备执行的进程中选择进程并分配CPU<ul>
<li>需要频繁的为CPU选择进程，因此执行必须很快否则效率低下</li>
<li>只负责在就绪队列里挑进CPU的进程</li>
</ul>
</li>
<li>长期调度程序&#x2F;作业调度程序：从缓冲池中保存的进程选择并装入内存准备执行<ul>
<li>执行不频繁，会控制内存中的进程数量，创建进程的速度等于进程离开系统的速度</li>
<li>进程可以分为I&#x2F;O为主和CPU为主的进程<ul>
<li>需要撑起调度程序选择一个合理的包含I&#x2F;O和CPU为主的组合进程</li>
</ul>
</li>
</ul>
</li>
<li>中期调度程序：将进程从内存中拿出、交换、改善进程组合（干一半先拿走）</li>
</ul>
</li>
<li><p>上下文切换</p>
<ul>
<li>遇到中断时需要保存当前运行的进程的上下文PCB，然后恢复另一个进程的状态</li>
<li>内核保留旧进程状态在PCB，然后装入新的进程的上下文</li>
<li>切换的时间是额外开销</li>
</ul>
</li>
</ul>
<h5 id="3-进程操作"><a href="#3-进程操作" class="headerlink" title="3.进程操作"></a>3.进程操作</h5><ul>
<li>进程创建<ul>
<li>创建进程称为父进程、新进程称为子进程，进程直接可以不断创建形成<em>进程树</em></li>
<li>进程通过进程标识符pid来识别进程</li>
<li>子进程资源：可以从系统获得也可以从父进程获得<ul>
<li>限制子进程只能使用父进程的资源能防止创建过多的进程带来的系统超载</li>
</ul>
</li>
<li>子进程初始化：由父进程传递给子进程</li>
<li>父子执行可能<ul>
<li>父进程和子进程并发执行</li>
<li>父进程等待，直到某个&#x2F;全部子进程执行完</li>
</ul>
</li>
<li>新进程的地址空间可能<ul>
<li>父进程的复制品</li>
<li>装入另一个新程序</li>
</ul>
</li>
<li>创建新进程：fork()<ul>
<li>复制原来的地址空间，允许父子进程通信</li>
<li>两个进程继续执行fork()之后的指令</li>
<li><em>子进程fork()的返回值为0，父进程返回值为子进程的标识符pid（非零）</em></li>
</ul>
</li>
<li>新程序取代内存空间：exec()<ul>
<li>系统调用将二进制文件装入内存，消除原来系统调用的内存映射</li>
</ul>
</li>
<li>等待：wait()<ul>
<li>等待子进程终止，并返回状态值</li>
</ul>
</li>
<li>结束：exit()</li>
</ul>
</li>
<li>进程终止<ul>
<li>调用exit()时终止，进程可以返回状态值到父进程（wait），所有的资源会被操作系统释放</li>
<li>父进程也可以通过系统调用终止子进程（需要知道子进程的标识符）<ul>
<li>原因1：使用了超过分配的资源</li>
<li>原因2：子任务不再需要</li>
<li>原因3：父进程中止（级连中止）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-进程间通信"><a href="#4-进程间通信" class="headerlink" title="4.进程间通信"></a>4.进程间通信</h5><ul>
<li>进程可以独立&#x2F;协作，协作的好处：<ul>
<li>信息共享、提高运算速度、模块化、方便</li>
</ul>
</li>
<li>进程协作的通信机制IPC<ul>
<li><p>共享内存</p>
<ul>
<li>速度快，建立共享内存之后不需要系统调用</li>
</ul>
</li>
<li><p>消息传递</p>
<ul>
<li>对于少量数据交换有用，不用避免冲突、好实现</li>
<li>速度慢，内核介入花很多时间</li>
</ul>
</li>
<li><p>都很常用</p>
</li>
</ul>
</li>
<li>共享内存<ul>
<li>建立共享内存区域，使用者把该区域放到自己的地址空间</li>
<li>缓冲类型<ul>
<li>无限缓冲：无限制、消费者可能等待、生产者不必等待</li>
<li>有限缓冲：缓冲为空消费者等待、缓冲已满生产者等待</li>
</ul>
</li>
</ul>
</li>
<li>消息传递<ul>
<li>消息传递工具提供发送send()和接受receive()</li>
<li>两个进程通信需要有通信线路<ul>
<li>直接&#x2F;间接通信</li>
<li>同步&#x2F;异步通信</li>
<li>自动&#x2F;显式缓冲</li>
</ul>
</li>
<li>命名<ul>
<li>直接通信<ul>
<li>需要每个进程明确的命名收发双方</li>
<li>send(P, msg)发给P信息</li>
<li>receive(Q, msg)接收Q信息</li>
<li>需要通信的每对进程自动建立线路，进程需要知道通信的标识符</li>
<li>一个线路只关系两个进程、每对进程之间只有一个线路</li>
<li>如果有进程改名就很麻烦</li>
</ul>
</li>
<li>间接通信<ul>
<li>通过邮箱或者端口来收发信息</li>
<li>进程可以往邮箱中存放和删除消息、每个邮箱是一个对象有唯一标识符</li>
<li>进程可以通过不同的邮箱与其他进程通信</li>
<li>进程间只有在至少有一个共享邮箱是才能通信</li>
<li>send(A, msg)发给邮箱A信息</li>
<li>receive(A, msg)接收邮箱A信息</li>
<li>两个进程共享一个邮箱是才能通信</li>
<li>一个线路可以与多个进程关联</li>
<li>两个进程可以有多个线路、一个线路对应一个邮箱</li>
<li>如果同时有两个进程取邮箱的信息可以采用不同策略<ul>
<li>一个邮箱只能和两个进程关联</li>
<li>一次最多一个进程取信息</li>
<li>允许系统选择进程接受信息</li>
</ul>
</li>
<li>如果邮箱在进程地址空间，进程消失时邮箱消失</li>
<li>操作系统拥有的邮箱可以分配拥有权和接收权</li>
</ul>
</li>
</ul>
</li>
<li>同步异步<ul>
<li>同步send：阻塞发送进程直到信息被接受</li>
<li>异步send：无视发送结果继续操作</li>
<li>同步receive：接受进程阻塞直到接收到消息</li>
<li>异步receice：接受这收到有效消息或空消息</li>
<li>同步的两个进程就好像在一个进程中一样，因为一个进程会等另一个</li>
</ul>
</li>
<li>信息缓冲队列<ul>
<li>零容量：信息不能存储，因此发送需要阻塞直到接收者接收到消息</li>
<li>有限容量：队列最大长度为n，如果有容量则把消息放入队列，如果没有则等待队列有空位</li>
<li>无限容量：信息任意存放，发送永不阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-IPC系统的实例"><a href="#5-IPC系统的实例" class="headerlink" title="5.IPC系统的实例"></a>5.IPC系统的实例</h5><ul>
<li>POSIX<ul>
<li>共享内存</li>
<li>进程首先创建共享内存段</li>
<li>也用于打开一个现有的段来共享它</li>
<li>设置对象的大小</li>
<li>进程可以写入共享内存了</li>
</ul>
</li>
<li>Mach<ul>
<li>Mach通信是基于消息的，甚至系统调用也是消息</li>
<li>每个任务在创建时都有两个邮箱——Kernel和Notify</li>
<li>消息传输只需要三个系统调用msg_send()， msg_receive()， msg_rpc()</li>
<li>通信所需的邮箱，通过port_allocate()创建</li>
<li>发送和接收是灵活的，例如邮箱满时有四个选项:<ul>
<li>无限期等待</li>
<li>最长等待n毫秒</li>
<li>立即返回</li>
<li>暂时缓存消息</li>
</ul>
</li>
</ul>
</li>
<li>WindowsXP<ul>
<li>通过高级本地过程调用(LPC)设施以消息传递为中心</li>
<li>仅在同一系统上的进程之间工作</li>
<li>使用端口(如邮箱)来建立和维护通信通道</li>
<li>通信工作如下:<ul>
<li>客户端打开子系统连接端口的句柄对象。</li>
<li>客户端发送连接请求。</li>
<li>服务器创建两个私有通信端口，并将其中一个的句柄返回给客户端。</li>
<li>客户端和服务器使用相应的端口句柄发送消息或回调，并侦听应答。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6-客户机-服务器系统"><a href="#6-客户机-服务器系统" class="headerlink" title="6.客户机-服务器系统"></a>6.客户机-服务器系统</h5><ul>
<li><p>Socket套接字</p>
<ul>
<li>通信的端点，一个进程一个socket，所有连接唯一</li>
<li>由IP地址和端口号连接而成</li>
</ul>
</li>
<li><p>javaSocket</p>
<ul>
<li>Socket类（TCP）DatagramSocket（UDP）多点传送Socket</li>
</ul>
</li>
<li><p>远程过程调用RPC</p>
<ul>
<li>消息传递通过远程系统上监听端口号的RPC服务器<ul>
<li>不同的端口号可以区分支持的多种网络服务</li>
</ul>
</li>
<li>RPC允许客户机调用远程主机的过程</li>
<li>外部数据表示XDR：解决客户机和服务器的存储数据大小端问题</li>
<li>调用语义：刚好执行一次而不是最多执行一次，防止调用失败<ul>
<li>实现方法：客户机周期性的重发RPC调用知道接收到ACK</li>
</ul>
</li>
<li>客户机获得端口的方式——初始请求</li>
</ul>
</li>
<li><p>远程方法调用RMI</p>
<ul>
<li>允许线程远程调用对象的方法</li>
<li>RPC和RMI区别<ul>
<li>RPC调用远程的程序或者函数</li>
<li>RMI基于对象支持只调用方法</li>
<li>RPC的远程过程参数只能是普通数据结构</li>
<li>RMI可以将对象作为参数传递</li>
</ul>
</li>
<li>实现方式：存根+骨干</li>
</ul>
</li>
</ul>
<h2 id="第四章-线程"><a href="#第四章-线程" class="headerlink" title="第四章 线程"></a>第四章 线程</h2><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><ul>
<li>线程：CPU使用的基本单元<ul>
<li>由线程ID、程序计数器、寄存器集合和栈组成</li>
<li>同一进程的线程共享代码段、数据段…</li>
<li>每个线程有自己的寄存器和栈</li>
</ul>
</li>
<li>动机<ul>
<li>需要同时处理多个任务</li>
<li>比多进程更加有效、省资源</li>
</ul>
</li>
<li>优点<ul>
<li>响应度高：即使部分阻塞或者执行冗长操作，该程序仍然能继续执行与用户交互</li>
<li>资源共享：线程默认共享所属进程的内存和资源，允许一个应用程序在同一地址空间有多个不同的活动线程</li>
<li>经济：进程的创建非常昂贵，创建线程更加经济</li>
<li>多处理器体系结构的利用：能够充分使用多处理器体系结构以便每个进程能并行运行在不同的处理器上</li>
</ul>
</li>
</ul>
<h5 id="2-多线程模型"><a href="#2-多线程模型" class="headerlink" title="2.多线程模型"></a>2.多线程模型</h5><ul>
<li>线程分为用户线程和内核线程<ul>
<li>用户线程受内核支持但不受内核管理</li>
<li>内核线程由操作系统直接支持和管理</li>
</ul>
</li>
<li>多对一模型<ul>
<li>许多用户线程映射到一个内核线程</li>
<li>如果一个线程阻塞系统调用则整个进程会阻塞（只有一个内核线程）</li>
<li>任意一个时刻只有一个线程能访问内核，不能够并行运行在多处理器上</li>
</ul>
</li>
<li>一对一模型<ul>
<li>每一个用户线程映射到一个内核线程</li>
<li>一个线程阻塞别的线程能继续执行</li>
<li>更好的并发更好的运行在多处理器上</li>
<li>但没创建一个用户线程就要创建一个内核线程，影响应用程序性能</li>
</ul>
</li>
<li>多对多模型<ul>
<li>多路复用许多用户线程到数量小于等于的内核线程</li>
<li>并发性只有内核线程数量有关</li>
<li>也允许有的用户线程单独绑定一个内核线程，称为二级模型</li>
</ul>
</li>
</ul>
<h5 id="3-线程库"><a href="#3-线程库" class="headerlink" title="3.线程库"></a>3.线程库</h5><ul>
<li>为程序员提供创建和管理线程的API<ul>
<li>可以提供一个没有内核支持的库，代码数据结构都存在用户空间中，执行本地调用</li>
<li>提供一个由操作系统直接支持的内核级别的库，代码数据结构存在内核空间中，调用API函数会导致对内核的系统调用</li>
</ul>
</li>
<li>Pthread（只是一个规范不是实现）<ul>
<li>pthread_create()创建独立线程<ul>
<li>参数有标识符、属性、要执行的函数名称</li>
</ul>
</li>
<li>pthread_join()等待子线程退出</li>
</ul>
</li>
<li>Win32<ul>
<li>与pthread类似</li>
</ul>
</li>
<li>Java线程<ul>
<li>1.创建新类从thread派生并重载run()<ul>
<li>run就是你想要运行的功能</li>
</ul>
</li>
<li>2.直接实现一个满足ruuable接口的类</li>
<li>start()创建新线程<ul>
<li>JVM中分配内存</li>
<li>调用run()使其在JVM中运行（run不会直接调用，都是通过调用start间接调用</li>
</ul>
</li>
</ul>
</li>
<li>Win和Pthread很好通过全局变量来共享数据，但java作为面向对象语言没有全局数据，只能分装在一个类里然后传递类到不同的线程</li>
</ul>
<h5 id="4-多线程问题"><a href="#4-多线程问题" class="headerlink" title="4.多线程问题"></a>4.多线程问题</h5><ul>
<li>系统调用fork()和exec()——针对线程<ul>
<li>如果线程调用fork()，会创建一个新的进程，可以复制所有线程也可以复制调用fork()的那一个线程</li>
<li>调用exec()会替换掉整个进程包括所有线程<ul>
<li>类似初始化</li>
</ul>
</li>
</ul>
</li>
<li>取消<ul>
<li>线程完成之前终止线程的任务，比如多个线程并发查找，有一个找到了别的线程就可以取消任务</li>
<li>要取消的线程称为目标线程，取消可发生于：<ul>
<li>异步取消：线程立即终止目标线程</li>
<li>延迟取消：目标线程检查运行情况，以有序方式终止自己<ul>
<li>安全的取消位置成为安全点，比如更新数据已经结束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>信号处理<ul>
<li><em>信号</em>用来通知进程某个特定的事件已经发生了</li>
<li>信号模式<ul>
<li>信号由特定事件的发生所产生</li>
<li>产生的信号要发送到进程</li>
<li>一旦发送必须被处理</li>
</ul>
</li>
<li>接受方式<ul>
<li>同步接收：信号发给线程自己所属的进程</li>
<li>异步接收：信号由运行进程之外的事件产生</li>
</ul>
</li>
<li>处理方式<ul>
<li>默认信号处理程序</li>
<li>用户自定义的信号处理程序<ul>
<li>可以忽略、终止程序等方式</li>
</ul>
</li>
</ul>
</li>
<li>发送目标<ul>
<li>发送信号到信号所应用的线程</li>
<li>发送信号到进程内到每一个线程</li>
<li>发送信号到进程内的某些固定线程</li>
<li>规定一个特定线程接收进程的所有信号</li>
<li>线程可以拒绝特定信号，因此信号通常发送到不拒绝的第一个线程</li>
</ul>
</li>
<li>发送函数kill()</li>
</ul>
</li>
<li>线程池<ul>
<li>问题：如果一有请求就创建线程则会浪费很多资源并且没法限制并发执行的线程数量、耗尽系统资源</li>
<li>定义：一开始创建一定数量线程放入池中等待，收到请求后唤醒线程并处理服务，完成后返回池中继续等待，没有可用线程服务器需要等待</li>
<li>优点<ul>
<li>现有线程处理请求快于创建进程</li>
<li>线程池容量限制了同一时间可用进程数量</li>
<li>高级线程池可以动态调整容量</li>
</ul>
</li>
</ul>
</li>
<li>线程特定数据<ul>
<li>有些线程需要一定数据的自己的副本，可以申请独立线程处理请求</li>
</ul>
</li>
<li>调度程序激活<ul>
<li>在内核线程和用户线程中间设置一种中间的数据结构轻量级进程LWP</li>
<li>表现为调度用户线程的应用程序</li>
<li>一个并发阻塞系统一个LWP、一般一个内核线程一个LWP</li>
<li>调度器激活<ul>
<li>内核提供一组LWP</li>
<li>应用程序调度用户线程到一个可用的LWP</li>
<li>任何与应用程序相关的事件都会通过运行在LWP1上的upcall处理句柄通知应用程序（比如用户线程1将要阻塞）</li>
<li>内核分配LWP2给应用程序，应用程序在LWP2上运行upcall，保存阻塞线程1状态和LWP1，然后调度线程2运行在LWP2上，当线程1阻塞结束，内核跟线程库发另一个upcall，需要在LWP3上运行，在线程1运行之后应用程序会调度线程3在LWP3上运行</li>
<li>一直保持内核线程与应用线程的数量匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-操作系统实例"><a href="#5-操作系统实例" class="headerlink" title="5.操作系统实例"></a>5.操作系统实例</h5><ul>
<li>Win XP<ul>
<li>程序以独立进程方式运行</li>
<li>fiber库提供多对多模型<ul>
<li>同属于一个进程的线程共享进程地址空间</li>
</ul>
</li>
<li>一个线程包括<ul>
<li>ID</li>
<li>寄存器集合</li>
<li>用户栈（用户模式）、内核堆栈（内核模式）</li>
<li>私有存储区域</li>
<li>后三部分称为<em>上下文</em>，线程主要数据结构包括<ul>
<li>执行线程块ETHREAD（内核访问）<ul>
<li>包括所属进程指针、开始控制子程序的地址、KTHREAD指针</li>
</ul>
</li>
<li>内核线程块KTHREAD（内核访问）<ul>
<li>线程调度同步信息、内核栈和TEB指针</li>
</ul>
</li>
<li>线程执行环境块TEB（用户访问）<ul>
<li>用户栈、线程本地存储</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Linux线程<ul>
<li>fork复制进程、clone创建线程</li>
<li>但linux不分进程线程、统一叫任务、有的共享空间有的不共享</li>
<li>fork创建任务会保留父进程数据副本</li>
<li>clone创建任务会存指向父任务数据结构的指针</li>
</ul>
</li>
</ul>
<h2 id="第五章-CPU调度（进程调度）"><a href="#第五章-CPU调度（进程调度）" class="headerlink" title="第五章 CPU调度（进程调度）"></a>第五章 CPU调度（进程调度）</h2><h5 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h5><ul>
<li>本质就是利用进程在等待I&#x2F;O的时间让CPU去处理其他的进程来提高效率</li>
<li>CPU-I&#x2F;O区间周期<ul>
<li>进程的执行从CPU区间开始然后I&#x2F;O区间–CPU区间交替，最后CPU区间通过系统请求终止</li>
<li>CPU区间时间往往非常短，有助于选择合适的CPU调度算法</li>
</ul>
</li>
<li>CPU调度程序<ul>
<li>CPU空闲时OS从就绪队列中选择一个进程来执行，选择由调度程序执行<ul>
<li>短期调度程序</li>
<li>CPU调度程序</li>
</ul>
</li>
<li>就绪队列可以是FIFO、优先队列、树、无需链表</li>
</ul>
</li>
<li>抢占调度<ul>
<li>CPU调度决策发生环境<ul>
<li>一个进程从运行状态切换到等待状态（必调度）<ul>
<li>I&#x2F;O请求，wait等待</li>
</ul>
</li>
<li>一个进程从运行状态切换到就绪状态（可选）<ul>
<li>中断</li>
</ul>
</li>
<li>一个进程从等待状态切换到就绪状态（可选）<ul>
<li>I&#x2F;O完成</li>
</ul>
</li>
<li>一个进程终止（必调度）</li>
</ul>
</li>
<li>如果只有必须调度时调度称为<em>非抢占&#x2F;协作</em>（分配完了会一直执行到停&#x2F;等），否则是<em>抢占的</em>（明明可以不调度硬要插队）</li>
<li>但抢占有可能造成修改读取数据的混乱，因此需要在必要时禁止中断</li>
</ul>
</li>
<li>分派程序<ul>
<li>负责将CPU的控制交给短期调度程序选择的进程<ul>
<li>切换上下文</li>
<li>切换成用户模式</li>
<li>跳转到用户程序合适的位置来重新启动程序</li>
</ul>
</li>
<li>每次切换进程的时候都会调用，停止一个进程到启动另一个进程的间隔称为分派延迟</li>
</ul>
</li>
</ul>
<h5 id="2-调度准则"><a href="#2-调度准则" class="headerlink" title="2.调度准则"></a>2.调度准则</h5><ul>
<li>&#x3D;&#x3D;调度因素&#x3D;&#x3D;<ul>
<li>CPU使用率：越高越好，一般负荷会40%～90%</li>
<li>吞吐量：单位时间内完成的进程的数量</li>
<li>周转时间：从进程提交到完成的时间，包括等待进入内存、就绪队列中等待、CPU上执行和I&#x2F;O执行</li>
<li>等待时间：进程在就绪队列中等待所花费的时间之和</li>
<li>响应时间：提交请求到产生第一响应的时间</li>
</ul>
</li>
<li>需要让使用率和吞吐量最大化、让周转时间等待时间响应时间最小化，大部分时间优化平均值、少数情况优化最值</li>
</ul>
<h5 id="3-调度算法"><a href="#3-调度算法" class="headerlink" title="3.&#x3D;&#x3D;调度算法&#x3D;&#x3D;"></a>3.&#x3D;&#x3D;调度算法&#x3D;&#x3D;</h5><ul>
<li><p>FCFS先到先服务调度</p>
<ul>
<li>效果：先请求CPU的进程先分配到CPU，可以直接用FIFO队列实现，每次加入进队列尾、分配从队列头，优：编写简单好实现、劣：平均等待时间长</li>
<li>平均等待时间变化很大，升序进入很短降序进入很长<ul>
<li>如果一个大进程先进入，后面的小进程会一直处在“护航效果”，大幅降低CPU使用率</li>
</ul>
</li>
<li>非抢占的，得到了CPU就会一直使用直到停&#x2F;等</li>
</ul>
</li>
<li><p>SJF最短作业优先调度</p>
<ul>
<li>效果：每次都优先将CPU给予最短CPU区间的进程，优：平均等待时间最短，劣：很难提前知道下一个CPU区间的长度，而且可能大进程会无限等待</li>
<li>可以抢占可以不抢占<ul>
<li>抢占时优化成“最短剩余时间优先调度”</li>
</ul>
</li>
</ul>
</li>
<li><p>priority优先级调度算法</p>
<ul>
<li>效果：每一个进程都会分配一个优先级，每次调度优先级最高的进程拥有CPU（SJF可以看成区间时间为优先级）<ul>
<li>一般数字越小优先级越高</li>
</ul>
</li>
<li>可以抢占也可以非抢占<ul>
<li>抢占就直接到达就直接切换，不抢占是加入队头</li>
</ul>
</li>
<li>会造成无穷阻塞或者饥饿<ul>
<li>解决方法：老化，优先级的值会随着时间降低</li>
</ul>
</li>
</ul>
</li>
<li><p>RR轮转法调度</p>
<ul>
<li>效果：定义个较小时间单元<em>时间片</em>（10～100ms）将就绪队列作为循环队列，调度程序循环就绪队列，为每一个进程分配不超过一个时间片的CPU<ul>
<li><p>新进程添加到就绪队列尾部，CPU设置定时器一个时间片后中断再分派</p>
</li>
<li><p>如果进程区间小于时间片则进程释放CPU，调度程序接着处理下一个进程，如果大于时间片则中断然后回到就绪队列的尾部</p>
</li>
<li><p>可抢占的，时间超过时间片就会被抢占</p>
</li>
<li><p>性能依赖于时间片大小，时间片超大就是FCFS，时间片很小就是处理器共享，一个cpu在多个进程之间来回切换</p>
</li>
<li><p>时间片要远远大于上下文切换时间才值</p>
</li>
<li><p>周转时间也依赖时间片的大小，因为需要很多上下文切换时间</p>
</li>
<li><p>80%的CPU区间应该小于时间片</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多级调度队列</p>
<ul>
<li>将就绪队列分成多个独立队列，一个进程被永久的分配到一个队列</li>
<li>每个队列可以有自己的调度算法，队列之间必须有调度，一般是固定优先级抢占（高级队列处理完了再处理低级）也可以是划分时间片，比如高优先级80%低优先级20%</li>
<li>还是有可能饥饿</li>
</ul>
</li>
<li><p>多集反馈队列调度</p>
<ul>
<li>如果进程使用CPU时间过长则会终止并降入低一级的队列尾部</li>
<li>调度程序可由一下参数定义<ul>
<li>队列数量</li>
<li>每个队列调度算法</li>
<li>何时升级队列</li>
<li>何时降级队列</li>
<li>每个进程都该进哪个队列</li>
</ul>
</li>
<li>最通用也最复杂</li>
</ul>
</li>
</ul>
<h5 id="4-多处理器调度"><a href="#4-多处理器调度" class="headerlink" title="4.多处理器调度"></a>4.多处理器调度</h5><ul>
<li>多个CPU需要进行负载分配</li>
<li>多处理器调度方法<ul>
<li>非对称处理AMP：一个主服务器处理所有的调度决定、I&#x2F;O处理和其他系统活动，其他处理器执行用户代码<ul>
<li>只有一个处理器访问系统数据结构、减轻了数据共享的需要</li>
</ul>
</li>
<li>对称多处理SMP：每个处理器自我调度，所有进程可能在一个公共的就绪队列或者有自己的私有就绪队列，每个调度通过检查共同队列并选择一个进程执行，还需要确保两个处理器不能选择一个进程</li>
</ul>
</li>
<li>处理器亲和性<ul>
<li>进程迁移所带来的代价过高，因此系统要尽量保证一个进程只在一个处理器上执行，即处理器亲和性</li>
<li>如果操作系统不能保证一定没有进程迁移，称为软亲和性，如果强制不允许移动称为硬亲和性</li>
</ul>
</li>
<li>负载平衡<ul>
<li>设法将工作负载平均的分配到SMP系统中的所有处理器上</li>
<li>如果队列公有则不需要，但如果每个处理器私有队列则需要负载的合理分配</li>
<li>方法1:推动迁移<ul>
<li>周期性的检查负载，发现不平衡则把即将超载的处理器的进程挪到空闲的不太忙的处理器中</li>
</ul>
</li>
<li>方法2:拉动迁移<ul>
<li>如果有处理器发生空闲则主动向忙碌的处理器获取进程（反方向）</li>
</ul>
</li>
<li>会破坏处理器亲和性</li>
</ul>
</li>
<li>对称多线程SMT&#x2F;超线程<ul>
<li>在同一个物理处理器上产生多个逻辑处理器，向操作系统呈现多处理器的框架，每个逻辑处理器有自己的架构状态、通用目的和机器状态寄存器、还负责自己的中断处理，每个逻辑处理器共享物理处理器的资源下图就是两个CPU产生4个处理器的效果</li>
<li>SMT是硬件提供的，不需要操作系统特殊设计，但如果能意识到这点还可以进一步提升性能，比如优先给不同物理处理器的逻辑处理器分配任务</li>
</ul>
</li>
</ul>
<h5 id="5-线程调度"><a href="#5-线程调度" class="headerlink" title="5.线程调度"></a>5.线程调度</h5><ul>
<li>竞争范围<ul>
<li>采用多对一&#x2F;多对多模型<ul>
<li>线程库调度一个进程内的用户线程到有效LWP上（即匹配上内核线程）称为<em>进程竞争范围PCS</em><ul>
<li>根据优先级完成，优先级由程序员决定且不被线程库调节</li>
<li>通常采用高优先级抢占</li>
</ul>
</li>
<li>调度多个内核线程到CPU采用<em>系统竞争范围SCS</em></li>
</ul>
</li>
<li>采用一对一模型<ul>
<li>用户线程到LWP不需要调度，只需要SCS</li>
</ul>
</li>
</ul>
</li>
<li>Pthread调度<ul>
<li>PTHREAD_SCOPE_PROCESS采用PCS调度	</li>
<li>PTHREAD_SCOPE_SYSTEM采用SCS调度</li>
<li>pthread_attr_set&#x2F;getscope(pthread_attr_t * attr, int scope)<ul>
<li>第一个是线程属性集的指针，第二个参数是传递竞争范围的值（PCS&#x2F;SCS）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6-操作系统实例"><a href="#6-操作系统实例" class="headerlink" title="6.操作系统实例"></a>6.操作系统实例</h5><ul>
<li>Solaris调度<ul>
<li>优先级线程调度、多级反馈队列<ul>
<li>实时、系统、分时、交互</li>
</ul>
</li>
<li>分配表<ul>
<li>优先级：数字越高优先级越大</li>
<li>时间片：和优先级成反比</li>
<li>时间片到期：用完时间片还没结束的线程刷新的优先级（会降低，视为CPU密集）</li>
<li>从睡眠中返回：等待I&#x2F;O返回后的优先级（会提高以支持交互进程的良好体验</li>
</ul>
</li>
<li>固定优先级：优先级不会动态调节（如系统类）</li>
<li>公平共享：CPU共享来替代优先级做调度决定</li>
</ul>
</li>
<li>WinXP调度<ul>
<li>基于优先级的、抢占调度算法来调度线程<ul>
<li>最高优先级的线程总是运行直到被更高优先级的线程抢占</li>
</ul>
</li>
<li>从高到低检查队列，如果没有可执行的线程调度程序会执行一个<em>空闲线程</em></li>
<li>32个优先级类型<ul>
<li>除了最高级实时和最低级空闲5个大<em>进程</em>层级</li>
<li>每个大层级6个小<em>线程</em>成绩 除了空闲</li>
<li>每个类型有一个基础优先级，默认是每个大层中的NORMAL级别</li>
<li>具体操作<ul>
<li>进程除非提前指定否则一般都是大层中的基础优先级，线程跟着进程走</li>
<li>当一个线程超时时间片，降低优先级、但不会低于基础优先级</li>
<li>当一个线程结束等待，提高优先级</li>
<li>前台进程甚至会调整时间片的倍数（3倍</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Linux调度<ul>
<li>抢占的机遇优先级的算法，0～99实时级100～140优秀级，数字越小级别越高</li>
<li>给高优先级长时间片、低优先级短时间片</li>
<li>每个处理器维护自己的队列，每当任务时间片超时则移出活动队列加入到期队列并重新计算优先级，每次从活动队列取任务，当活动队列空的时候两队列交换，继续下一轮取队列</li>
<li>实时任务优先级不变，其他任务动态调整，交互性越强、沉睡时间越长、越减优先级值</li>
</ul>
</li>
</ul>
<h5 id="7-算法评估"><a href="#7-算法评估" class="headerlink" title="7.算法评估"></a>7.算法评估</h5><ul>
<li>确定模型<ul>
<li>分析评估法：产生数据评估各个算法性能</li>
<li>确定模型法：采用预先负荷来算算法的性能</li>
</ul>
</li>
<li>排队模型<ul>
<li>估计CPU和I&#x2F;O区间的分布、进程到达系统的时间分布、估算大多数算法的平均吞吐量、利用率和等待时间</li>
<li>每个服务器都有等待进程队列，CPU具有就绪队列，I&#x2F;O具有设备队列，通过到达率和服务率可以计算使用率、平均队列长度、平均等待时间<ul>
<li>eg:平均队列长度n、平均等待时间W、平均到达率α，若系统稳定进出平衡则n&#x3D;W * α</li>
</ul>
</li>
<li>可以用于比较调度算法，但可处理的算法和分布还是比较有限</li>
</ul>
</li>
<li>模拟<ul>
<li>计算机来建模，随着模拟程序执行统计标识算法性能的数据</li>
<li>跟踪磁带可以监视真实的系统获得更精准的数据来跑模拟驱动，产生更精准的结果</li>
<li>但计算时间漫长、很昂贵</li>
</ul>
</li>
<li>实现<ul>
<li>模拟的精确度有限，只有完整实现才能得到最精确的算法信息</li>
<li>极其高昂的代价</li>
</ul>
</li>
</ul>
<h2 id="第六章-进程同步"><a href="#第六章-进程同步" class="headerlink" title="第六章 进程同步"></a>第六章 进程同步</h2><h5 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h5><ul>
<li>生产者消费者问题，原来是两个变量分别由两端修改，但是需要浪费一个空间标记空和满两种状态，但如果用counter计数，又会遇到同时修改全局变量时不可控的数据改变<ul>
<li>多个进程并发操作同一个数据的结果会与访问的特定顺序直接相关，称为<em>竞争条件</em></li>
<li>为了避免竞争条件需要确保一段时间只有一个进程能操作变量，不会相互影响</li>
<li>需要进程同步&#x2F;协调</li>
</ul>
</li>
</ul>
<h5 id="2-临界区问题"><a href="#2-临界区问题" class="headerlink" title="2.临界区问题"></a>2.临界区问题</h5><ul>
<li>临界区<ul>
<li>该区域内的代码可能改变变量、更新表、写文件</li>
<li>反正就是可能引起冲突的代码</li>
<li>没有两个进程能同时在临界区执行</li>
<li>进入区：请求进入临界区的代码</li>
<li>退出区：退出临界区的代码</li>
<li>剩余区：剩余部分</li>
</ul>
</li>
<li>临界区的要求<ul>
<li>互斥：如果一个进程在临界区内，其他进程都不能在临界区内（只有一人能进房子）</li>
<li>前进：如果没有进程在临界区内并且有进程需要进入临界区，只有不在剩余区的进程可以参选并且不能无限推迟选择（只要有想进的房子不能空）</li>
<li>有限等待：每个进程等待进入临界区的时间有上限（等待进入的时间有限）</li>
</ul>
</li>
<li>临界区处理方法<ul>
<li>抢占内核<ul>
<li>允许处于内核模式的进程被抢占</li>
<li>会导致竞争、难设计、但响应更快适合实时编程</li>
</ul>
</li>
<li>非抢占内核<ul>
<li>不允许内核模式的进程被抢占，会一直运行直到退出</li>
<li>不会导致竞争条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-Peterson算法"><a href="#3-Peterson算法" class="headerlink" title="3.Peterson算法"></a>3.Peterson算法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Process P</span><br><span class="line">do &#123;</span><br><span class="line">	flag[i]:= true;//我想进</span><br><span class="line">	turn = j;//令牌先给你</span><br><span class="line">	while (flag[j] and turn = j) ;//如果你又想进又有令牌，我等待</span><br><span class="line">	critical section//我进入临界区</span><br><span class="line">	flag [i] = false;//我不想进了</span><br><span class="line">	remainder section//剩余区</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>
<ul>
<li>只有“又有令牌又想进”的进程才能进入临界区</li>
<li>一开始先把令牌给对方，保证自己不会无条件进入（有限等待）</li>
<li>如果两个人都想进，只有一个人有令牌（互斥）</li>
<li>如果对方有令牌但不想进我也可以进（前进）</li>
</ul>
<h5 id="4-硬件同步"><a href="#4-硬件同步" class="headerlink" title="4.硬件同步"></a>4.硬件同步</h5><ul>
<li>临界区问题的关键——锁<ul>
<li>进入区 &#x3D;&#x3D; 请求锁</li>
<li>退出区 &#x3D;&#x3D; 释放锁</li>
</ul>
</li>
<li>单处理器环境<ul>
<li>直接修改变量时禁止中断，其他指令不能执行</li>
<li>非抢占内核</li>
</ul>
</li>
<li>多处理器<ul>
<li>禁止中断的消息传达给所有处理器会很费时间而且有延迟降低效率，还会影响系统时钟</li>
<li><em>原子地</em>&#x3D;不可中断的特殊硬件指令<ul>
<li>检查和修改字内容、交换两个字内容</li>
</ul>
</li>
<li>TestAndSet()实现互斥<ul>
<li>lock&#x3D;true代表上锁了，false代表没上锁</li>
<li>TestAndSet会返回当前锁状态并上锁</li>
<li>如果当前未上锁，则上锁并进入临界区，退出后开锁</li>
<li>如果当前已上锁则在while中等待别人开锁</li>
</ul>
</li>
<li>Swap实现互斥<ul>
<li>lock&#x3D;true代表上锁，false代表没上锁</li>
<li>上锁行为：key是true，锁是false，换完之后的key显示的是当前锁的状态</li>
<li>如果当前没上锁，把自己的key掰成true然后上给lock完成上锁，key得到当前锁为false</li>
<li>如果当前已上锁，换给锁true发现key得到当前锁已经是true了，上锁失败，循环换锁直到临近区里的人把lock开锁成false</li>
</ul>
</li>
<li>有限等待互斥<ul>
<li>不等待或者未上锁即可进入</li>
<li>第一个进去的人上锁，执行临界区，退出时先看还有没有人等，如果有，直接让下一个等待的人不等待并进入，不开锁；如果没有则开锁等待下一波人进入</li>
<li>这样保证了任何一个等待的人都会被稳定的传递到进入权</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a>5.信号量</h5><ul>
<li>信号量S是整数变量，除了初始化只能通过两个原子操作访问<ul>
<li>P操作——wait()：信号量-1（大于0）<ul>
<li>当S&#x3D;0没有可减的时候wait会一直循环等待</li>
</ul>
</li>
<li>V操作——signal()：信号量+1</li>
</ul>
</li>
<li>用法<ul>
<li>计数信号量的值域无限制，二进制信号量的值域为0或1（互斥锁mutex）</li>
<li>信号计数量可以标识资源数量，进程需要使用资源时执行wait（你们等等我要用了，信号量-1），进程需要释放资源时执行signal（通知你们一下我用完了，信号量+1）</li>
<li>互斥锁的使用<ul>
<li>进去使用就wait，如果已经变0了就等待</li>
</ul>
</li>
<li>解决同步问题：S1执行完后才执行S2<ul>
<li>初始synch&#x3D;0，只有S1结束signal+1之后P2才能wait-1，否则一直循环</li>
</ul>
</li>
</ul>
</li>
<li>实现<ul>
<li>忙等：当一个进程位于临界区内，其他代码必须循环while来进行等待，这段时间本来CPU可以用来做别的事，却要在这里“很忙碌的等待”<ul>
<li>这样的信号量称为“自旋锁”：进程在等待锁的时候会一直运行（比如一直在swap）</li>
<li>优点是不会产生上下文切换（可能会时间很长）</li>
</ul>
</li>
<li>克服忙等<ul>
<li>修改wait：当信号量S&#x3D;0时不再while循环，而是阻塞并加入信号量S的等待队列、切换进程状态为等待，CPU调度程序会选择另一个进程执行</li>
<li>其他进程signal(S)之后等待的进程通过wakeup()重新执行，进程放进就绪队列中（可以抢占也可以不抢占）</li>
</ul>
</li>
<li>信号量结构、wait、signal的重新定义<ul>
<li>semaphore新增等待队列，wait不会while而是加入等待队列并用block挂起当前进程，signal增加wakeup来重新启动挂起的进程</li>
</ul>
</li>
<li>这里并没有完全取消忙等而是取消了应用程序进入临界区的忙等，wait和signal因为需要时原子地执行还是会有忙等，但临界区很短因此很少发生，偶尔等一下也无所谓，比在应用程序忙等效率高多了</li>
</ul>
</li>
<li>死锁和饥饿<ul>
<li>死锁：一堆进程等一个事件但这个事件永远不会发生（比如会在等待的进程中发生）</li>
<li>饥饿：进程在信号量的等待队列里无限等待</li>
</ul>
</li>
</ul>
<h5 id="6-经典同步问题"><a href="#6-经典同步问题" class="headerlink" title="6.经典同步问题"></a>6.经典同步问题</h5><ul>
<li>有限缓冲问题<ul>
<li>题目：n个缓冲项，mutex互斥锁（初始为1），empty空位个数信号量（初始为n），full满位个数信号量（初始为0）<ul>
<li>维护两个信号量的原因：wait没有“满等”只有“0等”，因此双方都得用wait</li>
<li>empty的wait标志能不能放&#x2F;取，mutex的wait标志放&#x2F;取的时候不能被打扰</li>
</ul>
</li>
</ul>
</li>
<li>读者-写者问题<ul>
<li>读者只读、写者可读可改，此时多读者同时访问无影响，读者写者同时访问会有影响，可能会读到错误信息，因此写者需要排他性</li>
<li>变种：<ul>
<li>第一读者-写者：如果写者正在等待读者，此时加入到读者会直接插到写者前面进去读，读者都读完了再写（写者永远在等待队列最后）——写者可能饥饿<ul>
<li>第一个来的人和最后一个走的人控制wrt信号量，决定写者能不能写</li>
</ul>
</li>
<li>第二读者-写者：一旦写者要写，等当前读者读完立马写（写者永远在等待队列最前）——读者可能饥饿</li>
</ul>
</li>
<li>可以提供读写锁，读访问申请读锁，写访问申请写锁<ul>
<li>使用场景<ul>
<li>可以区分哪些读哪些写</li>
<li>读者多时，并发建立读锁可以减少锁建立的开销</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>哲学家进餐问题<ul>
<li>5个哲学家只负责吃饭和思考，五人坐成一圈，五根筷子在两两人中间，想吃饭时哲学家会设法拿起左右的筷子，一次只能拿取一个筷子，吃完后放下筷子并思考</li>
<li>最简单的方法是5个信号量表示5个筷子，哲学家调用wait和signal来拿起和放下筷子，先拿左再拿右<ul>
<li>但是这种情况可能发生死锁：当所有人同时想吃时，同时拿起左边筷子，然后所有人等待右边筷子，并永远等待</li>
<li>解决的可能方法<ul>
<li>最多4个哲学家坐在5人的桌子上</li>
<li>左右都可用时哲学家再拿</li>
<li>奇数位置先拿左边筷子，偶数位置先拿右边筷子</li>
</ul>
</li>
</ul>
</li>
<li>以上方法又都有可能产生饥饿（有人永远吃不到）</li>
</ul>
</li>
</ul>
<h5 id="7-管程"><a href="#7-管程" class="headerlink" title="7.管程"></a>7.管程</h5><ul>
<li>一些失误或者有意的破坏会造成死锁&#x2F;破坏互斥<ul>
<li>先signal再wait——mutex会先变成2，期间别的进程会加入并破坏互斥</li>
<li>先wait后wait——在第二个wait处所有进程死锁</li>
<li>省略wait或者signal——各种错误</li>
</ul>
</li>
<li>管程使用<ul>
<li>类型内容<ul>
<li>一组变量的声明（变量的值定义了一个类型实例的状态，可以是一个PCB）</li>
<li>对于这些变量操作的值程序和函数实现</li>
</ul>
</li>
<li>管程的表示不能直接为进程所用，管程内定义的值程序只能访问位于管程内那些局部声明的变量和局部参数</li>
<li>管程可以确保一次只有一进程在管程内活动，但为了处理更复杂的同步方案可以定义条件结构condition<ul>
<li>condition只提供wait和signal</li>
<li>wait会让调用的进程挂起直到另一个进程调用同一个条件变量的signal</li>
<li>而当P调用x.signal唤醒Q时，就会有两个进程在管程运行，解决方案有<ul>
<li>（P）唤醒并等待：P等Q离开或其他条件</li>
<li>（P）唤醒并继续：Q等P离开或其他条件</li>
</ul>
</li>
<li>Pascal：唤醒Q之后P立即离开，Q直接执行</li>
</ul>
</li>
</ul>
</li>
<li>管程实现哲学家进餐问题<ul>
<li>准备<ul>
<li>首先定义三种状态<ul>
<li>enum{THINKING,HUNGRY,EATING} state[5]</li>
</ul>
</li>
<li>设置成EATING的条件是左右都不在进餐</li>
<li>定义条件信号量饥饿，在hungry但拿不到筷子时延迟自己<ul>
<li>condition self[5]</li>
</ul>
</li>
<li>拿起和放下方法pickup、putdown</li>
</ul>
</li>
<li>实现<ul>
<li>管程dp</li>
<li>哲学家首先调用哲学家函数，执行拿筷子，进入pickup</li>
<li>进入pickup先进入管程，设置hungry，test能否开动</li>
<li>如果成功，修改状态eating，进入x.signal<ul>
<li>检查自己是“等待被唤醒吃饭”还是“直接吃上的”，如果是直接吃上的则直接继续运行</li>
<li>如果有人在next等着进管程则释放next，如果没人进则释放mutex大门锁，退出管程，开始eat</li>
<li>进入putdown，进入管程，调整自己的状态，test左右有没有饿着现在能吃的，有的话唤醒他</li>
<li>如果有人在next等着进管程则释放next，如果没人进则释放mutex大门锁，退出管程 结束</li>
</ul>
</li>
<li>如果失败，进入x.wait<ul>
<li>自己的计数器+1，代表自己挂起来了，不能再占用管程，于是释放next或者mutex，自己开始等待</li>
<li>当自己左右的人都吃完后，调用test时会signal自己，这时候的signal看计数器有值，直接复活计数器+1，signal解除挂起，自己的计数器–，开始进入next队列等待</li>
<li>当有人退出管程时，next计数器-1，重新进入管程开吃</li>
<li>下面同上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>管程内的进程重启<ul>
<li>如果多个进程悬挂在一个条件变量x上，且某个进程执行了x.signal()该如何挑选运行挂起进程，可以是FCFS，也可以条件等待构造<ul>
<li>x.wait(c)即等待的时候存一个优先级进去，当有进程执行signal后会优先唤醒优先级值最小的进程</li>
</ul>
</li>
<li>多个竞争进程中控制对单个资源的访问 管程概念无法避免的问题<ul>
<li>一个进程没有获得资源权限就访问</li>
<li>一个进程获得权限之后不释放</li>
<li>一个进程试图释放没有请求过的资源</li>
<li>一个进程请求同一资源两次</li>
</ul>
</li>
<li>解决问题需要检查的题哦啊键<ul>
<li>用户进程按照正确顺序调用管程</li>
<li>不合作的进程不能简单忽略管程的互斥关口并不遵守协议直接访问共享资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="8-同步实例"><a href="#8-同步实例" class="headerlink" title="8.同步实例"></a>8.同步实例</h5><ul>
<li>Solaris同步<ul>
<li>提供适应互斥、条件变量、信号量、读写锁、十字转门</li>
<li>适应互斥<ul>
<li>保护对每个临界数据项的访问</li>
<li>如果数据已加锁<ul>
<li>锁在另一个CPU上运行的线程——自旋</li>
<li>锁在当前CPU的线程或者非运行的线程——睡眠</li>
</ul>
</li>
</ul>
</li>
<li>读写锁<ul>
<li>保护经常访问但通常只读访问的数据</li>
<li>实现代价大，只用于很长的代码段</li>
</ul>
</li>
<li>十字转门<ul>
<li>安排等待获取适应互斥和读写锁的线程链表</li>
<li>是一个队列结构，包含阻塞在锁上的线程</li>
<li>其他线程获取锁则进入该锁的十字转门</li>
<li>锁释放的时候内核从十字转门中选择一个线程作为锁拥有者</li>
<li>一个内核线程一个十字转门</li>
</ul>
</li>
</ul>
</li>
<li>WinXP同步<ul>
<li>多线程、实时应用程序和多处理器</li>
<li>提供调度对象<ul>
<li>线程可以采用多种机制比如互斥、信号量、事件、定时器来进行同步</li>
<li>事件与condition类似</li>
</ul>
</li>
<li>调度对象可以处于触发&#x2F;非触发状态<ul>
<li>触发：对象可用且线程获得时不会阻塞</li>
<li>非触发：对象不可用且线程获取时会阻塞</li>
<li>线程阻塞在非触发对象，状态切换为等待，加入对象等待队列，当对象变为触发时内核检查队列，改变一个（互斥）或多个（时间）线程变为就绪状态</li>
</ul>
</li>
</ul>
</li>
<li>Linux同步<ul>
<li>提供自旋锁和信号量</li>
<li>多处理器：获取自旋锁、释放自旋锁</li>
<li>单处理器：禁止内核抢占、使用内核抢占</li>
<li>preempt_disable()禁止内核抢占</li>
<li>preempt_enable()允许内核抢占</li>
<li>preempt_count任务占有锁的数量</li>
<li>短期占用：自旋锁、长期占用：信号量</li>
</ul>
</li>
<li>Pthread同步<ul>
<li>与上文一致</li>
</ul>
</li>
</ul>
<h5 id="9-原子事物"><a href="#9-原子事物" class="headerlink" title="9.原子事物"></a>9.原子事物</h5><ul>
<li>系统模型<ul>
<li>事物：执行单个逻辑功能的指令&#x2F;操作<ul>
<li>由commit（提交）&#x2F;abort（撤销）停止</li>
</ul>
</li>
<li>存储数据设备<ul>
<li>易失性存储：系统崩溃后不保存</li>
<li>非易失性存储：系统崩溃后能保存</li>
<li>稳定存储：绝不会损失</li>
</ul>
</li>
</ul>
</li>
<li>基于日志的恢复<ul>
<li>日志的结构<ul>
<li>事务名称：执行写操作事物的唯一名称</li>
<li>数据项名称：所写数据项的唯一名称</li>
<li>旧值：写操作前的数据项的值</li>
<li>新值：写操作后的数据项的值</li>
</ul>
</li>
<li>恢复算法：<ul>
<li>undo(Ti)：事务Ti更新的所有数据的值恢复到原来的值——防止夭折</li>
<li>redo(Ti)：事务Ti更新的所有数据的值设置成新值——防止错误</li>
</ul>
</li>
</ul>
</li>
<li>检查点<ul>
<li>出现错误时通过参考日志寻找错误<ul>
<li>耗费大量时间</li>
</ul>
</li>
<li>引入检测点：系统定期执行检察点并执行<ul>
<li>将当前易失存储上的日志输出到稳定存储上</li>
<li>将当前易失存储上所有修改数据输出到稳定存储上</li>
<li>稳定存储上输出一个日志记录checkpoint</li>
<li>能更快地查找</li>
</ul>
</li>
</ul>
</li>
<li>并发原子操作<ul>
<li>多个事物同时执行</li>
<li>串型化能力<ul>
<li>一个事物可能有多个指令</li>
<li>如果每个操作原子（不被穿插）的执行，称为一个调度</li>
<li>每个事物原子的执行称为穿行调度<ul>
<li>n个事物有n！种穿行调度</li>
</ul>
</li>
<li>允许事物重叠：非串型调度<ul>
<li>需要定义冲突操作：当两个操作同一个数据项且至少有一个write操作</li>
<li>如果两个事物的操作不冲突则可以交换，与原来等价，如果一个调度可通过交换转换成串型调度则称该调度为冲突可串型化的</li>
</ul>
</li>
</ul>
</li>
<li>加锁协议<ul>
<li>共享：事物Ti获得数据Q的共享模式锁S，则Ti可读Q但不能修改</li>
<li>排他：事物Ti获得数据Q的排他模式锁X，则Ti可读和写Q</li>
<li>类似读者-写者锁</li>
<li>访问时必须说，完成之后不一定马上释放</li>
<li>两端加锁协议来发出加锁和放锁请求<ul>
<li>增长阶段：可获取锁不能释放锁</li>
<li>收缩阶段：可释放锁不能获取新锁</li>
<li>事物一开始处于增长阶段，一旦事物释放锁则进入收缩阶段、不再加锁</li>
</ul>
</li>
<li>两端协议确保了冲突串型化但不能保证死锁</li>
</ul>
</li>
<li>基于时间戳的协议<ul>
<li>时间戳排序方案确定串型化顺序</li>
<li>对于每个事物Ti关联一个固定的时间戳TS(Ti)，之后进入系统的事物Tj就有TS(Ti)&lt; TS(Tj)<ul>
<li>采用系统时钟作为时间戳，不适用于不同系统&#x2F;不共享时钟的多处理器系统</li>
<li>采用逻辑计数器作为时间戳</li>
</ul>
</li>
<li>每个数据项Q关联的时间戳<ul>
<li>W-timestamp(Q)成功执行write(Q)的任何事物的最大时间戳</li>
<li>R-timestamp(Q)成功执行read(Q)的任何事物的最大时间戳</li>
<li>只要有新的read和writ就更新</li>
</ul>
</li>
<li>时间戳顺序协议<ul>
<li>当Ti发出read(Q)<ul>
<li>如果TS(Ti)&lt; W-timestamp(Q),这Ti需要读的值已经被改写，read拒绝Ti回滚</li>
<li>如果TS(Ti)&gt;&#x3D; W-timestamp(Q)，那么自信read，R-timestamp(Q)更新成R-timestamp(Q)和TS(Ti)的最大值</li>
</ul>
</li>
<li>当Ti发出write(Q)<ul>
<li>如果TS(Ti)&lt; R-timestamp(Q),这Ti正在产生以前需要的Q，write拒绝Ti回滚</li>
<li>如果TS(Ti)&lt; W-timestamp(Q)，那么Ti正在改成旧值，wtite拒绝Ti回滚</li>
<li>否则执行write</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第七章-死锁"><a href="#第七章-死锁" class="headerlink" title="第七章 死锁"></a>第七章 死锁</h2><h5 id="1-系统模型"><a href="#1-系统模型" class="headerlink" title="1.系统模型"></a>1.系统模型</h5><ul>
<li>系统的资源可以分为多种类型，当一个进程申请某个资源类型的一个实例、那么分配这种类型的任何实例都能满足申请，否则这些实例不同<ul>
<li>进程使用资源前必须申请资源，使用资源后必须释放资源</li>
<li>申请资源的数量不能超过系统资源的重量</li>
</ul>
</li>
<li>进程使用资源顺序<ul>
<li>申请：如果申请不被立即允许则进程必须等待直到获得资源</li>
<li>使用：进程对资源进行操作</li>
<li>释放：进程释放资源</li>
</ul>
</li>
<li>当一组进程中每一个进程都在等待一个事件且这个事件只能由遮住进程中的进程引起，则处于死锁<ul>
<li>比如一个进程有A、一个进程有B，这时进程1申请B、进程2申请A</li>
</ul>
</li>
</ul>
<h5 id="2-死锁特征"><a href="#2-死锁特征" class="headerlink" title="2.死锁特征"></a>2.死锁特征</h5><ul>
<li>出现死锁时、进程永远不能完成</li>
<li>死锁必要条件<ul>
<li>互斥：至少有一个资源处于非共享的独立模式</li>
<li>占有并等待：一个进程占有并等待一个被其他进程占有的资源</li>
<li>非抢占：资源不能被抢占，只能自动释放</li>
<li>循环等待：等待的序列是一个圈</li>
</ul>
</li>
<li>很难识别和测试只在某种情况下发生的死锁</li>
<li>&#x3D;&#x3D;资源分配图&#x3D;&#x3D;<ul>
<li>由一个节点集合V和边集合E组成<ul>
<li>V分为P系统活动进程集合（圆形）</li>
<li>R系统所有资源类型集合（矩形，圆点表示实例）</li>
</ul>
</li>
<li>进程P到资源R的有向边记为P→R，表示P已经申请了R并在等待（申请边，指向矩形）</li>
<li>资源R到进程P的有向边记为R→P，表示R的一个实例已经分配给了P（分配边，从圆点发出）</li>
<li>如果分配图没有环，就没有死锁</li>
<li>有环且每个类型只有一个实例，就死锁</li>
</ul>
</li>
</ul>
<h5 id="3-死锁处理方法"><a href="#3-死锁处理方法" class="headerlink" title="3.死锁处理方法"></a>3.死锁处理方法</h5><ul>
<li>处理方法<ul>
<li>使用协议避免死锁</li>
<li>允许死锁然后检测并恢复</li>
<li>忽视死锁</li>
</ul>
</li>
</ul>
<h5 id="4-死锁预防"><a href="#4-死锁预防" class="headerlink" title="4.死锁预防"></a>4.死锁预防</h5><ul>
<li>&#x3D;&#x3D;确保四个必要条件之一不成立来避免死锁&#x3D;&#x3D;</li>
<li>互斥：非共享的肯定互斥，没办法避免</li>
<li>占有并等待<ul>
<li>保证当一个进程申请一个资源时不能占有其他资源<ul>
<li>可以要求进程执行前申请获得所有资源</li>
<li>可以要求进程在没有资源时才能申请资源</li>
</ul>
</li>
<li>缺点：<ul>
<li>资源利用率低（已经分配但无法使用）</li>
<li>产生饥饿（只要有一个资源没有就无法申请到）</li>
</ul>
</li>
</ul>
</li>
<li>非抢占<ul>
<li>如果一个进程占有资源并申请另一个忙碌的资源，则目前分配的资源都可以被抢占</li>
<li>一个进程要重新执行，必须分配到其所申请的资源并恢复在等待时被抢占的资源</li>
</ul>
</li>
<li>循环等待<ul>
<li>对于所有资源类型进行完全排序，要求每个进程按照递增顺序来申请资源</li>
<li>必须先申请低级别资源再申请高级别，即你申请的资源一定比当前申请过的资源级别高</li>
<li>箭头都是单向的，不可能有环</li>
<li>先使用的级别小，保证使用顺序正确</li>
</ul>
</li>
</ul>
<h5 id="5-死锁避免"><a href="#5-死锁避免" class="headerlink" title="5.死锁避免"></a>5.死锁避免</h5><ul>
<li>死锁预防会导致低设备使用率和系统吞吐率</li>
<li>另一种方法：每次申请要求系统考虑现有可用资源、现已分配给每个进程的资源和每个进程将来申请和释放的资源以决定当前申请是否满足或必须等待，从而避免死锁发生的可能</li>
<li>安全状态<ul>
<li>如果系统能按照某个顺序为每个进程分配资源并能避免死锁，则系统状态是安全的</li>
<li>或者说如果存在一个安全序列，那么系统处于安全状态</li>
<li>安全状态一定不死锁，但不安全状态不一定死锁</li>
<li>安全序列<ul>
<li>确定一个进程顺序如果每个进程要获取的资源小于前面进程释放的资源+公共剩余的资源（即分配到他的时候够用）那么这个顺序称为安全序列</li>
<li>一旦序列有一环不满足，则有可能会发生互相等待都差一点的情况</li>
</ul>
</li>
<li>避免算法<ul>
<li>简单的确保系统始终处于安全状态</li>
<li>每一次申请可用资源都检测申请之后会不会破坏安全状态来决定分配&#x2F;等待</li>
<li>资源使用率可能更低（可用但不分配，因为不安全）</li>
</ul>
</li>
</ul>
</li>
<li>&#x3D;&#x3D;资源分配图算法&#x3D;&#x3D;<ul>
<li>只针对每类资源只有一个实例</li>
<li>除了申请边和分配边引入需求边，P→R表示P可能在将来的某个时候申请R，类似申请边但用虚线表示</li>
<li>所有的需求一开始都用虚线标注，但如果虚线变成反向实现（需求申请成功得到分配）之后会产生环，那么就不能分配![[截屏2023-11-06 10.12.52.png]]</li>
</ul>
</li>
<li>&#x3D;&#x3D;银行家算法&#x3D;&#x3D;<ul>
<li>可用于一类资源拥有多个实例</li>
<li>准备工作<ul>
<li>设n为进程个数、m为资源类型个数</li>
<li>Available：长为m的数组，表示每种资源现有个数<ul>
<li>Available[j] &#x3D; k,则Rj还有k个</li>
</ul>
</li>
<li>Max：n* m矩阵，定义每个进程的最大需求<ul>
<li>Max[i][j] &#x3D; k,则进程Pi最多申请k个Rj</li>
</ul>
</li>
<li>Allocation：n* m矩阵，定义每个进程现在所分配的各种资源类型的实例数量<ul>
<li>Allocation[i][j] &#x3D; k,则进程Pi已经分配了k个Rj</li>
</ul>
</li>
<li>Need：n* m矩阵，表示每个进程还需要的剩余资源<ul>
<li>Need[i][j] &#x3D; k,则P i还需要申请k个Rj</li>
<li>Need&#x3D;Max-Allocation</li>
</ul>
</li>
<li>当数组X每一个分量对应小于Y，则X &lt; Y</li>
</ul>
</li>
<li>安全性算法<ul>
<li>确认计算机系统是否处于安全状态</li>
</ul>
<ol>
<li>Work、Finish为长度m、n的数组，<ol>
<li>Work&#x3D;Available、Finish全设为false</li>
</ol>
</li>
<li>遍历每一个i，看有没有(没完成任务且现在可以完成的进程)<ol>
<li>Finish[i] &#x3D; false</li>
<li>Need[i] &lt;&#x3D; Work</li>
</ol>
</li>
<li>如果有，完成该任务，work收到该进程归还的资源，然后回到第二步继续遍历<ol>
<li>Work &#x3D; Work + Allocation[i]</li>
<li>Finish[i] &#x3D; true</li>
</ol>
</li>
<li>如果没有，如果对于所有i，Finish[i] &#x3D; true，则系统安全（没有可以完成的是因为任务都做完了而不是因为资源分配不开）</li>
</ol>
</li>
<li>资源请求算法<ul>
<li>判断是都可以安全允许请求</li>
<li>Request_i为进程Pi的请求向量，如果Request_i[j] &#x3D; k则Pi需要k个Rj</li>
<li>当Pi做出资源请求时执行</li>
</ul>
<ol>
<li>如果Request_i &lt;&#x3D; Need[i],下一步，否则报错，因为你请求了多于你需要的资源数量</li>
<li>如果Request_i &lt;&#x3D; Available[i],下一步，否则等待，因为可用资源不够</li>
<li>预修改状态<ol>
<li>Available &#x3D; Available-Request</li>
<li>Allocation &#x3D; Allocation + Request</li>
<li>Need &#x3D; Need - Request</li>
<li>带入到安全性算法里看安不安全</li>
</ol>
</li>
</ol>
<ul>
<li>如果是安全的那么交易完成且Pi可以分配到所需资源，如果不安全则必须等待并且预修改取消</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6-死锁检测"><a href="#6-死锁检测" class="headerlink" title="6.死锁检测"></a>6.死锁检测</h5><ul>
<li>不死锁预防也不死锁避免<ul>
<li>需要检测是否出现死锁</li>
<li>如何从死锁中恢复</li>
</ul>
</li>
<li>每个资源类型只有单个实例<ul>
<li>&#x3D;&#x3D;使用等待图&#x3D;&#x3D;：在资源分配图中删除所有资源类型节点合并适当的变得到等待图<ul>
<li>只有Pi→Pj的边，代表我申请的资源现在正分配给了你![[截屏2023-11-06 10.53.22.png]]</li>
<li>如果等待图有环，则出现死锁</li>
<li>为了检查死锁，系统需要维护等待图</li>
</ul>
</li>
</ul>
</li>
<li>每种资源类型有多个实例<ul>
<li>有Available、Allocation、Request（正在申请的个数）</li>
</ul>
<ol>
<li>设Work&#x3D;Available，Finish&#x3D;false（如果Available[i]&#x3D;0,则可设成true，代表已经完成）</li>
<li>寻找i，满足<ol>
<li>Finish[i] &#x3D; false</li>
<li>Request &lt;&#x3D; Work</li>
</ol>
</li>
<li>如果有,完成后回第二步<ol>
<li>Work &#x3D; Work + Allocation</li>
<li>Finish[i] &#x3D; true</li>
</ol>
</li>
<li>如果还有Finish[i] &#x3D; false，则进程i死锁</li>
</ol>
<ul>
<li>与银行家算法的区别：仅通过当前申请的个数来判断，认为之后不会再额外申请，这时如果又额外申请了则会产生死锁并被算法检测到</li>
</ul>
</li>
<li>应用检测算法<ul>
<li>应该何时调用检测算法<ul>
<li>死锁可能发生的频率</li>
<li>死锁影响的进程范围</li>
</ul>
</li>
<li>如果经常死锁就要经常调用检测算法</li>
<li>当请求分配不能立即允许时也可以调用死锁算法<ul>
<li>还可以确定哪一步造成了死锁</li>
</ul>
</li>
<li>简单点就一小时一检测</li>
</ul>
</li>
</ul>
<h5 id="7-死锁恢复"><a href="#7-死锁恢复" class="headerlink" title="7.死锁恢复"></a>7.死锁恢复</h5><ul>
<li>进程终止<ul>
<li>终止所有死锁进程</li>
<li>一次只终止一个进程直到死锁循环取消<ul>
<li>必须确定终止哪个进程可以打破死锁，类似CPU调度，应该终止代价最小</li>
<li>需要考虑不同进程优先级</li>
<li>进程已经计算的时间、还要计算的时间</li>
<li>进程使用的资源类型</li>
<li>进程需要的资源数量</li>
<li>需要终止的进程数量</li>
<li>交互还是批处理进程</li>
</ul>
</li>
</ul>
</li>
<li>资源抢占<ul>
<li>逐步从进程中抢占资源给其他进程使用直到死锁打破</li>
<li>选择一个牺牲品<ul>
<li>确定抢占顺序使得代价最小化：代价包含死锁进程拥有的资源数量、已经消耗的时间</li>
</ul>
</li>
<li>对于抢占的进程执行回滚，回滚到安全状态再重启（最稳妥的是完全回滚进程，最有效的是回滚到打破死锁）</li>
<li>需要确保一个进程的回滚次数是有限的来防止饥饿，不然一遇到死锁总会牺牲那个代价最小的进程</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Alley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/">大三课程</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">大三算法笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">大三编译原理笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三数据库笔记</div></div></a></div><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三编译原理笔记</div></div></a></div><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三算法笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alley</div><div class="author-info__description">学习与生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 导论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">1.操作系统做什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">2.计算机系统组织</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">3.计算机体系结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">4.操作系统结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">5.操作系统操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">6.进程管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">7.内存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">8.存储管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%AE%89%E5%85%A8"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">9.保护和安全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">10.分布式系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E4%B8%93%E7%94%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">11.专用系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">12.计算环境</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">客户机-服务器计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">第二章 操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">1.操作系统服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">2.操作系统的用户界面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">3.系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">4.系统调用类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.0.0.5.</span> <span class="toc-text">5.系统程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.0.6.</span> <span class="toc-text">6.操作系统设计和实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">3.0.0.7.</span> <span class="toc-text">7.操作系统结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">3.0.0.8.</span> <span class="toc-text">8.虚拟机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E7%B3%BB%E7%BB%9F%E7%94%9F%E6%88%90"><span class="toc-number">3.0.0.9.</span> <span class="toc-text">9.系统生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8"><span class="toc-number">3.0.0.10.</span> <span class="toc-text">10.系统启动</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">第三章 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">1.进程概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">2.进程调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">3.进程操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">4.进程间通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-IPC%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.0.0.5.</span> <span class="toc-text">5.IPC系统的实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.0.0.6.</span> <span class="toc-text">6.客户机-服务器系统</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第四章 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.0.0.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.0.0.2.</span> <span class="toc-text">2.多线程模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">5.0.0.3.</span> <span class="toc-text">3.线程库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">5.0.0.4.</span> <span class="toc-text">4.多线程问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.0.0.5.</span> <span class="toc-text">5.操作系统实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-CPU%E8%B0%83%E5%BA%A6%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">第五章 CPU调度（进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">2.调度准则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">3.&#x3D;&#x3D;调度算法&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">6.0.0.4.</span> <span class="toc-text">4.多处理器调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">6.0.0.5.</span> <span class="toc-text">5.线程调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.0.0.6.</span> <span class="toc-text">6.操作系统实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0"><span class="toc-number">6.0.0.7.</span> <span class="toc-text">7.算法评估</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">7.</span> <span class="toc-text">第六章 进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">1.背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">2.临界区问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">7.0.0.3.</span> <span class="toc-text">3.Peterson算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">7.0.0.4.</span> <span class="toc-text">4.硬件同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">7.0.0.5.</span> <span class="toc-text">5.信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">7.0.0.6.</span> <span class="toc-text">6.经典同步问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E7%AE%A1%E7%A8%8B"><span class="toc-number">7.0.0.7.</span> <span class="toc-text">7.管程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.0.0.8.</span> <span class="toc-text">8.同步实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%8E%9F%E5%AD%90%E4%BA%8B%E7%89%A9"><span class="toc-number">7.0.0.9.</span> <span class="toc-text">9.原子事物</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%AD%BB%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">第七章 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">1.系统模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%AD%BB%E9%94%81%E7%89%B9%E5%BE%81"><span class="toc-number">8.0.0.2.</span> <span class="toc-text">2.死锁特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.0.3.</span> <span class="toc-text">3.死锁处理方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">8.0.0.4.</span> <span class="toc-text">4.死锁预防</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">8.0.0.5.</span> <span class="toc-text">5.死锁避免</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">8.0.0.6.</span> <span class="toc-text">6.死锁检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">8.0.0.7.</span> <span class="toc-text">7.死锁恢复</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记">大三数据库笔记</a><time datetime="2024-05-21T11:07:55.000Z" title="Created 2024-05-21 19:07:55">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记">大三算法笔记</a><time datetime="2024-05-21T11:04:16.000Z" title="Created 2024-05-21 19:04:16">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="大三操作系统笔记">大三操作系统笔记</a><time datetime="2024-05-21T11:00:36.000Z" title="Created 2024-05-21 19:00:36">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记">大三编译原理笔记</a><time datetime="2024-05-21T10:58:47.000Z" title="Created 2024-05-21 18:58:47">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%BA%8C%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AC%94%E8%AE%B0/" title="大二自动机笔记">大二自动机笔记</a><time datetime="2024-05-21T10:54:06.000Z" title="Created 2024-05-21 18:54:06">2024-05-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Alley</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>