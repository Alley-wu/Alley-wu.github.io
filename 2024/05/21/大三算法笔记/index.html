<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>大三算法笔记 | Alley的博客</title><meta name="author" content="Alley"><meta name="copyright" content="Alley"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 算法引论算法时间复杂性 最坏情况时间复杂性 Tmax(n) &#x3D; max{ T(I) | size(I)&#x3D;n }   最好情况下时间复杂性 Tmin(n) &#x3D; min{ T(I) | size(I)&#x3D;n }   平均情况下时间复杂性 Tavg(n)&#x3D; ∑p(I)T(I)   算法的渐进复杂性 t(n)是T(n)的渐进性态，也是略去低阶留下来的">
<meta property="og:type" content="article">
<meta property="og:title" content="大三算法笔记">
<meta property="og:url" content="http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Alley的博客">
<meta property="og:description" content="第一章 算法引论算法时间复杂性 最坏情况时间复杂性 Tmax(n) &#x3D; max{ T(I) | size(I)&#x3D;n }   最好情况下时间复杂性 Tmin(n) &#x3D; min{ T(I) | size(I)&#x3D;n }   平均情况下时间复杂性 Tavg(n)&#x3D; ∑p(I)T(I)   算法的渐进复杂性 t(n)是T(n)的渐进性态，也是略去低阶留下来的">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-05-21T11:04:16.000Z">
<meta property="article:modified_time" content="2024-05-21T11:07:27.580Z">
<meta property="article:author" content="Alley">
<meta property="article:tag" content="大三课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '大三算法笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-21 19:07:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Alley的博客"><span class="site-name">Alley的博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">大三算法笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-05-21T11:04:16.000Z" title="Created 2024-05-21 19:04:16">2024-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-05-21T11:07:27.580Z" title="Updated 2024-05-21 19:07:27">2024-05-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="大三算法笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="第一章-算法引论"><a href="#第一章-算法引论" class="headerlink" title="第一章 算法引论"></a>第一章 算法引论</h3><h5 id="算法时间复杂性"><a href="#算法时间复杂性" class="headerlink" title="算法时间复杂性"></a>算法时间复杂性</h5><ul>
<li>最坏情况时间复杂性<ul>
<li>Tmax(n) &#x3D; max{ T(I) | size(I)&#x3D;n }</li>
</ul>
</li>
<li>最好情况下时间复杂性<ul>
<li>Tmin(n) &#x3D; min{ T(I) | size(I)&#x3D;n }</li>
</ul>
</li>
<li>平均情况下时间复杂性<ul>
<li>Tavg(n)&#x3D; ∑p(I)T(I)</li>
</ul>
</li>
<li>算法的渐进复杂性<ul>
<li>t(n)是T(n)的渐进性态，也是略去低阶留下来的主项，更加简单</li>
</ul>
</li>
<li>&#x3D;&#x3D;渐进分析符号&#x3D;&#x3D;<ul>
<li>渐进上界符号O<ul>
<li>O(g(n)) &#x3D; { f(n) | 存在正常数c和n0使得对所有n ≥n0有: 0 ≤ f(n) ≤ cg(n) }</li>
<li>当n ≥n0，g(n)超过f(n)只需要一个常系数</li>
<li>非紧上界符号o就是取消等于号</li>
</ul>
</li>
<li>渐进下界符号Ω<ul>
<li>Ω(g(n)) &#x3D; { f(n) | 存在正常数c和n0使得对所有n ≥ n0有: 0≤ cg(n) ≤ f(n) }</li>
<li>当n ≥n0，g(n)被f(n)超过只需要一个常系数</li>
</ul>
</li>
<li>紧渐近界记号Θ<ul>
<li>Θ(g(n)) &#x3D; { f(n) | 存在正常数c1,c2和n0使得对所有n ≥ n0，有:c1g(n) ≤ f(n) ≤ c2g(n) }</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h5><ul>
<li>非递归算法<ul>
<li>for&#x2F;while循环<ul>
<li>循环体内时间* 循环次数</li>
</ul>
</li>
<li>嵌套循环<ul>
<li>循环体内时间* 总循环次数</li>
</ul>
</li>
<li>顺序语句<ul>
<li>各个语句计算时间相加</li>
</ul>
</li>
<li>if-else语句<ul>
<li>if和else两者中取最大值</li>
</ul>
</li>
</ul>
</li>
<li>递归算法<ul>
<li>先写出递推方程</li>
</ul>
</li>
<li>最优算法<ul>
<li>能够触及到计算时间下界的算法就是最优算法</li>
</ul>
</li>
</ul>
<h5 id="求解线性递归关系"><a href="#求解线性递归关系" class="headerlink" title="求解线性递归关系"></a>求解线性递归关系</h5><ul>
<li>形式<ul>
<li>c₀f(m)+c₁f(m-1)+···+cₖf(m-k) &#x3D; 0</li>
</ul>
</li>
<li>求解过程<ol>
<li>列出特征方程<ul>
<li>c₀xᵏ+c₁xᵏ⁻¹+···+c ₖ₋₁x+cₖ &#x3D; 0</li>
<li>从大到小依次是k到0次方，f参数最小的是0次方，最大是k次方</li>
</ul>
</li>
<li>求解特征方程的根<ol>
<li>没有重根，解为q₁～qₖ<ol>
<li>直接给出通解c₁q₁ⁿ + c₂q₂ⁿ +···+ cₖqₖⁿ</li>
<li>带入n&#x3D;0、n&#x3D;1··与题目已给的前几项联立方程求解出cᵢ每一个系数的值</li>
</ol>
</li>
<li>有重根<ol>
<li>针对每一个根qᵢ，重数为tᵢ，构造通解项<ul>
<li>（cᵢ₁ + cᵢ₂n +··+ cᵢₜᵢn ᵗⁱ⁻¹）qᵢⁿ</li>
<li>t重根，系数有t项，次数从0～t-1</li>
</ul>
</li>
<li>所有通解项相加构成通解</li>
<li>带入n&#x3D;0、n&#x3D;1··与题目已给的前几项联立方程求解出cᵢ每一个系数的值</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="主定理计算递推关系复杂度"><a href="#主定理计算递推关系复杂度" class="headerlink" title="主定理计算递推关系复杂度"></a>主定理计算递推关系复杂度</h5><ul>
<li><p>主定理内容</p>
</li>
<li><p>理解</p>
<ul>
<li>首先有两项要算出来比较 一个f(n)一个logba，看谁大<ul>
<li>n^d为第二项的复杂度，n^logba为第一项的复杂度</li>
</ul>
</li>
<li>如果logba大，则第一项复杂度为T(n)复杂度</li>
<li>如果一样大，互相影响，要多乘logn</li>
<li>如果d大，基本可以认为第二项为T(n)复杂度</li>
</ul>
</li>
<li><p>大致上谁大听谁的，一样大多个logn</p>
</li>
</ul>
<h3 id="第二章-递归与分治"><a href="#第二章-递归与分治" class="headerlink" title="第二章 递归与分治"></a>第二章 递归与分治</h3><h5 id="往年考点"><a href="#往年考点" class="headerlink" title="往年考点"></a>往年考点</h5><ul>
<li>分治法设计算法的过程&#x2F;归并排序算法原理</li>
<li>伪代码</li>
<li>最坏情况下的时间复杂度（比较次数）</li>
</ul>
<h5 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h5><ul>
<li>直接或者间接的调用自身的算法成为递归算法<ul>
<li>必须有非递归定义的初始值</li>
</ul>
</li>
</ul>
<h5 id="分治法的基本思想"><a href="#分治法的基本思想" class="headerlink" title="分治法的基本思想"></a>分治法的基本思想</h5><ul>
<li>适用条件<ul>
<li>小规模容易解决</li>
<li>最优子结构：可以分解成若干个规模较小的相同问题</li>
<li>子问题可以合并为问题的解</li>
<li>各个子问题相互独立</li>
</ul>
</li>
<li>基本思想<blockquote>
<p>分治法（）{<br>if 规模达到最小可计算块<br>计算并返回结果<br>分割大块到小块<br>for每一个小块<br>分治法小块<br>把每一个小块的结果合并然后并返回<br>}</p>
</blockquote>
</li>
<li>分割原则：子问题的规模大致相同(平衡子问题)</li>
<li>算法复杂度：可以用递归方程来分析</li>
</ul>
<h5 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索*"></a>二分搜索*</h5><ul>
<li><p>分析</p>
<ul>
<li>小规模可解√ 最优子结构√ 子解可合并√ 子问题独立√</li>
</ul>
</li>
<li><p>基本思想</p>
<ul>
<li>n个元素分成大致相同的两半，中间元素与搜索元素比较，决定下一步在左半部还是右半部进行递归搜索</li>
</ul>
</li>
<li><p>算法复杂度</p>
<ul>
<li>最坏情况O(logn)</li>
<li>一直二分直到剩下最后一个才找到，n个要分logn次</li>
</ul>
</li>
<li><p>伪代码</p>
<blockquote>
<p>int BinarySearch(a[], x, right, left){<br>while(left &lt;&#x3D; right){<br>    int middle &#x3D; (left + right)&#x2F;2<br>    if(x &#x3D;&#x3D; a[middle]) return middle<br>    else if(x &lt; a[middle]) right &#x3D; middle - 1<br>    else left &#x3D; middle + 1<br>}<br>return -1<br>}</p>
</blockquote>
</li>
<li><p>备注</p>
<ul>
<li>并不需要递归调用函数，直接用个小循环就行</li>
<li>循环体内如果和n无关，那就是O(1)，不用考虑</li>
</ul>
</li>
</ul>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序**"></a>归并排序**</h5><ul>
<li><p>分析</p>
<ul>
<li>可算：长度为1即有序</li>
<li>分解：n个分成两个n&#x2F;2个子序列</li>
<li>合并：合并两个排好序的子序列</li>
<li>独立：两个序列的排序独立</li>
</ul>
</li>
<li><p>基本思想</p>
<ul>
<li>序列对半分，分到剩1个有序，再两两合并有序的子序列</li>
<li>核心是归并排序本身和合并子序列两个模块</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>主要是考虑比较次数和移动次数</li>
</ul>
</li>
<li><p>伪代码</p>
<blockquote>
<p>merge_sort(a[], left, right){<br>if(left &lt; right){<br>    middle &#x3D; (left + right)&#x2F;2<br>    merge_sort(a[], left, middle)<br>    merge_sort(a[], middle + 1, right)<br>    merge(a[], left, middle, right)<br>}<br>&#x2F;&#x2F;如果left&#x3D;right说明只有一个数，什么都不做<br>}<br>merge(a[], left, middle, right){<br>n1 &#x3D; middle - left + 1&#x2F;&#x2F;左半边长度<br>n2 &#x3D; right - middle&#x2F;&#x2F;右半边长度<br>new array1[], array2[]<br>for i &#x3D; 1 to n1&#x2F;&#x2F;复制左半边<br>    array1[i] &#x3D; a[left - 1 + i]<br>for j &#x3D; 1 to n2&#x2F;&#x2F;复制右半边<br>    array2[j] &#x3D; a[middle + j]<br>i &#x3D; 1<br>for k &#x3D; left to right{<br>    if(i &gt; n1){&#x2F;&#x2F;左边到头了<br>        a[k<del>right] &#x3D; array2[j</del>n2]<br>    }<br>    if(j &gt; n2){&#x2F;&#x2F;右边到头了<br>        a[k<del>right] &#x3D; array1[i</del>n1]<br>    }<br>    if(array1[i] &lt;&#x3D; array2[j]){&#x2F;&#x2F;左边小<br>        a[k] &#x3D; array1[i]<br>        i++<br>    }<br>    else{&#x2F;&#x2F;右边小<br>        a[k] &#x3D; array2[j]<br>        j++<br>    }<br>}<br>}</p>
</blockquote>
</li>
<li><p>备注</p>
<ul>
<li>两个两个归并叫2路归并，n路归并同理</li>
</ul>
</li>
<li><p>迭代归并</p>
</li>
</ul>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序**"></a>快速排序**</h5><ul>
<li><p>分析</p>
<ul>
<li>可算：只剩下一个数不用排</li>
<li>分解：根据中间值划分成两个子数组</li>
<li>合并：不需要合并，就地合并</li>
<li>独立：左右排序独立</li>
</ul>
</li>
<li><p>基本思想</p>
<ul>
<li>根据一个数为基准进行划分，比这个数小的都在它左边、反之在右边（不一定二等分）</li>
<li>核心是快速排序+划分函数</li>
</ul>
</li>
<li><p>复杂度<br>  最坏情况，每一次都是n-1个和1个<br>  最优情况，每次都划分到中值</p>
</li>
<li><p>伪代码</p>
<blockquote>
<p>quick_sort(a[], left, right){<br>if(left &lt; right){<br>    middle &#x3D; partition(a[], left, right)&#x2F;&#x2F;返回划分点的序号<br>    quick_sort(a[], left, middle - 1)&#x2F;&#x2F;左边<br>    quick_sort(a[], middle + 1, right)&#x2F;&#x2F;右边<br>}<br>}<br>partition(a[], left, right){&#x2F;&#x2F;第一个数为划分点<br>int i &#x3D; left + 1, j &#x3D; right<br>temp &#x3D; a[left]&#x2F;&#x2F;划分点取出来<br>while(true){<br>    while(a[i] &lt; temp){i++}&#x2F;&#x2F;找到第一个该去右边的<br>    while(a[j] &gt; temp){j–}&#x2F;&#x2F;找到第一个该去左边的<br>    if(i &gt;&#x3D; j){break}&#x2F;&#x2F;交汇了 结束<br>    else{<br>        swap(a[i], a[j])&#x2F;&#x2F;把该去右边的和该去左边的交换<br>    }<br>}&#x2F;&#x2F;划分完毕，把最后一个该去左边的挪到第一个<br>a[left] &#x3D; a[j]<br>a[j] &#x3D; temp&#x2F;&#x2F;把第一个挪到划分中间位置<br>return j&#x2F;&#x2F;返回位置<br>}</p>
</blockquote>
</li>
<li><p>备注</p>
<ul>
<li>采取随机选择划分点可以增加划分的对称性和稳定性</li>
</ul>
</li>
</ul>
<h5 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择**"></a>线性时间选择**</h5><ul>
<li>基本思想<ul>
<li>参考快速排序的思想找出第k小的元素</li>
<li>划分的数随机生成</li>
</ul>
</li>
<li>复杂度</li>
<li>伪代码<blockquote>
<p>randomized_select(a[], left, right, k){<br>if(left &#x3D;&#x3D; right){<br>    return a[left]&#x2F;&#x2F;没有可选的<br>}<br>middle &#x3D; randomized_partition(a[], left, right)<br>index &#x3D; middle - left + 1&#x2F;&#x2F;算算是第几小的<br>if(k &lt;&#x3D; index){<br>return randomized_select(a[], left, middle, k)<br>}&#x2F;&#x2F;左半部分找<br>else{<br>    return randomized_select(a[], middle + 1, right, k - index)<br>}<br>}</p>
</blockquote>
</li>
<li>复杂度：最坏情况仍然是O(n ²)</li>
<li>优化版本<ul>
<li>要求每一次的划分长度有一个上限，比如长度必须小于3&#x2F;4</li>
<li>这样最坏情况也能满足O(n)的复杂度</li>
<li>因此划分点的选取很重要，要选一个偏中间的数</li>
</ul>
</li>
<li>select函数<ul>
<li>首先把n个元素分成5个元素一组（近似），每个组取中位数</li>
<li>再找出所有中位数的中位数（如果偶数个取中间较大的那个）</li>
<li>此时一定比x小的有一半的中位数，这里每个中位数还一定大于每组的两个小的，此时整个左上角近似1&#x2F;4的数是一定比x小的，同理右下角1&#x2F;4的数是一定比x大的</li>
<li>当数量越来越大，近似也就越准确，n&gt;75时稳定大于1&#x2F;4</li>
<li>因此用x作为划分点一定至少是1:3开，能缩小至少1&#x2F;4长度</li>
</ul>
</li>
<li>伪代码<blockquote>
<p>select(a[], left, right, k){<br>if(right - left &lt; 75){&#x2F;&#x2F;直接排序就行了省事<br>    sort(a[], left, right)<br>    return a[left + k - 1]<br>}<br>for i &#x3D; 0 to (right - left - 4)&#x2F;5{ &#x2F;&#x2F;后面这个数是分成多少组<br>    a[left+5<em>i]~a[left+5</em>i+4]里第三大的元素和a[left+i]换<br>    &#x2F;&#x2F;把一组五个数里的中位数挪到最前头去<br>}<br>x &#x3D; select(a[], left, (right - left - 4)&#x2F;5, (right - left - 4)&#x2F;10)&#x2F;&#x2F;把前面几个中位数整进去 找到中位数的中位数<br>index &#x3D; partition(a[], left, right, x)&#x2F;&#x2F;得到划分后的划分点序号<br>num &#x3D; index - left + 1&#x2F;&#x2F;得到第几个<br>if(k &lt;&#x3D; j)return select(a[], left, index, k)&#x2F;&#x2F;在左半边<br>else return select(a[], index+1, left, k - j)&#x2F;&#x2F;在右半边<br>}</p>
</blockquote>
</li>
<li>复杂度</li>
</ul>
<h5 id="最接近点对问题"><a href="#最接近点对问题" class="headerlink" title="最接近点对问题"></a>最接近点对问题</h5><h3 id="第三章-动态规划"><a href="#第三章-动态规划" class="headerlink" title="第三章 动态规划"></a>第三章 动态规划</h3><h5 id="往年考点-1"><a href="#往年考点-1" class="headerlink" title="往年考点"></a>往年考点</h5><ul>
<li>递归方程式</li>
<li>伪代码</li>
<li>时间复杂度</li>
</ul>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ul>
<li>问题需要具备的性质<ul>
<li>最优子结构性质<ul>
<li>原问题的最优解包含了子问题的最优解</li>
<li>即原问题可以由子问题的最优解组合而成</li>
</ul>
</li>
<li>子问题重叠性质<ul>
<li>子问题并不独立，有的子问题会被计算多次</li>
<li>因此算完一次后保存在一个表格中，下次用的时候只要简单的查询一下即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题**"></a>矩阵连乘问题**</h5><ul>
<li><p>题目介绍</p>
<ul>
<li>给定矩阵连乘积 A₁·A₂·…·A ₙ</li>
<li>通过结合律给连乘积加括号改变计算顺序，给出数乘计算次数最小的完全加括号方式<ul>
<li>完全加括号：每次都有确定的两个矩阵进行运算<ul>
<li>可以画成二叉树的形式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分析最优解结构</p>
<ul>
<li>A[i:j]的最优次序里A[i:k]和A[k+1:j]也是最优的</li>
<li>反证法证明</li>
</ul>
</li>
<li><p>建立递归关系</p>
<ul>
<li>设A[i:j]的最少次数是m[i,j] 则题目求的事m[1,n]</li>
<li>如果i&#x3D;j，只有一个矩阵不需要次数，m[i,i]&#x3D;0</li>
<li>如果i&lt;j,m[i,j]&#x3D;m[i,k]+m[k+1,j]+pᵢ₋₁pₖp ⱼ<ul>
<li>选择在k处断开，pᵢ₋₁pₖp ⱼ是左右两部分相乘的时候的计算量</li>
</ul>
</li>
<li>递归定义</li>
</ul>
</li>
<li><p>计算最优值</p>
</li>
<li><p>伪代码</p>
<blockquote>
<p>martixchain(p[], n, m[][] ,s[][]){<br>for i &#x3D; 1 to n&#x2F;&#x2F;初始化对角线<br>    m[i,i]&#x3D;0<br>for r &#x3D; 2 to n{&#x2F;&#x2F;r为斜线变量、指代第几条斜线<br>    for i &#x3D; 1 to n-r+1{&#x2F;&#x2F;i为这条斜线的第几个<br>        j &#x3D; i+r-1&#x2F;&#x2F;j确定了这条斜线第i个的位置<br>        m[i,j]&#x3D;m[i+1,j]+p[i-1]* p[i]* p[j]<br>        s[i,j]&#x3D;i&#x2F;&#x2F;初始化在开头第一个断开<br>        for k &#x3D; i+1 to j-1{&#x2F;&#x2F;遍历其他所有断开位置<br>            temp &#x3D; m[i,k]+m[k+1,j]+p[i-1]* p[k]* p[j]<br>            &#x2F;&#x2F;计算每种断电的计算量<br>            if(t&lt;m[i,j]){&#x2F;&#x2F;如果有更小的<br>                m[i,j] &#x3D; t&#x2F;&#x2F;更新最小值<br>                s[i,j] &#x3D; k&#x2F;&#x2F;更新最优断点<br>            }<br>        }<br>    }<br>}<br>}</p>
</blockquote>
</li>
<li><p>复杂度</p>
<ul>
<li>rik三层遍历，O(n ³)复杂度</li>
</ul>
</li>
<li><p>构造最优值</p>
<ul>
<li>每一步都已经计算了最优断点，递归回溯即可</li>
</ul>
</li>
<li><p>伪代码</p>
<blockquote>
<p>traceback(i, j, s){<br>if(i &#x3D;&#x3D; j) return<br>traceback(i, s[i,j], s)<br>traceback(s[i,j]+1, j, s)<br>cout&lt;&lt;i&lt;&lt;s[i,j]<br>cout&lt;&lt;s[i,j]+1&lt;&lt; j<br>}</p>
</blockquote>
</li>
<li><p>备注</p>
<ul>
<li>调用traceback(1, n, s)即可</li>
</ul>
</li>
<li><p>备忘录方法</p>
<ul>
<li>跟分治就很像了，只是中途要保存一下计算的结果</li>
</ul>
</li>
</ul>
<h5 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列**"></a>最长公共子序列**</h5><ul>
<li>题目介绍<ul>
<li>子序列：序列中按照顺序挑出来的一些项组成的序列（可不连续）</li>
<li>最长公共子序列：两个序列挑出来的最长公共部分</li>
</ul>
</li>
<li>分析最优解结构<ul>
<li>设序列X&#x3D;{x₁,x₂,…,xₘ}和Y&#x3D;{y₁,y₂,…,yₙ}的最长公共子序列为Z&#x3D;{z₁,z₂,…,zₖ}<ul>
<li>若xm&#x3D;yn，则zk&#x3D;xm&#x3D;yn，且Zk-1是xm-1和yn-1的最长公共子序列。</li>
<li>若xm&#x3D;̸yn且zk&#x3D;̸xm，则Z是xm-1和Y的最长公共子序列</li>
<li>若xm&#x3D;̸yn且zk&#x3D;̸yn，则Z是X和yn-1的最长公共子序列</li>
</ul>
</li>
<li>2个序列的最长公共子序列一定包含2个序列前缀的最长公共子序列</li>
</ul>
</li>
<li>建立递归关系<ul>
<li>由最长公共子序列问题的最优子结构性质建立子问题最优值的 递归关系。用c[i,j]记录序列的最长公共子序列的长度。其中，Xi&#x3D;{x1,x2,…,xi};Yj&#x3D;{y1,y2,…,yj}<ul>
<li>i和j是两个序列的结尾位置</li>
<li>情况一：i或j为0，有个是空序列，公共子序列肯定是0</li>
<li>情况二：x和y最后一个数相等，则肯定是最长公共子序列的一员，也就是排除掉这个数前面的递归定义再加上这个数</li>
<li>情况三：最后一个数不等可能是x结尾不是z 也可能是y结尾不是z，需要都进行分类并求出更大那个</li>
</ul>
</li>
</ul>
</li>
<li>计算最优值<ul>
<li>伪代码<blockquote>
<p>lcslength(m, n, x[], y[], c[,], b[,]){<br>for i in (1,m) c[i,0]&#x3D;0&#x2F;&#x2F;初始化<br>for j in (1,n) c[0,j]&#x3D;0&#x2F;&#x2F;初始化<br>for i in (1,m){<br>    for j in (1,n){<br>        if(x[i] &#x3D;&#x3D; y[j]){<br>            c[i,j]&#x3D;c[i-1,j-1]+1&#x2F;&#x2F;情况二<br>            b[i,j]&#x3D;1&#x2F;&#x2F;1表示当前数在公共子序列<br>        }<br>        else if(c[i-1,j]&gt;&#x3D;c[i,j-1]){<br>            c[i,j]&#x3D;c[i-1,j]&#x2F;&#x2F;情况三且留y更大<br>            b[i,j]&#x3D;2&#x2F;&#x2F;表示去上面找，复制的上面<br>        }<br>        else{<br>            c[i,j]&#x3D;c[i,j-1]&#x2F;&#x2F;情况三且留x更大<br>            b[i,j]&#x3D;3&#x2F;&#x2F;表示去左面找，复制的左面<br>        }<br>    }<br>}<br>}</p>
</blockquote>
</li>
</ul>
</li>
<li>复杂度<ul>
<li>O(mn)</li>
</ul>
</li>
<li>构造最优值<ul>
<li>伪代码<blockquote>
<p>LCS(i, j, x[], b[,]){&#x2F;&#x2F;参考的x序列<br>if(i &#x3D;&#x3D; 0|j &#x3D;&#x3D; 0) return<br>if(b[i,j] &#x3D;&#x3D; 1){<br>    LCS(i-1, j-1, x, b)&#x2F;&#x2F;这里是，可以输出<br>    cout&lt;&lt;x[i]	<br>}<br>else if(b[i,j] &#x3D;&#x3D; 2){<br>    LCS(i-1, j, x, b)&#x2F;&#x2F;去上面找<br>}<br>else{<br>    LCS(i, j-1, x, b)&#x2F;&#x2F;去左边找<br>}<br>}</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和**"></a>最大子段和**</h5><ul>
<li>题目介绍<ul>
<li>n个整数组成序列，求所有子序列中和最大的子序列（全部是负数的子段和视为0）</li>
</ul>
</li>
<li>分析最优解结构<ul>
<li>因为最大子段和一定不为空，所以一定至少有一项存在，所以遍历整个序列，第j项为“以第j项为最后一项的最大子段和”，这样遍历一定能扫描到最大子段和<ul>
<li>当遍历到第j项时，第j项的正负不重要，因为一定要算，只用考虑前j-1项求的最优解，如果为正，则要上前面的，如果为负则自立门户（加了不如不加）</li>
</ul>
</li>
</ul>
</li>
<li>建立递归关系</li>
<li>计算最优值<ul>
<li>伪代码<blockquote>
<p>maxSum(n, a[]){<br>sum&#x3D;0, b&#x3D;0&#x2F;&#x2F;b储存当前的最大子段和<br>for i in (1, n){&#x2F;&#x2F;遍历每一个位置<br>    if(b &gt; 0) b+&#x3D;a[i]&#x2F;&#x2F;目前为正，则带上<br>    else b &#x3D; a[i]&#x2F;&#x2F;目前为负，直接只要最新的<br>    if(b&gt;sum) sum &#x3D; b&#x2F;&#x2F;如果更新完比历史最高更高则更新<br>}<br>return sum<br>}</p>
</blockquote>
</li>
</ul>
</li>
<li>复杂度<ul>
<li>O(n)捏</li>
</ul>
</li>
</ul>
<h5 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题**"></a>0-1背包问题**</h5><ul>
<li>题目介绍<ul>
<li>给定n种物品和一背包。物品i的重量是𝑤𝑖，其价值为𝑣𝑖，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</li>
</ul>
</li>
<li>分析最优解结构<ul>
<li>最大背包的遍历点是开头，分析的是第i个及之后的物品待放入背包</li>
<li>假设m[i,j]为第i个物品之后可选且剩余容量为j的情况下的最优解，可以进行递归分析<ul>
<li>如果i&#x3D;n，说明只剩下一个物品，那能装下就装不能装下就不装</li>
<li>如果i！&#x3D;n，那么可装可不装、分类讨论<ul>
<li>如果不装，开头后移，j和m都不变</li>
<li>如果装，开头后移，j减去第i个物品重量，m加上第i个物品价值</li>
<li>两者取最大值就是此时此刻的最优解</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>建立递归关系</li>
<li>计算最优值<ul>
<li>伪代码<blockquote>
<p>knapsack(w[], v[], c, n, m[,]){<br>for j in (0,c){&#x2F;&#x2F;把最后一个安排好<br>    if(j&gt;&#x3D;w[n]){<br>        m[n,j] &#x3D; v[n]&#x2F;&#x2F;放得下，放<br>    }<br>    else{<br>        m[n,j] &#x3D; 0&#x2F;&#x2F;放不下，不妨<br>    }<br>}<br>for i in (n-1, 2){&#x2F;&#x2F;逆推<br>    for j in (0, c){&#x2F;&#x2F;每一种c都要写好方便后人查找<br>        if(j &lt; w[i]){&#x2F;&#x2F;所有装不下的<br>            m[i,j] &#x3D; m[i+1,j]&#x2F;&#x2F;不装，直接拿下面的<br>        }<br>        else{<br>            m[i,j] &#x3D; max(m[i+1,j], m[i+1,j-w[i]]+v[i])<br>            &#x2F;&#x2F;装得下，看哪个更大选哪个<br>        }<br>    }<br>}<br>m[1,c]&#x3D;m[2,c]&#x2F;&#x2F;i&#x3D;1时只考虑j&#x3D;c一种情况，节省计算<br>if(c &gt;&#x3D; w[1]){<br>    m[1,c]&#x3D;max(m[i+1,j],m[i+1,j-w[1]]+v[1]])<br>}<br>}</p>
</blockquote>
</li>
</ul>
</li>
<li>构造最优值<ul>
<li>伪代码<blockquote>
<p>traceback(){&#x2F;&#x2F;这里c是实时更新的剩余空间<br>for i in (1, n-1){<br>    if(m[i,c] &#x3D;&#x3D; m[i+1,c]){&#x2F;&#x2F;跟没拿一样，说明没拿<br>        x[i] &#x3D; 0<br>    }<br>    else{&#x2F;&#x2F;不一样说明拿了<br>        x[i] &#x3D; 1<br>        c -&#x3D; w[i]&#x2F;&#x2F;更新容量<br>    }<br>}<br>x[n] &#x3D; m[n,c]&#x2F;&#x2F;最后一个直接看当前容量装不装得下<br>}</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="第四章-贪心算法"><a href="#第四章-贪心算法" class="headerlink" title="第四章 贪心算法"></a>第四章 贪心算法</h3><h5 id="往年考点-2"><a href="#往年考点-2" class="headerlink" title="往年考点"></a>往年考点</h5><ul>
<li>问题的形式化描述（整数规划数学公式）</li>
<li>贪心策略</li>
<li>伪代码</li>
<li>时间复杂性</li>
<li>实际情况计算</li>
</ul>
<h5 id="贪心算法的基本要素"><a href="#贪心算法的基本要素" class="headerlink" title="贪心算法的基本要素"></a>贪心算法的基本要素</h5><ul>
<li>贪心选择性质<ul>
<li>整体最优解可通过一系列的局部最优解（弹性选择）来达到</li>
<li>必须证明每步所做的贪心选择最终导致问题最优解，类似如下活动安排的怎么<ul>
<li>一、证明贪心选择开始（活动1必须选）<ul>
<li>设A为活动安排最优解</li>
<li>假设有一个最优解的第一个活动不是1是k</li>
<li>把那个活动换成1也是最优解（k放得下1一定放得下，因为1是结束最早的）</li>
<li>因此1开始一定能找到一个最优解</li>
</ul>
</li>
<li>二、证明每一步的贪心选择<ul>
<li>A1为A去掉1，就是将开始时间推到1结束时的全新活动安排问题的最优解</li>
<li>假设A1不是最优解，B1是更优的解，那么把1加上得到的B就是原问题的更优解了，与A是原问题最优解矛盾</li>
<li>因此选完第一个之后的问题仍然是一个规模缩小的等价问题 仍然应该贪心的选第一个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最优子结构<ul>
<li>一个问题的最优解包含子问题的最优解（动态规划&#x2F;贪心）</li>
</ul>
</li>
</ul>
<h5 id="贪心算法一般框架"><a href="#贪心算法一般框架" class="headerlink" title="贪心算法一般框架"></a>贪心算法一般框架</h5><blockquote>
<p>greedy(C){<br>S&#x3D;{}&#x2F;&#x2F;解初始为空<br>while(not solution(S)){&#x2F;&#x2F;还没构造完解<br>    x&#x3D;select(C)&#x2F;&#x2F;贪心选择<br>    if constraint(S,x)&#x2F;&#x2F;满足约束条件<br>        S&#x3D;S+x&#x2F;&#x2F;加入最优解<br>        C&#x3D;C-x&#x2F;&#x2F;调整后选集<br>}<br>return S<br>}</p>
</blockquote>
<h5 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题*"></a>活动安排问题*</h5><ul>
<li>问题介绍<ul>
<li>n个活动都要使用一个资源并且同一时间只有一个活动使用资源，每个活动有开始时间si结束时间φ，求最大的相容子活动集合</li>
</ul>
</li>
<li>思考方法<ul>
<li>先把所有活动按照结束时间从早到晚排列</li>
<li>第一个活动一定选取，剩下的依次遍历，一碰到能选的就选</li>
</ul>
</li>
<li>伪代码<blockquote>
<p>greedyselector(){<br>a[1] &#x3D; true&#x2F;&#x2F;默认已经按照结束时间递增排列<br>j &#x3D; 1&#x2F;&#x2F;存储当前最后一个选取的活动变好<br>for i in (2, n){<br>    if(s[i]&gt;&#x3D;f[j]){<br>        a[i]&#x3D;true<br>        j &#x3D; i<br>    }<br>    else{<br>        a[i]&#x3D;false<br>    }<br>}<br>}</p>
</blockquote>
</li>
<li>复杂度<ul>
<li>递增序列：O(n)、非递增序列：O(nlogn)</li>
</ul>
</li>
<li><h2 id="背包？"><a href="#背包？" class="headerlink" title="背包？"></a>背包？</h2></li>
</ul>
<h5 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题**"></a>最优装载问题**</h5><ul>
<li>题目描述<ul>
<li>n个集装箱，每个重量为Wᵢ，船载重量为c，求不超重前提下能装的集装箱数目最大值</li>
</ul>
</li>
<li>形式化描述</li>
<li>贪心策略<ul>
<li>最轻者先装</li>
</ul>
</li>
<li>伪代码<blockquote>
<p>loading(){<br>t &#x3D; sort(x, n)&#x2F;&#x2F;先按照重量从小到大排序<br>for i in (1, n) x[i] &#x3D; 0&#x2F;&#x2F;初始化、都不装<br>for i in (1, n) &amp;&amp; w[t[i]] &lt;&#x3D; c{&#x2F;&#x2F;第i个还能装下<br>    x[t[i]] &#x3D; 1&#x2F;&#x2F;装<br>    c -&#x3D; w[t[i]]<br>}<br>}</p>
</blockquote>
</li>
<li>复杂度<ul>
<li>主要是在排序上，复杂度为O(nlogn)</li>
</ul>
</li>
</ul>
<h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码*"></a>哈夫曼编码*</h5><ul>
<li>题目描述<ul>
<li>构造最优前缀码的贪心算法</li>
</ul>
</li>
<li>贪心策略<ul>
<li>算法以｜C｜个叶子结点开始，执行｜C｜-1次合并后得到哈夫曼树T</li>
<li>贪心选择：每次合并当前频率最小的两个树，合并后产生一颗新的树，频率为两棵树之和，将新树插入到队列当中</li>
</ul>
</li>
<li>哈夫曼编码树</li>
<li>复杂度<ul>
<li>初始化优先队列需要O(n)，优先队列的出队入队都是O(logn)，一共n次合并，复杂度是O(nlogn)</li>
</ul>
</li>
</ul>
<h5 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径*"></a>单源最短路径*</h5><ul>
<li>题目描述<ul>
<li>给定带权有向图，还有一个起始点，求到每个顶点的最短路径长度</li>
</ul>
</li>
<li>贪心策略<ul>
<li>设置S记录已计算完毕的顶点，初始只有起始点v<ul>
<li>检验能到的所有点，选择路径最短的加入S</li>
<li>更新能到达的点以及距离，重复上一步</li>
</ul>
</li>
<li>当S包含所有顶点算法结束</li>
</ul>
</li>
<li>伪代码<blockquote>
<p>Dijkstra(){<br>s[]&#x2F;&#x2F;完成集合<br>for i in (1,n){&#x2F;&#x2F;初始化<br>    dist[i] &#x3D; c[v,i]&#x2F;&#x2F;存储源点到各个点距离<br>    s[i]&#x3D;false&#x2F;&#x2F;初始化<br>    if(dist[i] &#x3D;&#x3D; maxint){&#x2F;&#x2F;到不了<br>        prev[i] &#x3D; 0&#x2F;&#x2F;没有前驱<br>    }<br>    else{&#x2F;&#x2F;能到<br>        prev[i] &#x3D; v&#x2F;&#x2F;前驱设成源点<br>    }<br>}<br>dist[v] &#x3D; 0&#x2F;&#x2F;源点到自己距离为0<br>s[v] &#x3D; true&#x2F;&#x2F;源点已完成<br>for i in (1,n){<br>    temp &#x3D; maxint&#x2F;&#x2F;用于保存当前找到的最短路程<br>    int u &#x3D; v&#x2F;&#x2F;用于保存最短路程的点<br>    for j in (1,n){&#x2F;&#x2F;遍历点<br>        if((!s[j]) &amp;&amp; (dist[j]&lt;temp)){&#x2F;&#x2F;点还未完成且距离更短<br>            u &#x3D; j&#x2F;&#x2F;替换<br>            temp &#x3D; dist[j]&#x2F;&#x2F;替换<br>        }<br>    }<br>    s[u] &#x3D; true&#x2F;&#x2F;找到最小的为u点<br>    for j in (1,n){&#x2F;&#x2F;修改dist<br>        if((!s[j]) &amp;&amp; (c[u,j] &lt; maxint)){&#x2F;&#x2F;只看u能到的点<br>            newdist &#x3D; dist[u] + c[u,j]&#x2F;&#x2F;通过u走的路程<br>            if(newdist &lt; dist[j]){&#x2F;&#x2F;如果更优则替换当前路径<br>                dist[j] &#x3D; newdist<br>                prev[j] &#x3D; u<br>            }<br>        }<br>    }<br>}<br>}</p>
</blockquote>
</li>
<li>复杂度<ul>
<li>主循环体O(n),执行n-1次，复杂度O(n ²)</li>
</ul>
</li>
<li>算法正确性分析<ul>
<li>贪心选择性质</li>
</ul>
</li>
</ul>
<h3 id="第五章-回溯法"><a href="#第五章-回溯法" class="headerlink" title="第五章 回溯法"></a>第五章 回溯法</h3><h5 id="往年考点-3"><a href="#往年考点-3" class="headerlink" title="往年考点"></a>往年考点</h5><ul>
<li>解向量</li>
<li>剪枝策略</li>
<li>伪代码</li>
<li>复杂性</li>
</ul>
<h5 id="回溯法的概念"><a href="#回溯法的概念" class="headerlink" title="回溯法的概念"></a>回溯法的概念</h5><ul>
<li>解空间：<ul>
<li>一般用等长向量，所有可能的解向量构成了问题的解空间</li>
<li>解空间一般由解空间树来组织<ul>
<li>根结点第一层——搜索初始状态</li>
<li>第二层为解向量第一个分量做出选择后到达的状态</li>
<li>以此类推，根结点到叶子结点的路径构成了解空间的一个可能的解</li>
</ul>
</li>
</ul>
</li>
<li>避免无效搜索——剪枝函数<ul>
<li>约束条件剪去得不到可行解的子树</li>
<li>目标函数剪去得不到最优解的子树</li>
</ul>
</li>
<li>回溯法基本步骤<ul>
<li>定义问题的解空间</li>
<li>确定易于搜索的解空间结构</li>
<li>深度优先方式搜索解空间，用剪枝函数避免无效搜索</li>
</ul>
</li>
<li>任何时候算法都只保存从根结点到当前拓展结点到路径</li>
<li>子集树和排列树<ul>
<li>子集树：从n个元素的集合中找出满足某种性质的子集，对应的解空间称为子集树<ul>
<li>一般是n层，每个边是0&#x2F;1，代表选不选</li>
</ul>
</li>
<li>排列树：从n个元素中确定满足某种性质的排列，对应的解空间称为排列树<ul>
<li>一般也是n层，每个边是选择排的项</li>
</ul>
</li>
<li>两种问题的通用结构</li>
</ul>
</li>
</ul>
<h5 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h5><blockquote>
<p>backtrack(){<br>if(t&gt;n) output(x)&#x2F;&#x2F;t为层数，到达叶子层输出结果<br>else{&#x2F;&#x2F;还在中间节点<br>    for i in (f, g){&#x2F;&#x2F;遍历所有孩子<br>        x[t]&#x3D;h(i)&#x2F;&#x2F;构造这一位解分量<br>        if(constraint(t)&amp;&amp;bound(t))backtrack(t+1)&#x2F;&#x2F;继续深度搜索<br>    }<br>}<br>}</p>
</blockquote>
<h5 id="迭代回溯"><a href="#迭代回溯" class="headerlink" title="迭代回溯"></a>迭代回溯</h5><blockquote>
<p>iterativebacktrack(){<br>int t&#x3D;1&#x2F;&#x2F;初始层为1<br>while(t&gt;0){<br>    if(f(n,t) &lt;&#x3D; g(n,t)){<br>        for i in (f,g){<br>            x[t]&#x3D;h(i)<br>            if(constraint(t)&amp;&amp;bound(t)){<br>                if(solution(t))output(x)<br>                else t++<br>            }<br>        }<br>    }<br>    else t–<br>}<br>}</p>
</blockquote>
<h5 id="0-1背包问题-1"><a href="#0-1背包问题-1" class="headerlink" title="0-1背包问题*"></a>0-1背包问题*</h5><ul>
<li>思路<ul>
<li>子集树，从第一个物品到第n个物品，每个结点两个子树（0-不选、1-选）</li>
</ul>
</li>
<li>约束函数<ol>
<li>约束函数：重量不能超</li>
<li>上界函数：用装载法求出剩余能装的最大价值（非法值），但如果此时的价值加上这个大于实际值的非法值都比不过目前所得的最优解的话一定可以剪枝</li>
</ol>
</li>
<li>伪代码<blockquote>
<p>backtrack(i){<br>if(i&gt;n){&#x2F;&#x2F;到叶子结点则一定是最优，否则会被提前剪枝<br>    bestp &#x3D; cp<br>    return<br>}<br>if(cw+w[i]&lt;&#x3D;c){&#x2F;&#x2F;装<br>    cw+&#x3D;w[i]&#x2F;&#x2F;当前重量<br>    cp+&#x3D;p[i]&#x2F;&#x2F;当前价值<br>    backtrack(i+1)&#x2F;&#x2F;递归<br>    cw-&#x3D;w[i]&#x2F;&#x2F;还原重量<br>    cp-&#x3D;p[i]&#x2F;&#x2F;还原价值<br>}<br>if(bound(i+1) &gt; bestp){&#x2F;&#x2F;不装还有可能超过，那就试试不装<br>    backtrack(i+1)<br>}<br>}<br>bound(i){<br>cleft &#x3D; c-cw&#x2F;&#x2F;剩余容量<br>b &#x3D; cp&#x2F;&#x2F;当前价值<br>while(i &lt;&#x3D; n &amp;&amp; w[i] &lt;&#x3D; cleft){&#x2F;&#x2F;物品已经价值递减排列<br>    cleft -&#x3D; w[i]&#x2F;&#x2F;从大到小往里装<br>    b +&#x3D; p[i]<br>    i++<br>}<br>if(i &lt;&#x3D; n) b+&#x3D;p[i]* cleft&#x2F;w[i]&#x2F;&#x2F;装不下就装部分，为了求得理论最大值<br>return b&#x2F;&#x2F;返回理论最大值<br>}</p>
</blockquote>
</li>
<li>复杂度<ul>
<li>计算上界O(n),最坏情况O(2ⁿ)个有儿子需要计算</li>
<li>O(n2ⁿ)</li>
</ul>
</li>
</ul>
<h5 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h5><blockquote>
<p>loading(){<br>if(i &gt; n){&#x2F;&#x2F;成功到达，说明没被剪枝，一定是更优解<br>    bestw &#x3D; cw<br>    return<br>}<br>r -&#x3D; w[i]&#x2F;&#x2F;r记录没被装的总重量<br>if(cw+w[i] &lt;&#x3D; c){&#x2F;&#x2F;装得下<br>    cw+&#x3D;w[i]<br>    backtrack(i+1)&#x2F;&#x2F;先装试试<br>    cw-&#x3D;w[i]&#x2F;&#x2F;回溯<br>}<br>if(cw+r &gt; bestw)&#x2F;&#x2F;不装的话，剩下的都装有可能更优<br>    backtrack(i+1)&#x2F;&#x2F;那就试试不装<br>r+&#x3D;w[i]&#x2F;&#x2F;回溯<br>}</p>
</blockquote>
<h5 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后**"></a>N皇后**</h5><ul>
<li>题目介绍<ul>
<li>n* n的棋盘上放n个皇后，让他们两两不同列、行、斜线</li>
</ul>
</li>
<li>解向量（x₁···xₙ）<ul>
<li>表示第i个皇后放在第i列</li>
</ul>
</li>
<li>约束条件<ul>
<li>首先解向量的结构满足一行一个，因此不会同行</li>
<li>约束条件1:不同列——xᵢ两两不等</li>
<li>约束条件2:不同斜线|i-xᵢ|不等于|j-xⱼ|<blockquote>
<p>constraint(){<br>for j in (1,k-1){<br>    if((abs(k-j) &#x3D;&#x3D; abs(x[j]-x[k])) || (x[j] &#x3D;&#x3D; x[k]) {<br>        return false<br>    }<br>    return true<br>}<br>}<br>backtrack(t)<br>{<br>if(t&gt;n) sum++<br>else{<br>    for i in (1,n){<br>        x[t] &#x3D; i<br>        if(constraint(t)) backtrack(t+1)<br>    }<br>}<br>}</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="旅行售货员TSP"><a href="#旅行售货员TSP" class="headerlink" title="旅行售货员TSP**"></a>旅行售货员TSP**</h5><ul>
<li>题目介绍<ul>
<li>等价于n个顶点的带权无向图，找出权值最少的欧拉通路</li>
</ul>
</li>
<li>约束函数<ol>
<li>当前顶点j到顶点i没有边，则不必搜索</li>
<li>如果当前的长度已经大于当前最优解，则不必搜索<blockquote>
<p>TSP(i){<br>if(i &#x3D;&#x3D; n){&#x2F;&#x2F;已经只剩下一个结点了<br>    if(a[x[n-1],x[n]] &lt; intmax &amp;&amp; a[x[n],1] &lt; intmax &amp;&amp; (cc+a[x[n-1],x[n]]+a[x[n],1]&lt;bestc)){<br>    &#x2F;&#x2F;检查到这个结点以及这个结点回起点的路是否存在<br>    &#x2F;&#x2F;如果存在再检查新回路是否是更优解<br>        for j in (1, n){&#x2F;&#x2F;更新最优解<br>            bestx[j] &#x3D; x[j]<br>        }<br>        bestc &#x3D; cc+a[x[n-1],x[n]]+a[x[n],1]<br>        &#x2F;&#x2F;更新最优值<br>    }<br>}<br>else{<br>    for j in (i,n){<br>        if(a[x[i-1],x[j]]&lt;intmax &amp;&amp; (cc+a[x[i-1],x[j]]&lt;bestc))&#x2F;&#x2F;满足两个约束条件{<br>            swap(x[i],x[j])&#x2F;&#x2F;拿j来试试<br>            cc+&#x3D;a[x[i-1],x[i]]&#x2F;&#x2F;更新花费<br>            backtrack(i+1)&#x2F;&#x2F;递归<br>            cc-&#x3D;a[x[i-1],x[i]]&#x2F;&#x2F;还原花费<br>            swap(x[i],x[j])&#x2F;&#x2F;还回去<br>        }<br>    }<br>}<br>}</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h5 id="图着色"><a href="#图着色" class="headerlink" title="图着色"></a>图着色</h5><ul>
<li>图着色等价于给无向连通图着色</li>
<li>解向量(x1··xn)表示顶点i着色x[i]<br>可行性约束：相邻顶点着色不重复<blockquote>
<p>color_backtrack(){<br>if(t&gt;n){&#x2F;&#x2F;找到可行解<br>    sum++&#x2F;&#x2F;解个数+1<br>    output(x)&#x2F;&#x2F;输出解<br>}<br>else{<br>    for i in (1, m){&#x2F;&#x2F;针对每一种颜色<br>        x[t] &#x3D; i&#x2F;&#x2F;选择一种颜色<br>        if(constraint(t)) backtrack(t+1)&#x2F;&#x2F;如果合法则继续<br>    }<br>}<br>}<br>constraint(k)&#x2F;&#x2F;检查相邻着色是否重复<br>{<br>for j in (1, n){&#x2F;&#x2F;遍历所有顶点<br>    if((a[k,j] &#x3D;&#x3D; 1) &amp;&amp; (x[j] &#x3D;&#x3D; x[k])) return false<br>}&#x2F;&#x2F;如果有边相连并且颜色相同，返回错误<br>return true&#x2F;&#x2F;返回正确<br>}</p>
</blockquote>
</li>
<li>复杂度</li>
</ul>
<h3 id="第六章-分支界限"><a href="#第六章-分支界限" class="headerlink" title="第六章 分支界限"></a>第六章 分支界限</h3><h5 id="往年考点-4"><a href="#往年考点-4" class="headerlink" title="往年考点"></a>往年考点</h5><h5 id="与回溯法的区别"><a href="#与回溯法的区别" class="headerlink" title="与回溯法的区别"></a>与回溯法的区别</h5><ul>
<li>求解目标：<ul>
<li>回溯法：解空间树中满足约束条件的所有解</li>
<li>分支限界：找出满足约束条件的一个（最优）解</li>
</ul>
</li>
<li>搜索方式：<ul>
<li>回溯法：深度优先</li>
<li>分支限界：广度优先</li>
</ul>
</li>
</ul>
<h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><ul>
<li>分支限界类型<ul>
<li>FIFO分支限界<ul>
<li>先进先出选择下一个结点</li>
</ul>
</li>
<li>优先队列分支限界<ul>
<li>按照优先级最高的结点选择下一个结点</li>
</ul>
</li>
</ul>
</li>
<li>搜索过程<ul>
<li>确定一个限界函数，得到一个界</li>
<li>广度优先遍历解空间树<ul>
<li>到达一个结点遍历所有孩子结点</li>
<li>估算每一个孩子结点的可能取值<ul>
<li>如果超出界、丢弃、因为不可能得到最优解</li>
<li>如果在界中、依次加入活结点表</li>
</ul>
</li>
<li>从活结点表中按照特定策略选取下一个活结点拓展</li>
<li>重复上述过程知道找出最优解</li>
<li>到达一个叶子结点之后<ul>
<li>如果得到的解是一个新的最优解，则调整现在的界，重新检查活结点表、删除不满足界的活结点，回溯到还在活结点中的当前叶子结点的祖先结点继续进行拓展</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="一般化过程"><a href="#一般化过程" class="headerlink" title="一般化过程"></a>一般化过程</h5><ul>
<li>先用很宽泛的方法确定一个上下界</li>
<li>确定限界函数，可以大致估计当前结点能达到的最优情况</li>
<li>活结点表置空</li>
<li>遍历孩子结点<ul>
<li>通过限界函数求出每个孩子结点的预估值（目标函数值），如果在当前界限范围内则加入活结点表</li>
<li>选择一个预估值最大的结点，重复遍历操作</li>
</ul>
</li>
<li>如果遍历到叶子结点<ul>
<li>如果叶子结点的预估值（其实不是预估了就是实际值）大于所有活结点的预估值，那他一定是最好的，输出</li>
<li>如果叶子结点的预估值不是最大，那更新下限，要求至少要达到这个预估值，删掉活结点表中不满足条件的结点</li>
</ul>
</li>
</ul>
<h5 id="0-1背包问题-2"><a href="#0-1背包问题-2" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h5><ul>
<li>算法思想<ul>
<li>预处理：单位重量价值从大到小排序</li>
<li>目标函数：当前剩余容量全装剩余单位价值最大的物品</li>
<li>算法<ul>
<li>先检查左儿子是否合法，能装则装</li>
<li>右儿子一定合法，检查预估值够不够，够就继续</li>
<li>只要到达叶子结点就一定是最优解<ul>
<li>最优解的特征：叶子结点且预估值最大</li>
<li>在倒数第二层一定会把叶子结点添加进活结点列表</li>
<li>每次访问的一定是预估值最大的</li>
<li>所以只要访问到叶子结点就说明他是“叶子结点且预估值最大”也就是最优解</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>迭代算法<blockquote>
<p>knap(){<br>i &#x3D; 1, bestx[]<br>cw &#x3D; cp &#x3D; 0<br>bestp &#x3D; 0&#x2F;&#x2F;当前装到的最大价值，即下界<br>up &#x3D; bound(1)&#x2F;&#x2F;初始上界<br>while(i!&#x3D;n+1){<br>    wt&#x3D;cw+w[i]&#x2F;&#x2F;检查左子树，装<br>    if(wt&lt;&#x3D;c){&#x2F;&#x2F;能装下<br>        if(cp+p[i]&gt;bestp) {&#x2F;&#x2F;目前已经装的就很多了<br>            bestp&#x3D;cp+p[i]&#x2F;&#x2F;更新下界<br>        }<br>        addlivenode(up,cp+p[i],cw+w[i],true,i+1)&#x2F;&#x2F;左孩子加入活结点<br>        up&#x3D;bound(i+1)&#x2F;&#x2F;更新上界<br>    }<br>    if(up&gt;&#x3D;bestp) &#x2F;&#x2F;不装的话最大值还有可能比当前实际最大值大<br>    addlivenode(up,cp,cw,false,i+1)&#x2F;&#x2F;右孩子加入活结点<br>    heapnode N<br>    deletemax(N)&#x2F;&#x2F;拿一个当前最优点<br>    E,cw,cp,up,i &#x3D; N&#x2F;&#x2F;更新赋值<br>}<br>for j in (n,1){<br>    bestx[j] &#x3D; E-&gt;LChild<br>    E &#x3D; E-&gt;parent<br>}<br>return cp<br>}<br>bound(i){<br>cleft &#x3D; c-cw&#x2F;&#x2F;剩余容量<br>b &#x3D; cp&#x2F;&#x2F;当前价值<br>while(i &lt;&#x3D; n &amp;&amp; w[i] &lt;&#x3D; cleft){&#x2F;&#x2F;物品已经价值递减排列<br>    cleft -&#x3D; w[i]&#x2F;&#x2F;从大到小往里装<br>    b +&#x3D; p[i]<br>    i++<br>}<br>if(i &lt;&#x3D; n) b+&#x3D;p[i]* cleft&#x2F;w[i]&#x2F;&#x2F;装不下就装部分，为了求得理论最大值<br>return b&#x2F;&#x2F;返回理论最大值<br>}</p>
</blockquote>
</li>
</ul>
<h5 id="TSP旅行商问题"><a href="#TSP旅行商问题" class="headerlink" title="TSP旅行商问题**"></a>TSP旅行商问题**</h5><ul>
<li>问题上界：贪心算法<ul>
<li>贪心算法不是最优，必须比它要好</li>
</ul>
</li>
<li>问题下界：<ul>
<li>每个结点一定是一入一出，有两条边关联，则假设所有结点都关联的是自己最短的两条边，求和再除以2（每个边算了两次），可以得到一个更大的下界，但每个结点选的边不一定对的上，因此不是解</li>
</ul>
</li>
<li>目标函数（预估最优值函数）</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Alley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">http://example.com/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/">大三课程</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">大三数据库笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="大三操作系统笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">大三操作系统笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三数据库笔记</div></div></a></div><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三编译原理笔记</div></div></a></div><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="大三操作系统笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三操作系统笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alley</div><div class="author-info__description">学习与生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 算法引论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">1.0.1.</span> <span class="toc-text">算法时间复杂性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.0.2.</span> <span class="toc-text">算法复杂度分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E9%80%92%E5%BD%92%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.3.</span> <span class="toc-text">求解线性递归关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%AE%9A%E7%90%86%E8%AE%A1%E7%AE%97%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.0.4.</span> <span class="toc-text">主定理计算递推关系复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB"><span class="toc-number">2.</span> <span class="toc-text">第二章 递归与分治</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E8%80%83%E7%82%B9"><span class="toc-number">2.0.1.</span> <span class="toc-text">往年考点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.2.</span> <span class="toc-text">递归的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.0.3.</span> <span class="toc-text">分治法的基本思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">2.0.4.</span> <span class="toc-text">二分搜索*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.5.</span> <span class="toc-text">归并排序**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.6.</span> <span class="toc-text">快速排序**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-number">2.0.7.</span> <span class="toc-text">线性时间选择**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.8.</span> <span class="toc-text">最接近点对问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.</span> <span class="toc-text">第三章 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E8%80%83%E7%82%B9-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">往年考点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">3.0.2.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98"><span class="toc-number">3.0.3.</span> <span class="toc-text">矩阵连乘问题**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.0.4.</span> <span class="toc-text">最长公共子序列**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="toc-number">3.0.5.</span> <span class="toc-text">最大子段和**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.0.6.</span> <span class="toc-text">0-1背包问题**</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">第四章 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E8%80%83%E7%82%B9-2"><span class="toc-number">4.0.1.</span> <span class="toc-text">往年考点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">4.0.2.</span> <span class="toc-text">贪心算法的基本要素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E6%A1%86%E6%9E%B6"><span class="toc-number">4.0.3.</span> <span class="toc-text">贪心算法一般框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.4.</span> <span class="toc-text">活动安排问题*</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">背包？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-number">0.0.1.</span> <span class="toc-text">最优装载问题**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">0.0.2.</span> <span class="toc-text">哈夫曼编码*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">0.0.3.</span> <span class="toc-text">单源最短路径*</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">第五章 回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E8%80%83%E7%82%B9-3"><span class="toc-number">1.0.1.</span> <span class="toc-text">往年考点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.2.</span> <span class="toc-text">回溯法的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">递归回溯</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.0.4.</span> <span class="toc-text">迭代回溯</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.0.5.</span> <span class="toc-text">0-1背包问题*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.6.</span> <span class="toc-text">装载问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E"><span class="toc-number">1.0.7.</span> <span class="toc-text">N皇后**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%85%E8%A1%8C%E5%94%AE%E8%B4%A7%E5%91%98TSP"><span class="toc-number">1.0.8.</span> <span class="toc-text">旅行售货员TSP**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9D%80%E8%89%B2"><span class="toc-number">1.0.9.</span> <span class="toc-text">图着色</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90"><span class="toc-number">2.</span> <span class="toc-text">第六章 分支界限</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%80%E5%B9%B4%E8%80%83%E7%82%B9-4"><span class="toc-number">2.0.1.</span> <span class="toc-text">往年考点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.2.</span> <span class="toc-text">与回溯法的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.3.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">2.0.4.</span> <span class="toc-text">一般化过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-2"><span class="toc-number">2.0.5.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TSP%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.6.</span> <span class="toc-text">TSP旅行商问题**</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记">大三数据库笔记</a><time datetime="2024-05-21T11:07:55.000Z" title="Created 2024-05-21 19:07:55">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记">大三算法笔记</a><time datetime="2024-05-21T11:04:16.000Z" title="Created 2024-05-21 19:04:16">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="大三操作系统笔记">大三操作系统笔记</a><time datetime="2024-05-21T11:00:36.000Z" title="Created 2024-05-21 19:00:36">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记">大三编译原理笔记</a><time datetime="2024-05-21T10:58:47.000Z" title="Created 2024-05-21 18:58:47">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%BA%8C%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AC%94%E8%AE%B0/" title="大二自动机笔记">大二自动机笔记</a><time datetime="2024-05-21T10:54:06.000Z" title="Created 2024-05-21 18:54:06">2024-05-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Alley</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>