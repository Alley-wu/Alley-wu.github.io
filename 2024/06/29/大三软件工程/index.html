<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>大三软件工程 | Alley的博客</title><meta name="author" content="Alley"><meta name="copyright" content="Alley"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 软件工程概述软件的定义 IEEE定义:软件是计算机程序、规程以及运行计算机系统所需要的文档和数据 Wirth中指出:   在结构化程序设计:程序&#x3D;算法+数据结构 在软件工程中:软件&#x3D;程序+文档   另一种对软件的公认解释是:软件是包括程序、数据及其相关文档的完整集合 程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品  软件危机 2">
<meta property="og:type" content="article">
<meta property="og:title" content="大三软件工程">
<meta property="og:url" content="http://example.com/2024/06/29/%E5%A4%A7%E4%B8%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.html">
<meta property="og:site_name" content="Alley的博客">
<meta property="og:description" content="第一章 软件工程概述软件的定义 IEEE定义:软件是计算机程序、规程以及运行计算机系统所需要的文档和数据 Wirth中指出:   在结构化程序设计:程序&#x3D;算法+数据结构 在软件工程中:软件&#x3D;程序+文档   另一种对软件的公认解释是:软件是包括程序、数据及其相关文档的完整集合 程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品  软件危机 2">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-06-29T12:22:03.000Z">
<meta property="article:modified_time" content="2024-07-05T13:03:09.251Z">
<meta property="article:author" content="Alley">
<meta property="article:tag" content="大三课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/06/29/%E5%A4%A7%E4%B8%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '大三软件工程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-05 21:03:09'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="/live2d-widget/autoload.js"> </script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Alley的博客"><span class="site-name">Alley的博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">大三软件工程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-29T12:22:03.000Z" title="Created 2024-06-29 20:22:03">2024-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-07-05T13:03:09.251Z" title="Updated 2024-07-05 21:03:09">2024-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="大三软件工程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h2><h3 id="软件的定义"><a href="#软件的定义" class="headerlink" title="软件的定义"></a>软件的定义</h3><ul>
<li>IEEE定义:软件是计算机程序、规程以及运行计算机系统所需要的文档和数据</li>
<li>Wirth中指出:  <ul>
<li>在结构化程序设计:程序&#x3D;算法+数据结构</li>
<li>在软件工程中:软件&#x3D;程序+文档</li>
</ul>
</li>
<li>另一种对软件的公认解释是:<span style="background:#fff88f">软件是包括程序、数据及其相关文档的完整集合</span></li>
<li>程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品</li>
</ul>
<h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><ul>
<li>20世纪60年代后，随着计算机软件应用领域增多，软件规模不断扩大，软件系统 功能多，逻辑复杂，不断扩充，从而导致许多系统开发出现了不良的后果:<ul>
<li>系统存在大量错误，可用性和可靠性差; • 系统无法增加新功能，难于维护;  </li>
<li>系统无法按照计划时间完成;  </li>
<li>..等因素</li>
<li>导致很多软件系统的彻底失败</li>
</ul>
</li>
<li>所谓软件危机就是计算机软件在开发和维护过程中所遇到的一系列严重问题，导致了软件行业的信任危机，具体表现在:<ul>
<li>软件开发成本难以估算，无法制定合理的开发计划</li>
<li>用户的需求无法确切表达</li>
<li>软件质量存在问题</li>
<li>软件的可维护性差</li>
<li>缺乏文档资料</li>
</ul>
</li>
</ul>
<h3 id="软件危机的解决途径"><a href="#软件危机的解决途径" class="headerlink" title="软件危机的解决途径"></a>软件危机的解决途径</h3><ul>
<li>产生软件危机的原因<ul>
<li>软件系统本身的复杂性</li>
<li>软件开发的方法和技术不合理及不成熟</li>
</ul>
</li>
<li>软件工程方法<ul>
<li>1968年 Friedrich Ludwig (Fritz) Bauer 提出运用工程化原则和方法，组织软件开发解决软件危机，并提出“软件工程 Software Engineering”的概念。</li>
</ul>
</li>
</ul>
<h3 id="软件工程要素"><a href="#软件工程要素" class="headerlink" title="软件工程要素"></a>软件工程要素</h3><ul>
<li><span style="background:#fff88f">软件工程三要素: 方法、工具和过程</span><ul>
<li>方法: 提供了“如何做”的技术</li>
<li>工具: 提供了自动或半自动的软件支撑环境</li>
<li>过程: 将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的</li>
</ul>
</li>
<li>**<span style="background:#fff88f">软件工程的目标：在给定成本和时间的前提下</span>，开发出满足用户需求且具有<span style="background:#fff88f">正确性、可用性</span>等因素的软件产品</li>
<li>软件工程的终极目标：摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化</li>
</ul>
<h2 id="第二章-软件生命周期模型"><a href="#第二章-软件生命周期模型" class="headerlink" title="第二章 软件生命周期模型"></a>第二章 软件生命周期模型</h2><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><ul>
<li>&#x3D;&#x3D;软件工程过程&#x3D;&#x3D;是为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动。主要活动：<ul>
<li>软件规格说明：规定软件功能及其使用限制。</li>
<li>软件开发：产生满足规格说明的软件。</li>
<li>软件确认：通过有效性验证以保证软件能够满足客户要求。</li>
<li>软件演进：为了满足客户变更要求，软件在使用过程中不断地改进</li>
</ul>
</li>
<li>软件生命周期: 指软件产品从考虑其概念开始，到该软件产品不再使用为止的整个时期，一般包括&#x3D;&#x3D;概念阶段、分析与设计阶段、构造阶段、移交和运行阶段&#x3D;&#x3D;等不同时期。</li>
<li>软件生命周期的六个基本步骤<ul>
<li><span style="background:#fff88f">制定计划</span> (P)</li>
<li><span style="background:#fff88f">需求分析</span> (D)</li>
<li><span style="background:#fff88f">设计</span> (D)</li>
<li><span style="background:#fff88f">程序编码</span> (D)</li>
<li><span style="background:#fff88f">测试</span> (C)</li>
<li><span style="background:#fff88f">运行维护</span> (A)</li>
</ul>
</li>
</ul>
<h3 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h3><ul>
<li>软件过程模型: 从一个特定角度提出的对软件过程的概括描述，是对软件开发实际过程的抽象，包括构成软件过程的各种<span style="background:#fff88f">活动 </span>(Activities)、<span style="background:#fff88f">软件工件</span> (artifacts) <span style="background:#fff88f">以及参与角色</span> (Actors&#x2F;Roles) 等</li>
<li><span style="background:#fff88f">软件生命周期模型</span>是一个框架，描述从软件需求定义直至软件经使用后废弃为止，跨越整个生存期的软件开发、运行和维护所实施的全部<span style="background:#fff88f">过程、活动和任务</span>，同时<span style="background:#fff88f">描述生命周期不同阶段产生的软件工件，明确活动的执行角色等。</span></li>
</ul>
<h3 id="传统模型种类"><a href="#传统模型种类" class="headerlink" title="传统模型种类"></a>传统模型种类</h3><ul>
<li><p>瀑布模型<br>  <img src="/prtsc/test2.png"></p>
<ul>
<li>**<span style="background:#fff88f">是所有其他软件生命周期模型的基础</span></li>
<li>瀑布模型中的每一个开发活动具有下列特征:<ul>
<li>本活动的工作对象来自于上一项活动的输出，这些输出一般是代表该阶段活动结束的里程碑式的文档。</li>
<li>根据本阶段的活动规程执行相应的任务。</li>
<li>产生本阶段活动相关产出—软件工件，作为下一活动的输入。</li>
</ul>
</li>
<li>优点:<ul>
<li>降低了软件开发的复杂程度，提高了软件开发过程的透明性及软件开发过程的可管理性</li>
<li><span style="background:#fff88f">推迟了软件实现，强调在软件实现前必须进行分析和设计工作</span></li>
<li>以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，从而能够使产品达到预期的质量要求。</li>
</ul>
</li>
<li>缺点:<ul>
<li>模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题。</li>
<li>模型的风险控制能力较弱。</li>
<li>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量；而且当管理人员以文档的完成情况来评估项目完成进度时，往往会产生错误的结论。</li>
</ul>
</li>
</ul>
</li>
<li><p>演化模型<br>  <img src="/prtsc/abc.png"></p>
<ul>
<li>使用瀑布模型人们认识到，由于需求很难调研充分，所以很难一次性开发成功。</li>
<li>演化模型提倡两次开发:<ul>
<li>第一次是试验开发，得到试验性的原型产品，其目标只是在于探索可行性，弄清软件需求;</li>
<li>第二次在此基础上获得较为满意的软件产品。</li>
</ul>
</li>
<li>优点: <ul>
<li>明确用户需求</li>
<li>提高系统质量</li>
<li>降低开发风险;</li>
</ul>
</li>
<li>缺点:<ul>
<li>难于管理、结构较差、技术不成熟;</li>
<li>可能会抛弃瀑布模型的文档控制优点;</li>
<li>可能会导致最后的软件系统的系统结构较差;</li>
</ul>
</li>
<li>演化模型适用范围:<ul>
<li>需求不清楚;</li>
<li>小型或中小型系统;</li>
<li>开发周期短。</li>
</ul>
</li>
</ul>
</li>
<li><p>增量模型<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2010.41.18.png"></p>
<ul>
<li>增量模型<span style="background:#fff88f">结合瀑布模型和演化模型的优点</span><ul>
<li>待开发增量的选择是依照优先级确定的，核心需求的优先级较高，一般在最初的增量中解决</li>
<li>一旦一个增量开发完成，客户就可以使用实现核心需求的部分产品，并对其进行评价，反馈需求修改和补充意见</li>
</ul>
</li>
<li>优点<ul>
<li>客户可以在第一次增量后使用系统的核心功能</li>
<li>项目总体失败的风险较低</li>
<li>最高优先级的功能得到最多次的测试，保障系统重要功能部分</li>
<li>所有增量都是在同一个体系结构指导下进行集成的，提高系统的稳定度和可维护度</li>
</ul>
</li>
<li>缺点<ul>
<li>增量的粒度选择问题</li>
<li>确定所有的基本业务服务比较困难</li>
</ul>
</li>
</ul>
</li>
<li><p>喷泉模型<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2010.59.44.png"></p>
<ul>
<li>喷泉模型认为软件开发过程的各个阶段是相互重叠和多次反复的，功能模块不是一次完成，而是像喷泉，水喷上去又可以落下来，既可以落在中间，又可以落到底部</li>
<li>各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求</li>
<li>优点<ul>
<li>提高软件项目开发效率</li>
<li>节省开发时间</li>
</ul>
</li>
<li>缺点<ul>
<li>管理困难</li>
</ul>
</li>
</ul>
</li>
<li><p>V模型和W模型<span style="background:#fff88f">（不重要）</span></p>
<ul>
<li>瀑布模型将测试作为软件实现之后的 一个独立阶段，使得在分析和设计阶段潜在的错误得到纠正的时机大推迟，造成较大的返工成本</li>
<li>针对瀑布模型的这个缺点，20世纪80年代后期，Paul Rook提出了V模型<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2011.34.05.png"><ul>
<li>V 模型明确地划分测试的级别，并将其与开发阶段的活动对应</li>
<li>缺点<ul>
<li>保留了瀑布模型的缺点，即将测试作为一个独立的阶段，所以并没有提高模型抵抗风险能力</li>
</ul>
</li>
</ul>
</li>
<li>Evolutif公司在V模型的基础上提出了W模型<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2011.38.02.png"><ul>
<li>W模型强调:测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求和设计同样需要测试，即测试与开发是同步进行的</li>
<li>缺点<ul>
<li>并没有改变瀑布模型中需求、设计和编码等活动的串行关系</li>
<li>同时，测试和开发活动也保持一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段的工作</li>
<li>只适合需求比较稳定的软件项目</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>螺旋模型（不重要）</p>
</li>
<li><p><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2011.28.58.png"></p>
<ul>
<li>螺旋模型的每个回路被分在4个象限上，分别表达4个方面的活动<ul>
<li>制订计划：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素，制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划</li>
<li>风险分析：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并制定风险管理措施规避这些风险</li>
<li>实施工程：针对每一个开发阶段的任务要求执行本开发阶段的活动</li>
<li>客户评估：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其开发过程进行评审，决定是否进入螺旋线的下一个回路</li>
</ul>
</li>
<li>优点<ul>
<li>适合于大型软件的开发。它吸收演化模型的“演化”概念，要求开发人员和客户对每个演化过程中出现的风险进行分析，并采取相应的规避措施</li>
</ul>
</li>
<li>缺点<ul>
<li>风险分析需要相当丰富的评估经验，风险规避又需要深厚的专业知识，这给螺旋模型的应用增加了难度</li>
</ul>
</li>
</ul>
</li>
<li><p>构件组装模型（不重要）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2011.40.10.png"></p>
<ul>
<li>将整个系统模块化，并在一定构件模型的支持下复用构件库中的一个或多个软件构件，通过组装高效率、高质量地构造软件系统</li>
<li>构件组装模型本质上是演化的，开发过程是迭代的</li>
<li>构件组装模型的开发过程就是构件组装的过程，维护的过程就是构件升级、替换和扩充的过程。</li>
<li>优点<ul>
<li>充分利用软件复用，提高软件开发的效率。构件可由一方定义其规格说明，被另一方实现，然后供给第三方使用</li>
<li>允许多个项目同时开发，降低费用，提高可维护性，可实现分步提交软件产品</li>
</ul>
</li>
<li>缺点<ul>
<li>缺乏通用的构件组装结构标准，风险较大</li>
<li>构件可重用性和系统高效性之间不易协调</li>
<li>由于过分依赖于构件，构件质量影响着最终产品的质量</li>
</ul>
</li>
</ul>
</li>
<li><p>快速应用开发模型<br>  ![[截屏2024-06-20 11.44.20.png|500]]</p>
<ul>
<li>是一种增量型的软件开发过程模型，强调极短的开发周期</li>
<li>优点<ul>
<li>大量使用可复用构件加快开发速度，对管理信息系统的开发特别有效</li>
</ul>
</li>
<li>缺点<ul>
<li>并非所有应用都适合采用RAD</li>
<li>由于时间约束，开发人员和客户必须在较短的时间内完成一系列的需求分析，沟通配合不当都会导致应用RAD模型的失败</li>
<li>RAD适合于管理信息系统的开发，对于其他类型的应用系统，如技术风险较高、与外围系统的互操作性较高等，不太合适</li>
</ul>
</li>
</ul>
</li>
<li><p>原型方法（不重要）<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2014.12.05.png"></p>
<ul>
<li>完整而准确的需求规格说明是很难一次性得到，因为：<ul>
<li>在开发早期用户往往对系统只有一个模糊的想法，很难完全准确地表达对系统的全面要求</li>
<li>随着开发工作的推进，用户可能会产生新的要求</li>
<li>开发者又可能在设计与实现的过程中遇到一些没有预料到的实际困难，需要以改变需求来解脱困境</li>
</ul>
</li>
<li>定义<ul>
<li>原型指模拟某种最终产品的原始模型；</li>
<li>原型方法指在获得一组基本需求后，通过快速分析构造出一个小型的软件系统原型，满足用户的基本要求。</li>
<li>用户通过使用原型系统，提出修改意见，从而减少用户与开发人员对系统需求的误解，使需求尽可能准确。</li>
<li>原型方法主要用于明确需求，但也可以用于软件开发的其他阶段</li>
</ul>
</li>
<li>在软件开发过程中，原型是软件的一个早期可运行的版本，反映最终系统的部分重要特性</li>
<li>对于需求的变更，可以在变更后的原型版本中调整，从而提高最终产品的质量</li>
<li>类型<ul>
<li>废弃策略:<ul>
<li>探索型：目的是明确用户对目标系统的要求，确定所期望的特性，并探讨多种实现方案的技术可行性</li>
<li>实验型：用于大规模开发和实现之前，考核技术实现方案是否合适，分析和设计的规格说明是否可靠</li>
</ul>
</li>
<li>追加策略：<ul>
<li>进化型：这种原型的目的是在构造系统的过程中能够适应需求的变化，通过不断地 改进原型，逐步将原型进化成最终的系统</li>
</ul>
</li>
</ul>
</li>
<li>优点<ul>
<li>原型方法有助于快速理解用户对于需求的真实想法</li>
<li>可以容易地确定系统的性能，确认各项主要系统服务可应用，确认系统设计可行，以及确认系统作为产品的结果</li>
<li>软件原型的最终版本，有的可以原封不动地成为产品，有的稍加修改就可以成为最终系统的一个组成部分，这样有利于建成最终系统</li>
</ul>
</li>
<li>缺点<ul>
<li>对于一个大型系统，如果不经过系统分析得到系统的整体划分，那么直接使用原型来模拟系统部件是很困难的</li>
<li>对于大量运算且逻辑较强的程序模块，原型方法很难构造出该模块的原型用于评价</li>
<li>对于原有应用的业务流程、信息流程混乱的情况，原型构造与使用有一定的困难</li>
</ul>
</li>
<li>问题<ul>
<li>文档容易被忽略</li>
<li>建立原型的许多工作会被浪费掉</li>
<li>项目难以规划和管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="新型软件生命周期模型"><a href="#新型软件生命周期模型" class="headerlink" title="新型软件生命周期模型"></a>新型软件生命周期模型</h3><ul>
<li>RUP<ul>
<li>RUP(Rational Unified Process)是由Rational公司(现被IBM公司收购)开发的一种软件工程过程框架，是一个基于面向对象的程序开发方法论。</li>
<li>RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中</li>
<li>基本结构<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2014.16.47.png"></li>
<li><span style="background:#fff88f">四个主要阶段</span><ul>
<li><span style="background:#fff88f">初始阶段</span> (Inception)</li>
<li><span style="background:#fff88f">细化阶段</span> (Elaboration)</li>
<li><span style="background:#fff88f">构造阶段</span> (Construction)</li>
<li><span style="background:#fff88f">交付阶段</span> (Transition)。</li>
</ul>
</li>
<li>每个阶段结束于一个主要的<span style="background:#fff88f">里程碑</span>，并在阶段结尾执行一次评估以确定这个阶段的目标是否已经满足。如果评估结果令人满意的话，可以允许项目进入下一个阶段<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-20%2014.17.42.png"></li>
</ul>
</li>
<li>敏捷及极限编程<ul>
<li>敏捷建模(Agile Modeling，AM)是由Scott W. Ambler从许多的软件开发过程实践中归纳总结出来的一些敏捷建模价值观、原则和实践等组成的，它是快速软件开发的一种思想代表，具体的应用有极限编程、SCRUM、水晶、净室开发等。</li>
<li>2001年敏捷联盟成立，其主要特点就是具有快速及灵活的响应变更的能力</li>
</ul>
</li>
</ul>
<h2 id="第三章-软件需求分析"><a href="#第三章-软件需求分析" class="headerlink" title="第三章 软件需求分析"></a>第三章 软件需求分析</h2><h3 id="需求分析的对象、任务和目标"><a href="#需求分析的对象、任务和目标" class="headerlink" title="需求分析的对象、任务和目标"></a>需求分析的对象、任务和目标</h3><ul>
<li><span style="background:#fff88f">软件需求分析的对象: 用户要求</span>。</li>
<li>软件需求分析的任务是: 准确地定义新系统的目标，回答系统必须“做什么”的问题并编制需求规格说明书。</li>
<li><span style="background:#fff88f">需求分析的目标: 借助于当前(业务)系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的“做什么”的问题</span>。<img src="/../prtsc/Pasted%20image%2020240620150248.png"></li>
<li>用户需求说明书与软件需求规格说明书的区别：前者主要采用自然语言来表达用户需求，后者采用规范的建模语言表示。&#x3D;&#x3D;后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求。软件需求规格说明书是软件系统设计的直接依据&#x3D;&#x3D;</li>
</ul>
<h3 id="数据、功能及行为建模"><a href="#数据、功能及行为建模" class="headerlink" title="数据、功能及行为建模"></a>数据、功能及行为建模</h3><ul>
<li><span style="background:#fff88f">数据模型</span>:<ul>
<li>信息内容和关系</li>
<li>信息流</li>
<li>信息结构</li>
</ul>
</li>
<li><span style="background:#fff88f">功能模型</span>:<ul>
<li>对进入软件的信息和数据进行变换和处理的模块，它必须至少完成三个常见功能：输入、处理、输出</li>
</ul>
</li>
<li><span style="background:#fff88f">行为模型</span>:<ul>
<li>大多数软件对来自外界的事件做出反应，这种刺激&#x2F;反应特征形成了行为模型的基础。行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示。</li>
</ul>
</li>
</ul>
<h3 id="需求类别"><a href="#需求类别" class="headerlink" title="需求类别"></a>需求类别</h3><ul>
<li><span style="background:#fff88f">功能需求</span>：<ul>
<li>列举出所开发软件在功能上应做什么，这是最主要的需求</li>
</ul>
</li>
<li><span style="background:#fff88f">性能需求</span>: <ul>
<li>给出所开发软件的技术性能指标，尤其是系统的实时性和其他时间要求，如响应时间、处理时间、消息传送时间等；资源配置要求，精确度，数据处理量等要求。</li>
</ul>
</li>
<li><span style="background:#fff88f">环境需求</span>: 是对软件系统运行时所处环境的要求。<ul>
<li>在硬件方面，采用什么机型、有什么外部设备、数据通信接口等等。</li>
<li>在软件方面，采用什么支持系统运行的系统软件 (指操作系统、数据库管理系统等)。</li>
<li>在使用方面，需要使用部门在制度上、操作人员的技术水平上应具备什么样的条件等等。</li>
</ul>
</li>
</ul>
<h3 id="其他需求类别"><a href="#其他需求类别" class="headerlink" title="其他需求类别"></a>其他需求类别</h3><ul>
<li>可靠性需求: <ul>
<li>指软件的有效性和数据完整性。各种软件在运行时失效的影响各不相同。在需求分析时，应对所开发软件在投入运行后不发生故障的概率，按实际的运行环境提出要求。</li>
</ul>
</li>
<li>安全保密要求: <ul>
<li>工作在不同环境的软件对其安全、保密的要求显然是不同的，应当把这方面的需求恰当地做出规定。</li>
</ul>
</li>
<li>用户界面需求: <ul>
<li>软件与用户界面的友好性是用户能够方便有效愉快地使用该软件的关键之一。</li>
</ul>
</li>
<li>资源使用需求: <ul>
<li>指所开发软件运行时所需的数据、软件、内存空间等各项资源，以及软件开发时所需的人力、支撑软件、开发设备等。</li>
</ul>
</li>
<li>软件成本消耗与开发进度需求: <ul>
<li>在软件项目立项后，要根据合同规定，对软件开发的进度和各步骤的费用提出要求，作为开发管理的依据。</li>
</ul>
</li>
<li>预先估计以后系统可能达到的目标: <ul>
<li>在开发过程中，可对系统将来可能的扩充与修改做准备。一旦需要时，就比较容易进行补充和修改。</li>
</ul>
</li>
</ul>
<h2 id="第四章-面向对象需求分析方法"><a href="#第四章-面向对象需求分析方法" class="headerlink" title="第四章 面向对象需求分析方法"></a>第四章 面向对象需求分析方法</h2><h3 id="UML-4-1视图的作用"><a href="#UML-4-1视图的作用" class="headerlink" title="UML 4+1视图的作用"></a>UML 4+1视图的作用</h3><ul>
<li>UML：面向对象的统一<span style="background:#fff88f">建模</span>语言。是一种<span style="background:#fff88f">建模语言规格说明</span>，是一种标准。不是过程也不是方法，但允许任何一种过程和方法使用它![[截屏2024-06-21 15.57.57.png|350]]</li>
<li><span style="background:#fff88f">用例视图</span>: ——用例图<ul>
<li>强调从用户的角度看到的或需要的系统功能，这种视图也叫做用户模型视图或场景视图</li>
</ul>
</li>
<li><span style="background:#fff88f">逻辑视图</span>: ——类图、对象图、顺序图&#x2F;协作图<ul>
<li>展现系统的静态或结构组成及特征，也称为结构模型视图或静态视图;</li>
</ul>
</li>
<li><span style="background:#fff88f">进程视图</span>: ——状态图、活动图<ul>
<li>描述设计的并发和同步等特性，关注系统非功能性需求，也称为行为模型视图、过程视图、协作视图和动态视图;</li>
</ul>
</li>
<li><span style="background:#fff88f">构件视图</span>: ——构件图<ul>
<li>关注软件代码的静态组织与管理，也称为实现模型视图和开发视图</li>
</ul>
</li>
<li><span style="background:#fff88f">部署视图</span>: ——部署图<ul>
<li>描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求(性能、可靠性等)，也称为环境模型视图或物理视图;</li>
</ul>
</li>
</ul>
<h3 id="UML的9个基本图"><a href="#UML的9个基本图" class="headerlink" title="UML的9个基本图"></a>UML的9个基本图</h3><ul>
<li><span style="background:#fff88f">用例图</span>: <ul>
<li>描述系统的功能;</li>
</ul>
</li>
<li><span style="background:#fff88f">类图</span>: <ul>
<li>描述系统的静态结构(类及其相互关系);</li>
</ul>
</li>
<li><span style="background:#fff88f">对象图</span>: <ul>
<li>描述系统在某个时刻的静态结构(对象及其相互关系);</li>
</ul>
</li>
<li><span style="background:#fff88f">顺序图</span>: <ul>
<li>按时间顺序描述系统元素间的交互;</li>
</ul>
</li>
<li><span style="background:#fff88f">协作图</span>: <ul>
<li>按照时间和空间的顺序描述系统元素间的交互和它们之间的关系;</li>
</ul>
</li>
<li><span style="background:#fff88f">状态图</span>: <ul>
<li>描述了系统元素的状态条件和响应;</li>
</ul>
</li>
<li><span style="background:#fff88f">活动图</span>: <ul>
<li>描述了系统元素之间的活动;</li>
</ul>
</li>
<li>构件图: <ul>
<li>描述了实现系统的元素组织;</li>
</ul>
</li>
<li>部署图: <ul>
<li>描述了环境元素的配置并把实现系统的元素映射到配置上。</li>
</ul>
</li>
</ul>
<h3 id="面向对象的需求分析建模"><a href="#面向对象的需求分析建模" class="headerlink" title="面向对象的需求分析建模"></a>面向对象的需求分析建模</h3><ul>
<li>面向对象分析方法中的需求分析包含两个模型: 领域模型和用例模型<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.25.29.png"><ul>
<li>领域模型表示了需求分析阶段“当前系统”逻辑模型的静态结构及业务流程;</li>
<li>用例模型是“目标系统”的逻辑模型，定义了“目标系统”做什么的需求。由以下四个部分组成:<ul>
<li>用例图</li>
<li>用例说明</li>
<li>系统顺序图</li>
<li>操作契约</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><ul>
<li>领域模型: 针对某一特定领域内<span style="background:#fff88f">概念类</span>或者<span style="background:#fff88f">对象</span>的抽象可视化表示。</li>
<li>主要用于概括地描述<span style="background:#fff88f">业务背景</span>及重要的<span style="background:#fff88f">业务流程</span>，并通过UML的类图和活动图进行展示，帮助软件开发人员在短时间内了解业务。<ul>
<li><span style="background:#fff88f">业务背景</span>: 可由需求定义或者用例说明中具有代表业务概念或者业务对象的词汇获得，这些词汇可统称为“概念类”，并通过能够代表关系的词汇建立概念类之间的关系，表示成能够代表业务知识结构的<span style="background:#fff88f">类图</span>。</li>
<li><span style="background:#fff88f">业务流程</span>: 一般由角色及其执行的活动(活动及任务节点)构成，活动的输出一般有数据对象和传给另一个活动的消息组成，建议使用UML的<span style="background:#fff88f">活动图</span>进行描述。</li>
</ul>
</li>
</ul>
<h3 id="创建领域模型的步骤"><a href="#创建领域模型的步骤" class="headerlink" title="创建领域模型的步骤"></a>创建领域模型的步骤</h3><ul>
<li>理解领域模型对理解系统需求至关重要，领域模型的创建步骤如下:<ul>
<li>第1步，找出当前需求中的<span style="background:#fff88f">候选概念类</span>;</li>
<li>第2步，在领域模型中描述这些<span style="background:#fff88f">概念类</span>。用问题域中的词汇对概念类进行命名，将与当前需求无关的概念类排除在外。</li>
<li>第3步，在概念类之间<span style="background:#fff88f">添加必要的关联</span>来记录那些需要保存记忆的关系，概念之间的关系用关联、继承、组合&#x2F;聚合来表示。</li>
<li>第4步，在概念类中<span style="background:#fff88f">添加</span>用来实现需求的必要<span style="background:#fff88f">属性</span>。</li>
</ul>
</li>
</ul>
<h3 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h3><ul>
<li>依赖（途中使用了一下你的方法）<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.29.04.png"><ul>
<li>类A 把 类B 的实例作为方法里的参数使用;</li>
<li>类A 的某个方法里使用了类B的实例作为局部变量;</li>
<li>类A 调用了类B的静态方法。</li>
</ul>
</li>
<li>关联（你是我的一个属性）![[截屏2024-06-21 11.29.45.png]]<ul>
<li>一个类可以将另一个类的某些属性或者类对象的整体作为其属性时，它们之间就存在关联关系</li>
<li>如果只有一边是另一边的属性，那么则是单向箭头<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.31.58.png"></li>
</ul>
</li>
<li>聚合（拥有但不独有，别人也可以有）<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.34.19.png"><ul>
<li>一个类A拥有另一个类B，同时其他的类C也可分享类B，即类B 不完全被类A所拥有时</li>
<li>部分类的对象不会因整体类消失而不存在，这是聚合关系与组合关系之间最重要的区别</li>
</ul>
</li>
<li>组合（完全占有，组成部分）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.35.49.png" alt="|400"><ul>
<li>一个类A完全拥有另一个类B，且其他任何类都不能分享类B时</li>
<li>当整体类消失时，部分类也不会存在</li>
</ul>
</li>
<li>继承（父子关系）<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.37.51.png"><ul>
<li>一个类(父类)是另外一个类或一些类(子类)的类型时，它们之间存在继承或者泛化关系</li>
<li>子类可以拥有父类所有的属性和操作，且可以定义自身的 一些属性和操作，这种关系充分体现面向对象强调的软件复用原则</li>
</ul>
</li>
<li>关联类（跟某个关系相关的类）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.39.10.png" alt="|475"><ul>
<li>在关联建模中，存在一些情况下，需要其他类，因为它包含关于关联有价值的信息。对于这种情况，使用关联类来绑定这些基本关联</li>
</ul>
</li>
</ul>
<h3 id="用例模型"><a href="#用例模型" class="headerlink" title="用例模型"></a>用例模型</h3><ul>
<li>用例模型由以下四个部分组成:<ul>
<li>用例图;</li>
<li>用例说明;</li>
<li>系统顺序图SSD</li>
<li>操作契约</li>
</ul>
</li>
<li>以用例为核心从使用者的角度描述和解释待构建系统的功能需求。</li>
</ul>
<h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><ul>
<li>用例图由三个基本元素组成:<ul>
<li>Actor: 称为角色或者参与者，表示使用系统的对象，代表角色的不一定是人，也可以是组织、系统或设备;</li>
<li>Use_case: 称为用例，描述角色如何使用<span style="background:#fff88f">系统功能实现需求目标</span>的一组成功场景和一系列失败场景的集合;</li>
<li>Association: 表示角色与用例之间的关系，以及用例和子用例之间的关系。</li>
</ul>
</li>
</ul>
<h3 id="基本用例与子用例"><a href="#基本用例与子用例" class="headerlink" title="基本用例与子用例"></a>基本用例与子用例</h3><ul>
<li>基本用例: 与角色直接相关的用例，表示系统的功能需求;</li>
<li>子用例: 通过场景描述分析归纳出的用例，也表示了系统的功能，但这些用例与角色无直接关系，而与基本用例存在关联关系;<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.42.54.png" alt="|"><ul>
<li>包含子用例: 多个基本用例中的某个与角色交互的场景具有相同的操作，且这些场景都是基本用例中必须执行的步骤，可以将其抽取出来作为基本用例的子用例;</li>
<li>扩展子用例: 多个基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出来作为基本用例的子用例。</li>
</ul>
</li>
</ul>
<h3 id="系统顺序图"><a href="#系统顺序图" class="headerlink" title="系统顺序图"></a>系统顺序图</h3><ul>
<li>在用例描述的基础上需要进一步确定角色与系统之间的交互信息，并以可编程的方式将其命名;</li>
<li>系统顺序图中“一般”只需要三个UML的符号元素<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.43.44.png" alt="|500"><ul>
<li>角色;</li>
<li>代表软件系统的对象，一般使用system或者系统命名;</li>
<li>角色与system之间的交互信息，简称消息或操作。</li>
</ul>
</li>
</ul>
<h3 id="操作契约"><a href="#操作契约" class="headerlink" title="操作契约"></a>操作契约</h3><ul>
<li>系统操作: 处理系统事件的操作，也称为系统事件;</li>
<li>操作契约: 操作契约是为系统操作而定义的，参考领域模型中业务对象接收到相同的系统事件后，执行必须的业务处理时各业务对象的状态以及系统操作执行的结果，以便软件设计时进行参考。模板如下表所示:<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.44.46.png" alt="|425"></li>
<li>创建操作契约的指导原则如下:<ul>
<li>根据系统顺序图识别进入到系统内的所有系统事件，即操作;</li>
<li>针对每一个系统操作结合对应的用例领域模型，找到与此操作相关的概念类对象;</li>
<li>对那些相对复杂以及用例描述中不清楚的那些系统操作按照以下内容描述并确定对象的状态变化，即后置条件;<ul>
<li><span style="background:#fff88f">对象实例创建和删除</span>。</li>
<li><span style="background:#fff88f">对象属性修改</span>。</li>
<li><span style="background:#fff88f">对象关联形成和断开</span>。</li>
</ul>
</li>
</ul>
</li>
<li>后置条件的陈述应该是声明性的，以强调系统状态所发生的变化，而非强调这种变化是如何设计实现的。</li>
</ul>
<h2 id="第六章-软件设计的概念及原则"><a href="#第六章-软件设计的概念及原则" class="headerlink" title="第六章 软件设计的概念及原则"></a>第六章 软件设计的概念及原则</h2><h3 id="软件概要设计"><a href="#软件概要设计" class="headerlink" title="软件概要设计"></a>软件概要设计</h3><ul>
<li><span style="background:#fff88f">制定设计规范</span></li>
<li><span style="background:#fff88f">软件系统结构的总体设计</span></li>
<li>处理方式设计(性能设计)</li>
<li>数据结构设计</li>
<li>可靠性设计(质量设计)</li>
<li>界面设计(需求的直接表达方式)</li>
<li><span style="background:#fff88f">编写软件概要设计说明书</span></li>
<li>概要设计评审</li>
</ul>
<h3 id="软件详细设计"><a href="#软件详细设计" class="headerlink" title="软件详细设计"></a>软件详细设计</h3><ul>
<li>确定软件各个功能模块内的算法以及各功能模块的内部数据组织。</li>
<li>选定某种表达形式来描述各种算法。</li>
<li>编写软件详细设计说明书</li>
<li>进行详细设计的评审。</li>
</ul>
<h3 id="软件设计模型"><a href="#软件设计模型" class="headerlink" title="软件设计模型"></a>软件设计模型</h3><ul>
<li>软件设计既是过程又是模型。</li>
<li>软件设计模型由两个部分构成:<ul>
<li>动态结构设计: 以某种方式表示功能响应客户请求时处理数据的过程或条件，用于进一步解释软件结构中各功能之间是如何协调工作的机制。</li>
<li>静态结构设计: 由软件的功能结构和数据结构组成，展示软件系统能够满足所有需求的框架结构。</li>
</ul>
</li>
<li>软件的设计活动:<ul>
<li>系统结构设计及数据结构设计;</li>
<li>接口设计和过程设计;</li>
<li>界面设计、组件设计及优化设计等。</li>
</ul>
</li>
</ul>
<h3 id="软件的模块化"><a href="#软件的模块化" class="headerlink" title="软件的模块化"></a>软件的模块化</h3><ul>
<li>模块定义: <ul>
<li>整个软件可被划分成若干个<span style="background:#fff88f">可单独命名且可编址组成部分</span>，这些部分称之为模块。</li>
</ul>
</li>
<li>模块具有如下三个基本属性:<ul>
<li>功能: 实现什么功能，做什么事情。</li>
<li>逻辑: 描述模块内部怎么做。</li>
<li>状态: 该模块使用时的环境和条件。</li>
</ul>
</li>
<li>模块的表示:<ul>
<li>模块的外部特性: 是指模块的模块名、参数表、以及给程序以至整个系统造成的影响。</li>
<li>模块的内部特性: 是指完成其功能的程序代码和仅供该模块内部使用的数据。</li>
</ul>
</li>
</ul>
<h3 id="模块的内聚性"><a href="#模块的内聚性" class="headerlink" title="模块的内聚性"></a>模块的内聚性</h3><ul>
<li>内聚是模块功能强度的度量，一个模块内部各元素之间的联系越紧密，则它的内聚性就越高，相对地，它与其他模块之间的耦合性就会减低，而模块独立性就越强。<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2014.28.11.png" alt="|"></li>
<li>巧合内聚（相同代码就凑一块写个模块）<ul>
<li>内聚程度最低。模块内凑巧有一些程序段代码相同，又没有明确表现出独立的功能，应当抽象为一个新的模块</li>
</ul>
</li>
<li>逻辑内聚（几个功能硬融一个模块，用判断决定执行哪个）<ul>
<li>把几种相关的功能组合在一起，每次调用由模块根据参数确定执行那一部分功能。（if-else）</li>
</ul>
</li>
<li>时间内聚（大家都要在初始化的时候执行，捏一个初始化模块）<ul>
<li>又称经典内聚。一般为多功能模块，各个功能的执行与时间有关。例如初始化模块、终止模块</li>
</ul>
</li>
<li>过程内聚（整个流程分成模块）<ul>
<li>把流程图中的一部分划出组成模块。例如，把一个流程中的循环部分、判定部分、计算部分分成三个模块</li>
</ul>
</li>
<li>通信内聚（多个功能都传同一个参数类型，则捏成一个模块）<ul>
<li>一个模块完成多个功能，各功能都在同一个数据结构上操作，每个功能有唯一入口。例如对某数据结构的 CRUD</li>
</ul>
</li>
<li>功能内聚（就是一个模块）<ul>
<li>内聚程度最高。一个模块中各个部分都是完成某一具体功能必不可少的组成部分，紧密联系，不可分割</li>
</ul>
</li>
</ul>
<h3 id="模块的耦合性"><a href="#模块的耦合性" class="headerlink" title="模块的耦合性"></a>模块的耦合性</h3><ul>
<li>耦合是模块之间互相连接的紧密程度的度量。模块之间的连接越紧密，联系越多，耦合性就越高，而其模块独立性就越弱。<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2014.29.02.png" alt="|"></li>
<li>非直接耦合（没有关系，只是上级控制时可能控制&#x2F;调用）<ul>
<li>耦合性最低。两个模块之间没有直接关系，通过父级模块控制和调用各自实现功能</li>
</ul>
</li>
<li>数据耦合（一个模块就传一些数据、信息给另一个模块）<ul>
<li>一组模块通过参数表简单变量交换信息。</li>
</ul>
</li>
<li>标记耦合（共享一个模块但使用不通的数据结构）<ul>
<li>一组模块通过参数表传递记录信息。这个记录是某一数据结构的子结构，不是简单变量。（违反了通信内聚原则）</li>
</ul>
</li>
<li>控制耦合（一个模块传一些标识位来控制另一个模块）<ul>
<li>一个模块通过传送开关、标志、名字等控制信息明显地控制另一模块的功能。</li>
</ul>
</li>
<li>外部耦合（共用一个数据格式作为参数）<ul>
<li>一组模块都访问同一全局简单变量（而非数据结构），并且不通过参数表传递该变量信息。</li>
</ul>
</li>
<li>公共耦合（临界区）<ul>
<li>一组模块访问同一个公共数据环境。如全局数据结构、共享通信区、内存公共覆盖区等。</li>
</ul>
</li>
<li>内容耦合（两个模块纠缠不清）<ul>
<li>耦合性最高。一个模块直接访问另一模块内部数据、不通过正常入口转到另一模块内部、两模块有部分代码重叠、一个模块有多个入口。（垃圾代码）</li>
</ul>
</li>
</ul>
<h3 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3><ul>
<li><span style="background:#fff88f">单一职责</span>SRP：<ul>
<li>引起一个类<strong>变化的原因</strong>（职责）应该只有一个<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2016.16.22.png" alt="|500"></li>
</ul>
</li>
<li><span style="background:#fff88f">开闭原则</span>OCP：<ul>
<li>类、模块、函数可以扩展，但不能修改原有代码<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2016.17.16.png" alt="|450"><ul>
<li>如果是改原来的代码来添加一个功能就是差设计</li>
<li>原来的代码不用改，多继承一个子类就能实现功能的增加就是满足OCP的好设计</li>
</ul>
</li>
</ul>
</li>
<li><span style="background:#fff88f">里氏替换原则</span>：<ul>
<li>子类应当可以替换父类，并出现在父类能够出现的任何地方<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2016.18.37.png" alt="|475"></li>
</ul>
</li>
<li><span style="background:#fff88f">依赖倒置原则</span>：<ul>
<li>高层模块不应依赖于底层模块，二者都应依赖于抽象。抽象不应依赖于细节，细节应该依赖于抽象。</li>
<li>程序中所有依赖关系都应终止于抽象类或接口![[截屏2024-06-21 16.18.56.png|450]]</li>
</ul>
</li>
<li>接口隔离原则：<ul>
<li>若一个服务类为多个客户类提供不同服务，则服务类针对每个不同服务都应该有一个接口<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2016.19.19.png" alt="|425"></li>
</ul>
</li>
<li>组合&#x2F;聚合复用：<ul>
<li>在一个新对象里面使用一些已有对象，使之成为新对象的一部分。新对象通过向已有对象委托（delegate）一部分职责而达到复用已有对象的目的。（不要继承，要组合&#x2F;聚合）</li>
</ul>
</li>
<li>迪米特法则：<ul>
<li>最少知识原则。一个对象应当尽可能少地了解其他对象。（对象只与 this、本对象方法中的参量、当前对象实例直接引用的对象、对象实例聚集中的其他元素、当前对象创建的对象通信）</li>
</ul>
</li>
</ul>
<h2 id="第七章-面向对象设计方法"><a href="#第七章-面向对象设计方法" class="headerlink" title="第七章 面向对象设计方法"></a>第七章 面向对象设计方法</h2><h3 id="面向对象的设计与UML"><a href="#面向对象的设计与UML" class="headerlink" title="面向对象的设计与UML"></a>面向对象的设计与UML</h3><ul>
<li>面向对象的设计：以需求分析阶段的<span style="background:#fff88f">用例模型</span>和<span style="background:#fff88f">领域模型</span>为基础，运用 UML 构建软件系统结构，通过一系列设计模型说明用例的实现过</li>
<li>软件概要设计步骤<ul>
<li>选择合适的软件架构</li>
<li>系统的<span style="background:#fff88f">动态结构设计</span>:<ul>
<li>用例实现过程设计，针对用例对应的SSD中的每个系统事件，运用UML的顺序图或协作图给出符合该系统事件定义的操作契约的内容</li>
<li>如果软件对象具有多种不同的职责(主要考虑对应于不同的用例)的情况下，需要运用状态图对该软件对象进行状态迁移的设计</li>
</ul>
</li>
<li>系统的<span style="background:#fff88f">静态结构设计</span><ul>
<li>对所有用例或者子系统级别的用例的交互图进行归纳，运用UML的类图给出系统的静态结构</li>
</ul>
</li>
</ul>
</li>
<li>软件详细设计<ul>
<li>针对系统静态结构中每个对象的方法，运用UML活动图对其进行逻辑结构的设计</li>
</ul>
</li>
</ul>
<h3 id="面向对象设计的关键步骤"><a href="#面向对象设计的关键步骤" class="headerlink" title="面向对象设计的关键步骤"></a>面向对象设计的关键步骤</h3><ul>
<li>在确定软件框架结构的基础上，进行以下内容的设计:<ul>
<li><span style="background:#fff88f">发现对象(发现软件类)</span>: 根据需求和选择的架构和模式确定系统由哪些对象构成</li>
<li>确定对象属性: 明确该对象应该具有的特征属性</li>
<li><span style="background:#fff88f">确定对象行为</span>: 明确对象应具有的功能和职责</li>
<li><span style="background:#fff88f">确定对象之间的关系</span>: 根据系统顺序图及操作契约以及选择的架构和模式明确系统是如何相互协作完成功能需求的交互过程</li>
</ul>
</li>
</ul>
<h3 id="基于BS结构-模型的层次化"><a href="#基于BS结构-模型的层次化" class="headerlink" title="(基于BS结构)模型的层次化"></a>(基于BS结构)模型的层次化</h3><ul>
<li>层次化的设计模型是面向对象方法基于软件体系结构风格的一种方案选择。层次化的设计模型符合面向对象的设计原则，并使系统易于扩展和维护。<ul>
<li>用户界面层:(用例)系统功能的各种界面表现形式。</li>
<li>控制器层:用于协调、控制其他类共同完成用例规定的功能或行为。</li>
<li>业务&#x2F;应用层:实现用例要求的各种系统级功能;</li>
<li>持久化层:用于保存需要持久化存储的数据对象;</li>
<li>系统层:为应用提供操作系统相关的功能，通过把特定于操作系统的特性包装起来，使软件与操作系统分离，增加应用的可移植性。<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2014.33.19.png" alt="|400"></li>
</ul>
</li>
</ul>
<h3 id="面向对象的设计模式"><a href="#面向对象的设计模式" class="headerlink" title="面向对象的设计模式"></a>面向对象的设计模式</h3><ul>
<li><span style="background:#fff88f">对象的职责通过调用对象的方法来实现</span>。将职责分配给一个对象还是多个对象，是分配给一个方法还是多个方法要受到职责粒度的影响。</li>
<li><span style="background:#fff88f">面向对象设计最关键的活动是正确地给对象分配职责</span>。</li>
<li>模式是面向对象软件的设计经验，是可重用的设计思想，它描述了在特定环境中反复出现的一类设计问题，并提供经过实践检验的解决这类问题的通用模式。</li>
<li><span style="background:#fff88f">模式定义了一组相互协作的类</span>，<span style="background:#fff88f">包括类的职责和类之间的交互方式</span>。</li>
</ul>
<h3 id="类职责分配-Grasp-模式"><a href="#类职责分配-Grasp-模式" class="headerlink" title="类职责分配(Grasp)模式"></a>类职责分配(Grasp)模式</h3><ul>
<li>设计类的来源有两部分。<ul>
<li>核心逻辑由领域模型中的<span style="background:#fff88f">概念类</span>转换而来</li>
<li>另一部分则是为实现而新增的一些类，如负责对象持久化的类、负责通信的类。</li>
</ul>
</li>
<li>每一个设计类都有明确的职责，分为两种类型:<ul>
<li>了解型(knowing)职责(自己干自己的事)细分为三类:<ul>
<li>对象要了解自己私有的封装数据;</li>
<li>了解相关联的对象;</li>
<li>了解能够派生或者计算的事物。</li>
</ul>
</li>
<li>行为型(doing)职责(自己干自己能干的事)。细分为三类:<ul>
<li>对象自身要能执行一些行为，如创建一个对象或者进行计算;</li>
<li>对象要能启动其他对象中的动作;</li>
<li>对象要能控制或协调其他对象中的活动。</li>
</ul>
</li>
</ul>
</li>
<li>职责的内聚(自己只干自己的事): 目的是提高内聚降低耦合，减少不必要的关联关系。</li>
</ul>
<h3 id="控制器-Controller-模式"><a href="#控制器-Controller-模式" class="headerlink" title="控制器(Controller)模式"></a>控制器(Controller)模式</h3><ul>
<li>问题来源: 第一个接收系统事件的软件对象是什么? 哪个软件对象负责接收和处理一个系统输入事件?</li>
<li>解决方案: 把接收和处理系统事件的职责分配给位于控制器层的对象<ul>
<li>它代表整个系统(系统简单且不复杂)，称为外观(facade)控制器;</li>
<li>它代表一个发生系统事件的用例场景，这个类通常命名为“&#x3D;&#x3D;&lt;用例名&gt;&#x3D;&#x3D;控制器”，称为用例控制器或者会话控制器。</li>
<li>在相同的用例场景中使用同一个控制器类处理所有的系统事件;</li>
<li>一次会话是与一个参与者进行交谈的一个实例。</li>
</ul>
</li>
</ul>
<h3 id="创建者-Creator-模式"><a href="#创建者-Creator-模式" class="headerlink" title="创建者(Creator)模式"></a>创建者(Creator)模式</h3><ul>
<li>问题来源: 哪个对象应该负责产生类的实例?(<span style="background:#fff88f">操作契约中对象实例的创建</span>)</li>
<li>如果符合下面的一个或者多个条件，则可将创建类A实例的职责分配给类B(B创建 A):<ul>
<li>B聚合(aggregate)或包含(contain)对象A;</li>
<li>B记录(record)对象A;</li>
<li>B密切使用对象A;</li>
<li>B拥有创建对象A所需要的初始化数据(B是创建对象A的信息专家)。</li>
</ul>
</li>
<li>创建者模式体现了低耦合的设计思想，是&#x3D;&#x3D;对迪米特法则的具体运用&#x3D;&#x3D;。<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2014.43.00.png" alt="|383"></li>
</ul>
<h3 id="信息专家模式"><a href="#信息专家模式" class="headerlink" title="信息专家模式"></a>信息专家模式</h3><ul>
<li><span style="background:#fff88f">给对象分配职责的通用原则</span>: 将职责分配给拥有履行职责所必需信息的类，即信息专家。换言之，对象具有处理自己拥有信息的职责或能力。</li>
<li>根据信息专家模式，应该找到拥有履行职责所必须的信息的类，选取类的方法:<ul>
<li>如果在设计模型中存在相关的类，先到设计模型中查看;</li>
<li>如果在设计模型中不存在相关的类，则到领域模型中查看，试着应用或扩展领域模型，得出相应的设计类。</li>
</ul>
</li>
<li>职责的实现(即功能)需要信息，而信息往往分布在不同的对象中，一个任务可能需要多个对象(信息专家)协作来完成。</li>
</ul>
<h3 id="创建设计类图"><a href="#创建设计类图" class="headerlink" title="创建设计类图"></a>创建设计类图</h3><ul>
<li>通过类职责分配，找出了实现用例的类，以及类的职责。结合分析阶段的领域模型，可以得到设计阶段的类图，简称设计类图。</li>
<li>设计类图中主要定义<span style="background:#fff88f">类、类的属性和操作</span>，但是不定义实现操作的算法。<ol>
<li>通过扫描所有的交互图以及领域模型中涉及的类，识别软件类。</li>
<li>将领域模型中已经识别出来的部分属性添加到类中。</li>
<li>根据交互图为软件类添加方法。忽略软件类的构造函数和get&#x2F;set方法。</li>
<li>添加更多的类型信息。包括属性类型、方法参数类型以及返回类型。</li>
<li>添加关联和导航。定义A到B带导航修饰关联的常见情况有以下几种:<ul>
<li>A发送一个消息到B;</li>
<li>A创建一个B的实例;</li>
<li>A需要维护到B的一个连接。</li>
</ul>
</li>
<li>类成员的细节表示(可选)。如成员的属性可见性，方法体的描述等。</li>
</ol>
</li>
</ul>
<h2 id="第九章-程序实现"><a href="#第九章-程序实现" class="headerlink" title="第九章 程序实现"></a>第九章 程序实现</h2><h3 id="源程序文档化"><a href="#源程序文档化" class="headerlink" title="源程序文档化"></a>源程序文档化</h3><ul>
<li>从软件工程的角度，对于源程序除了质量要求之外，为了后期代码的维护和更改，还必须从提高可阅读性，即达到源程序文档化。</li>
<li>标识符命名: 模块名(类名及方法名)，变量&#x2F;常量名<ul>
<li>名称需清楚表示具体的含义，采用添加前缀和后缀增加可阅读性;</li>
<li>使用专业术语(业务词汇)，注意编码语言的关键字冲突;</li>
<li>注意大小写及长度;</li>
</ul>
</li>
<li>源程序布局<ul>
<li>编码之前定义统一的编码规范;</li>
<li>规定合理的注释、缩进、空格、空行等方式;</li>
</ul>
</li>
<li>程序注释<ul>
<li>序言性注释</li>
<li>功能性注释</li>
</ul>
</li>
</ul>
<h3 id="序言性注释"><a href="#序言性注释" class="headerlink" title="序言性注释"></a>序言性注释</h3><ul>
<li>注释的目的: 解释程序的主要内容及难点说明;</li>
<li>序言性注释: 位于程序代码之前，说明该模块(类及方法)具体作用</li>
<li>主要包括以下内容:<ul>
<li>程序标题: 模块名称</li>
<li>模块描述: 该模块的功能和目的说明</li>
<li>主要算法: (可选) 说明算法结构</li>
<li>接口说明: 说明该模块与其他模块的调用关系</li>
<li>开发简历:<ul>
<li>创建者、创建时间;</li>
<li>修改者、修改时间、修改内容;</li>
<li>版本</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="功能性注释"><a href="#功能性注释" class="headerlink" title="功能性注释"></a>功能性注释</h3><ul>
<li>在序言性注释的基础上，对于程序体中复杂难于理解的程序结构进行局部说明;<ul>
<li>主要描述一段程序，必要时对某一段进行说明;</li>
<li>修改代码的同时，对应的功能性注释也要进行修改;</li>
</ul>
</li>
</ul>
<h2 id="第十章-软件测试"><a href="#第十章-软件测试" class="headerlink" title="第十章 软件测试"></a>第十章 软件测试</h2><h3 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h3><p><img src="/../prtsc/Pasted%20image%2020240621144906.png"></p>
<ul>
<li>软件配置:<ul>
<li>软件需求规格说明、软件设计规格说明、源代码等;</li>
</ul>
</li>
<li>测试配置:<ul>
<li>测试计划、测试用例、测试程序等;</li>
</ul>
</li>
<li>测试工具:<ul>
<li>测试数据自动生成程序、静态分析程序、动态分析程序、测试结果分析程序、以及驱动测试的测试数据库等等。</li>
</ul>
</li>
<li>测试结果分析: <ul>
<li>比较实测结果与预期结果，评价错误是否发生以及错误的级别和严重性。</li>
</ul>
</li>
<li>排错(调试): <ul>
<li>对已经发现的错误进行错误定位和确定出错性质，并改正错误，同时修改相关的文档。</li>
</ul>
</li>
<li>修正后的文档再测试: <ul>
<li>直到通过测试为止。</li>
</ul>
</li>
<li>利用可靠性分析，评价软件质量:<ul>
<li>软件的质量和可靠性达到可接受的程度</li>
<li>是否所做的测试不足以发现严重的错误</li>
</ul>
</li>
<li>如果测试发现不了错误，只能说明测试配置考虑得不够细致充分，错误仍然潜伏在软件中</li>
</ul>
<h3 id="两种常用的测试方法"><a href="#两种常用的测试方法" class="headerlink" title="两种常用的测试方法"></a>两种常用的测试方法</h3><ul>
<li>&#x3D;&#x3D;测试用例由测试输入数据和预期的输出结果两部分组成&#x3D;&#x3D;<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2016.24.51.png" alt="|"></li>
<li>白盒测试: 将测试对象看做一个透明的盒子，允许利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致，又称为结构测试或逻辑驱动测试。</li>
<li>黑盒测试: 这种方法完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书和概要设计说明，检查程序的功能是否符合它的功能说明，又称为功能测试或数据驱动测试</li>
</ul>
<h3 id="白盒测试方法"><a href="#白盒测试方法" class="headerlink" title="白盒测试方法"></a>白盒测试方法</h3><ul>
<li>白盒测试主要应用于单元测试，是检查程序逻辑错误的主要方法。</li>
<li>使用白盒测试方法，主要对程序模块进行如下的检查:<ul>
<li>程序模块的所有独立的执行路径至少测试一次;</li>
<li>对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次;</li>
<li>在循环的边界和运行界限内执行循环体;</li>
<li>测试内部数据结构的有效性，等。</li>
</ul>
</li>
<li>逻辑覆盖: 逻辑覆盖是以程序内部的逻辑结构为基础设计的测试用例技术<ul>
<li>语句覆盖<ul>
<li>（每个判断语句都走一趟就行）</li>
<li>使得每一个可执行语句至少执行一次。语句覆盖发现不了判断中逻辑运算中出现的错误，是最弱的逻辑覆盖准则</li>
</ul>
</li>
<li>判定覆盖<ul>
<li>（每个判断语句的真假都走一趟就行）</li>
<li>使得程序中每个判断的取真分支和取假分支至少经历一次，又称为分支覆盖。判定覆盖还不能保证一定查出在判断的条件中存在的错误，因此需要更强的逻辑覆盖准则检验判断内部条件</li>
</ul>
</li>
<li>条件覆盖<ul>
<li>（每个判断语句中的小条件的真假都要走一趟）</li>
<li>使得程序中每个判断的每个条件的可能取值至少执行一次</li>
</ul>
</li>
<li>判定+条件覆盖<ul>
<li>（每个判断语句中的小条件的真假都要走且要覆盖每个判断路径）</li>
<li>使得判断中每个条件的所有可能取值至少执行一次，同时每个判断的所有可能判断结果取值至少执行一次。采用判定-条件覆盖，逻辑表达式中的错误不一定能够查得出来</li>
</ul>
</li>
<li>条件组合覆盖<ul>
<li>（每个判断语句中的所有小条件组合都要走一趟）</li>
<li>使得每个判断的所有可能的条件取值组合至少执行一次。需要将多重条件判断分解成有多个基本判断组成的流程图</li>
</ul>
</li>
<li>路径覆盖<ul>
<li>（每一条头到尾的可能的路径都走一遍）</li>
<li>设计足够的测试用例，覆盖程序中所有可能的路径。&#x3D;&#x3D;这种测试仍然无法满足条件组合覆盖某些条件，也并非是完善的测试方法。在实际的测试用例设计过程中需要综合以上 6 种测试方法去设计测试用例。以路径覆盖为主，辅助其他 5 种方法&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基本路径测试"><a href="#基本路径测试" class="headerlink" title="基本路径测试"></a>基本路径测试</h3><ul>
<li>对于具有循环结构的程序而言，其路径数有可能很多，要求做到路径覆盖有难度。基本路径测试方法力图把覆盖的路径数压缩到一定限度内，得程序中的循环体最多只执行一次。</li>
<li>这个方法需引入&#x3D;&#x3D;程序控制流图&#x3D;&#x3D;:基于程序流程图进行简化，得到程序的控制结构。</li>
<li>进而分析控制结构的环路复杂性，导出基本可执行路径集合，设计测试用例的方法。设计出的测试用例要保证在测试中，程序的每一个可执行语句至少要执行一次。<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2015.18.51.png" alt="|525"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2015.19.00.png" alt="|157"></li>
</ul>
<h3 id="控制流图的转换"><a href="#控制流图的转换" class="headerlink" title="控制流图的转换"></a>控制流图的转换</h3><ul>
<li>顺序结构的多个结点可以合并为一个结点。</li>
<li>在选择或多分支结构中，分支的汇聚处应有一个虚拟汇聚结点。</li>
<li>边和结点圈定的范围叫做区域，当对区域计数时，图形外的范围也应记为一个区域。</li>
<li>如果判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, NAND, NOR) 连接的复合条件表达式，则需要改为一系列只有单个条件的嵌套的判断。<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2015.24.45.png" alt="|450"></li>
</ul>
<h3 id="控制流图的环路复杂度计算"><a href="#控制流图的环路复杂度计算" class="headerlink" title="控制流图的环路复杂度计算"></a>控制流图的环路复杂度计算</h3><ul>
<li>控制流图的环路复杂度(也称为McCabe复杂度)确定了程序中独立路径的上界，以此为依据可以找出程序中的全部独立路径。</li>
<li>环路复杂度有三种计算方法:<ul>
<li>等于控制流图中的区域数，包括封闭区域和开放区域;</li>
<li>设E为控制流图的边数，N为图的结点数，则定义环路复杂性为 V(G)&#x3D;E-N+2;</li>
<li>若设P为控制流图中的判定结点数，则有 V(G)&#x3D;P+1。</li>
</ul>
</li>
<li>基本路径集: 指程序的控制流图中，从入口到出口的路径，该路径至少经历一个从未走过的边。<ul>
<li>基本路径集不是唯一的，对于给定的控制流图，可以得到不同的基本路径集。</li>
<li>最大的基本路径条数就是环路复杂度。</li>
</ul>
</li>
</ul>
<h3 id="导出测试用例"><a href="#导出测试用例" class="headerlink" title="导出测试用例"></a>导出测试用例</h3><ul>
<li>根据控制流图的基本路径导出测试用例，确保基本路径集中每一条路径的执行。</li>
<li>根据判断结点给出的条件，选择适当的数据以保证每一条路径可以被测试到，考虑使用逻辑覆盖方法。</li>
<li>每个测试用例执行之后，与预期结果进行比较。</li>
<li>如果所有测试用例都执行完毕，则可以确信程序中所有的可执行语句至少被执行了一次。<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2015.26.23.png" alt="|500"><br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2015.26.44.png" alt="|500"></li>
</ul>
<h3 id="黑盒测试方法"><a href="#黑盒测试方法" class="headerlink" title="黑盒测试方法"></a>黑盒测试方法</h3><ul>
<li>相对于白盒测试，黑盒测试是在不需要了解程序结构的基础上，根据概要设计或者需求分析的结果进行测试用例的设计。常用的方法有:<ul>
<li>等价类划分;</li>
<li>边界值分析;</li>
<li>因果图;</li>
</ul>
</li>
<li>黑盒测试方法一般用于集成测试、系统测试和验收测试，某些特殊情况也会用到单元测试。</li>
<li>黑盒测试方法用于测试程序接口，主要是为了发现以下错误:<ul>
<li>是否有不正确或遗漏了的功能?</li>
<li>在接口上，输入能否正确地接受? 能否输出正确的结果?</li>
<li>是否有数据结构错误或外部信息(例如数据文件)访问错误?</li>
<li>性能上是否能够满足要求?</li>
<li>是否有初始化或终止性错误?</li>
</ul>
</li>
</ul>
<h3 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h3><ul>
<li>黑盒测试方法不能选用穷举方式，为此通过寻找具有代表意义的数据进行替代其它同类型的数据，称为等价类。</li>
<li>并合理地假定: 测试某等价类的代表值就等价于对这一类其它值的测试。</li>
<li>使用这一方法设计测试用例要经历划分等价类(列出等价类表)和选取测试用例。<ul>
<li>划分等价类: 根据输入域的要求和数据类型定义寻找等价类，确定等价类表结构。</li>
<li>等价类的划分有两种不同的情况:<ul>
<li>有效等价类: 是指对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合。</li>
<li>无效等价类: 是指对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="划分等价类原则"><a href="#划分等价类原则" class="headerlink" title="划分等价类原则"></a>划分等价类原则</h3><ul>
<li>按区间划分: 如果某个字段的输入条件属于一个取值范围[x,y]，则可以确立<ul>
<li>一个有效等价类;</li>
<li>两个无效等价类。</li>
</ul>
</li>
<li>按数值集合划分: 如果输入条件规定了输入数据的集合，则可划分<ul>
<li>一个有效等价类: 所有符合输入条件的数据集合，</li>
<li>一个无效等价类: 所有不允许输入的数据集合。</li>
</ul>
</li>
<li>如果输入条件是一个布尔量，则可以确定<ul>
<li>一个有效等价类，即取真;</li>
<li>一个无效等价类，即取假。</li>
</ul>
</li>
<li>按数值划分: 如果规定了输入数据的一组值，而且程序要对每个输入值分别进行处理，这时可以为<ul>
<li>每一个输入值确立一个有效等价类;</li>
<li>一个无效等价类，包含所有不允许输入的数值。</li>
</ul>
</li>
<li>按限制条件或规则划分: 如果规定了输入数据必须遵守的规则或限制条件，则可以确立<ul>
<li>一个有效等价类，即各方面均符合规则要求;</li>
<li>若干个无效等价类，每个无效等价类从不同角度违反输入规则。</li>
</ul>
</li>
</ul>
<h3 id="确定测试用例"><a href="#确定测试用例" class="headerlink" title="确定测试用例"></a>确定测试用例</h3><ul>
<li>为每一个等价类规定一个唯一编号;</li>
<li>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止;</li>
<li>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。</li>
</ul>
<h3 id="等价类划分举例"><a href="#等价类划分举例" class="headerlink" title="等价类划分举例"></a>等价类划分举例</h3><p>要求:</p>
<ol>
<li>工作证号必须是整数，范围区间为 1～5000，不能为为空;</li>
<li>姓名必须是中文字符，不超过20个中文字符，不能为为空;</li>
<li>密码必须大于等于6位，必须包括数字和字母;</li>
<li>参加工作时间必须是8位数字，格式为YYYYMMDD，如20130525。<br><img src="/../prtsc/Pasted%20image%2020240621153718.png"><br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2015.39.01.png" alt="|500"></li>
</ol>
<h3 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h3><ul>
<li>边界值分析方法是对等价类划分方法的补充。</li>
<li>从长期的测试工作经验得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。</li>
<li>这里所说的边界是指，相当于输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特定情况。</li>
<li>使用边界值分析方法设计测试用例，首先应确定边界情况。应当选取正好等于，刚刚大于，或刚刚小于边界的值做为测试数据，而不是选取等价类中的典型值或任意值做为测试数据。</li>
<li>比如，在做三角形计算时，要输入三角形的三个边长:A、B和C。我们应注意到这三个数值应当满足:<ul>
<li>A &gt; 0、B &gt; 0、C &gt; 0、A + B &gt; C、A + C &gt; B、B + C &gt; A，才能构成三角形。</li>
<li>在程序中如果把不等式中的任何一个 “&gt;” 错写成 “≥”，那就不能构成三角形。</li>
</ul>
</li>
</ul>
<h3 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h3><ul>
<li>在测试时必须考虑输入条件的各种组合，以及相应动作的形式来设计测试用例，这就需要利用因果图。因果图方法需要使用判定表。<ul>
<li>分析(需求)软件规格说明描述中，哪些是原因(输入或状态)，哪些是结果(输出或动作)，并给每个原因和结果赋予一个唯一的标识符。</li>
<li>分析(需求)软件规格说明中的语义，找出原因与原因之间，原因与结果之间的关系，根据这些关系，画出因果图。</li>
<li>由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号标明约束或限制条件。</li>
<li>把因果图转换成判定表，并根据因果图中的制约关系对判定表进行化简，去掉不可能存在的组合情况。</li>
<li>简化后的判定表中的每一列就是一种有效的条件组合，对应一个测试用例。</li>
</ul>
</li>
</ul>
<h3 id="因果图中的符号"><a href="#因果图中的符号" class="headerlink" title="因果图中的符号"></a>因果图中的符号</h3><ul>
<li>通常在因果图中用Ci表示原因，用Ei表示结果，各结点表示状态。<ul>
<li>“0”表示某状态不出现，</li>
<li>“1”表示某状态出现。</li>
</ul>
</li>
<li>主要的原因和结果之间的关系有:</li>
<li>表示约束条件的符号 为了表示原因与原因之间，结果与结果之间可能存在的约束条件，在因果图中可以 附加一些表示约束条件的符号。<img src="/../prtsc/Pasted%20image%2020240621154100.png"><img src="/../prtsc/Pasted%20image%2020240621154119.png"></li>
</ul>
<h3 id="五个软件测试的基本类型"><a href="#五个软件测试的基本类型" class="headerlink" title="五个软件测试的基本类型"></a>五个软件测试的基本类型</h3><ul>
<li>单元测试: 编码阶段使用白盒测试方法，对已实现的最小代码单位进行正确性检查。</li>
<li>集成测试: 编码阶段在单元测试基础上，使用黑盒测试方法检查被测单元的接口问题，并验证代码集成后各功能的完整性。</li>
<li>确认测试: 开发后期，验证系统级软件功能和性能是否符合用户需求。</li>
<li>系统测试: 在开发或实际运行环境中，根据系统需求分析规格说明书进行一系列集成和确认测试。</li>
<li>验收测试: 在实际运行环境中，系统试运行一段时间后进行的测试活动，确认系统功能和性能符合生产要求，验收通过后交付给用户使用。</li>
</ul>
<h2 id="第十一章-软件维护"><a href="#第十一章-软件维护" class="headerlink" title="第十一章 软件维护"></a>第十一章 软件维护</h2><h3 id="维护的分类"><a href="#维护的分类" class="headerlink" title="维护的分类"></a>维护的分类</h3><ul>
<li>改正性维护：为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用而进行的诊断和改正错误的过程</li>
<li>适应性维护：为了使软件适应外部环境或数据环境的变化，而去修改软件的过程</li>
<li>完善性维护：为了满足用户对软件提出新的功能与性能要求而去修改和再开发软件的过程</li>
<li>预防性维护：采用先进的软件工程方法对需要维护的软件或软件中的某一部分(重新)进行设计、编制和测试</li>
</ul>
<h2 id="附录-大题专精指南"><a href="#附录-大题专精指南" class="headerlink" title="附录 大题专精指南"></a>附录 大题专精指南</h2><h3 id="题型1-交互图"><a href="#题型1-交互图" class="headerlink" title="题型1:交互图"></a>题型1:交互图</h3><ul>
<li><em>2019</em></li>
</ul>
<h4 id="样例题"><a href="#样例题" class="headerlink" title="样例题"></a>样例题</h4><p><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.42.05.png" alt="|475"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>交互图原本一般都是在综合题的最后一问出现，不过这次期末由于取消了结构化，因此应用题少了一道，就把交互图拿来单独考了</li>
<li>交互图是面向对象设计方法的内容，也叫sequence diagram顺序图</li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>确定已知条件<ul>
<li>确定使用系统的角色【病人】</li>
<li>确定用例【病人使用查询机获得排队信息】</li>
<li>确定领域模型【上一问提供】<ul>
<li>没有可以yy</li>
</ul>
</li>
<li>确定操作契约【题目给了】<ul>
<li>一般会给，没有只能yy了</li>
</ul>
</li>
<li>确定控制器对象【查询机】<ul>
<li>没有需要自己定（外观&#x2F;用例）</li>
</ul>
</li>
</ul>
</li>
<li>实现中的各种情况<ul>
<li>首先需要明确的问题——找到每一个动作的“负责人”<ul>
<li>谁负责创建xx实例？</li>
<li>谁负责计算xx？</li>
<li>谁负责查询xx？<br>  （这里的负责需要结合领域模型，有关联关系才能负责）</li>
</ul>
</li>
<li>角色发送请求<ul>
<li>首先控制器对象为查询机，因此角色病人发送的消息会给查询机负责接受<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2018.54.08.png" alt="|178"></li>
</ul>
</li>
<li>创建实例<ul>
<li>需要根据领域模型+创建者模式来判断</li>
<li>一般来说对于一个实例B，如果A和B是聚合&#x2F;组合关系，A就需要负责创建B，如果需要初始化还要传响应参数进去</li>
<li>如果遇到创建数组并添加元素的时候如下<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2019.01.50.png" alt="|275"></li>
</ul>
</li>
<li>调用方法<ul>
<li>找到调用对象和被调用对象，除非是初始化创建或者特殊情况，都是一来一回，去实线箭头回虚线箭头<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.02.43.png" alt="|281"></li>
<li>如果调用的是自己的方法（比如查询自己存的map）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.03.53.png" alt="|225"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>最根本的是基于操作契约</li>
<li>在一个用例中对于操作契约的每一个方法都进行深度分析</li>
<li>通过创建者模式确定负责创建的对象</li>
<li>通过信息专家模式找到该具有负责操作契约中某个功能的职责的对象</li>
<li>按照标准格式进行绘制</li>
</ul>
<h3 id="题型2-白盒测试"><a href="#题型2-白盒测试" class="headerlink" title="题型2:白盒测试"></a>题型2:白盒测试</h3><p><em>2019+2012</em></p>
<h4 id="样例题-1"><a href="#样例题-1" class="headerlink" title="样例题"></a>样例题</h4><p><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.21.19.png" alt="|"></p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li>白盒测试的题型在几年的考题中都相对固定，第一问程序流程图（可能修改可能直接画）、第二问程序控制流图+环路复杂性、第三问独立路径集</li>
</ul>
<h4 id="步骤一：程序流程图"><a href="#步骤一：程序流程图" class="headerlink" title="步骤一：程序流程图"></a>步骤一：程序流程图</h4><ul>
<li>确定图例<ul>
<li>开始：黑圆点</li>
<li>事件：矩形</li>
<li>判断：菱形、Y、N</li>
<li>结束：黑圆点加一圈</li>
</ul>
</li>
<li>示例（如果给的是代码、事件&#x2F;判断中写的是代码）<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.20.26.png" alt="|475"></li>
<li>“将复合条件的判定变为一系列单个条件嵌套的判定”<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.29.05.png" alt="|"></li>
<li>while的常见结构<br><img src="/../prtsc/IMG_620CA6048D11-1.jpeg" alt="|425"></li>
</ul>
<h4 id="步骤二：程序流图-环路复杂性"><a href="#步骤二：程序流图-环路复杂性" class="headerlink" title="步骤二：程序流图+环路复杂性"></a>步骤二：程序流图+环路复杂性</h4><ul>
<li>通过程序流程图导出程序控制流图<ol>
<li>所有程序流程图的元素都变为圆圈（结点）</li>
<li>所有顺序结构的结点合并为一个结点（连续两个以上的单进单出的结点可以合并成一个）</li>
<li>分支结束是需要添加虚拟汇聚结点，多个汇聚结点可合并</li>
<li>判定条件必须为单一条件，如果为复合需要分布拆开（上一步骤没要求做的话）</li>
</ol>
</li>
<li>示例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.43.33.png" alt="|375"><br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.43.49.png" alt="|275"></li>
<li>计算环路复杂度V(G)<ul>
<li>三种方法<ul>
<li>方法一：数包围区域（最外面开放区域也算一个）</li>
<li>方法二：E为边数N为结点数则V(G)&#x3D;E-N+2<ul>
<li>欧拉公式，面数&#x3D;包围区域数</li>
</ul>
</li>
<li>方法三：判断节点数+1</li>
</ul>
</li>
<li>最好用两种方法算完对一下，第一种+第三种快一些</li>
</ul>
</li>
</ul>
<h4 id="步骤三：独立路径集"><a href="#步骤三：独立路径集" class="headerlink" title="步骤三：独立路径集"></a>步骤三：独立路径集</h4><ul>
<li>独立路径指的是控制流图从入口到出口的路径，该路径至少经历一个从未经历的边</li>
<li>看着数就完了，独立路径集里的路径个数一定等于环路复杂度</li>
<li>示例<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.43.49.png" alt="|425"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.53.39.png" alt="|"></li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>程序流程图答案不唯一，但是判断结点的个数一定要对，决定了后面每一道题</li>
<li>环路复杂度一定要给出计算的原理&#x2F;公式</li>
</ul>
<h3 id="题型3-黑盒测试"><a href="#题型3-黑盒测试" class="headerlink" title="题型3:黑盒测试"></a>题型3:黑盒测试</h3><ul>
<li><em>2012</em></li>
</ul>
<h4 id="样例题-2"><a href="#样例题-2" class="headerlink" title="样例题"></a>样例题</h4><p><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.44.47.png" alt="|"></p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ul>
<li>黑盒测试的题型也比较统一，就是等价类的划分</li>
</ul>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>分析题目给的要求<ul>
<li>数字区间类要求（内容码不小于100且小于99）<ul>
<li>有效等价类：区间内</li>
<li>无效等价类：区间左侧、区间右侧</li>
</ul>
</li>
<li>数值集合类要求（输入的月份允许为1～12的整数）<ul>
<li>有效等价类：满足条件的数值集合</li>
<li>无效等价类：不满足条件的数值集合</li>
</ul>
</li>
<li>布尔条件类要求（标识码是11952799）<ul>
<li>有效等价类：布尔为真（符合要求）</li>
<li>无效等价类：布尔为假（不符合要求）</li>
</ul>
</li>
<li>多规则类要求（以11为前缀并以99为后缀的8为数字）<ul>
<li>有效等价类：满足所有规则</li>
<li>无效等价类：如示例由3个规则组成，则一共有2³&#x3D;8种可能情况，有效等价类占1种则其余7种均为无效等价类</li>
</ul>
</li>
</ul>
</li>
<li>开画表格<ul>
<li>第一列列出每一个题目的条件，第二列有效等价类，第三列无效等价类</li>
<li>每一个要求按照上面的方法进行拆分，罗列出来</li>
<li>针对每一个等价类标上序号</li>
</ul>
</li>
<li>示例<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2021.31.41.png" alt="|550"><br>（质疑一下最后一个无效等价类，我认为不止4种应该是7种）</li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li>区间要求的无效等价类要分为两段</li>
<li>多规则要求的分析要有耐心</li>
<li>一定别忘了标号</li>
</ul>
<h3 id="题型4-综合题"><a href="#题型4-综合题" class="headerlink" title="题型4:综合题"></a>题型4:综合题</h3><ul>
<li><em>2019</em></li>
</ul>
<h4 id="样例题-3"><a href="#样例题-3" class="headerlink" title="样例题"></a>样例题</h4><p>![[截屏2024-06-21 17.42.05.png|500]]</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><ul>
<li>本来往年题型还是比较固定的，第一问用例图、第二问领域模型图、第三问交互图</li>
<li>但是由于今年交互图提前到了应用题，这里的第三问就有点不好说了，只能把能想到的都试着复习一下了</li>
</ul>
<h4 id="可能一：用例-用例图（极其有可能）"><a href="#可能一：用例-用例图（极其有可能）" class="headerlink" title="可能一：用例+用例图（极其有可能）"></a>可能一：用例+用例图（极其有可能）</h4><ul>
<li>确定角色<ul>
<li>跟系统产生交互的“人”</li>
<li>可能有多个，样例题中就有病人+药剂师</li>
<li>一个角色一个用例图</li>
<li>一个用例图要用方框框起来</li>
</ul>
</li>
<li>确定用例图<ul>
<li>确定基础用例<ul>
<li>确定角色可能遇到的事件，一个事件一个基础用例<ul>
<li>病人跟系统交互的事件有交费、查询</li>
<li>药剂师跟系统交互的事件有配药完成、取药完成</li>
</ul>
</li>
<li>角色和基础用例之间只用连线不用箭头</li>
</ul>
</li>
<li>是否有包含子用例？<ul>
<li>首先包含子用例必须也是与用户交互的用例（比如挂号中的密码输入）</li>
<li>大部分情况而言，包含子用例是在两个及以上的基础用例中都有的某个操作，才会提出了一个公共的子用例用作包含子用例，不过书中也存在单包含关系<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2022.21.21.png" alt="|"><ul>
<li>此题中病人交费以及查询等待状态都提到了“使用就医卡”，因此这里就医卡可以当作一个包含子用例</li>
</ul>
</li>
<li>包含的画法是基础用例虚线指向子用例并标注《包含》</li>
</ul>
</li>
<li>是否有拓展子用例？<ul>
<li>拓展子用例必须在场景中存在条件分支情况，该子用例往往与角色没有直接的关联关系，只有在基础用例达成某个条件的时候被调用</li>
<li>题中我个人认为超时加入滚动条以及查询超时退出系统都符合拓展子用例</li>
<li>包含的画法是子用例虚线指向基础用例并标注《包含》</li>
</ul>
</li>
</ul>
</li>
<li>示例（个人答案非标准）<img src="/../prtsc/IMG_823B65E2EC18-1.jpeg" alt="|500"><ul>
<li>主动退出查询也可以考虑画一个包含子用例</li>
</ul>
</li>
</ul>
<h4 id="可能二：领域模型（极其有可能）"><a href="#可能二：领域模型（极其有可能）" class="headerlink" title="可能二：领域模型（极其有可能）"></a>可能二：领域模型（极其有可能）</h4><ul>
<li>UML类图来描述业务背景<ul>
<li><p>找出概念候选类</p>
<ul>
<li>首先把所有名词挑出来</li>
<li>名词可能是属性&#x2F;概念类，用以下方法区分<ul>
<li>属性一般是可以赋值的（如数字、文本），而概念类不可以，概念类只能实例化</li>
<li>如果对一个名词是概念类还是属性不确定，将其作为概念类处理</li>
</ul>
</li>
</ul>
</li>
<li><p>命名并筛选无关概念类</p>
</li>
<li><p><strong>添加必要的关联</strong></p>
<ul>
<li>用关联、继承、组合&#x2F;聚合表示</li>
<li>关联分为两种<ul>
<li>&#x3D;&#x3D;“需要知道”型关联&#x3D;&#x3D;：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑</li>
<li>“只需理解”型关联：有助于增强对领域中关键概念的理解的关联</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>添加</strong>必要的<strong>属性</strong></p>
</li>
<li><p>示例<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2022.42.59.png" alt="|425"><img src="/../prtsc/Pasted%20image%2020240621224024.png"><br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2022.45.56.png" alt="|500"></p>
</li>
<li><p>注意</p>
<ul>
<li>所有的组成一般都是聚合，极特殊为组合</li>
<li>依赖和关联好像区分的不是特别明显，不确定写关联</li>
<li>只要有“是”的关系就是继承，比如“配件是硬件”</li>
<li>如果题目中明确提出了关系的名称比如“依赖”“控制”则需要在关系上写出来</li>
<li>要标注数量对应关系（1和*）</li>
</ul>
</li>
</ul>
</li>
<li>“完整”的领域模型还需要&#x3D;&#x3D;UML活动图&#x3D;&#x3D;来表示业务流程<ul>
<li>活动图由泳道组成，为了区分各个角色之间的功能联系</li>
<li>其余的和程序流程图类似</li>
<li>示例<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2022.58.55.png" alt="|425"></li>
</ul>
</li>
</ul>
<h4 id="可能三：SSD（较小可能）"><a href="#可能三：SSD（较小可能）" class="headerlink" title="可能三：SSD（较小可能）"></a>可能三：SSD（较小可能）</h4><ul>
<li>三大元素<ul>
<li>角色</li>
<li>系统</li>
<li>消息<ul>
<li>消息还有可能为“可选消息”</li>
<li>还有可能为“循环消息”</li>
<li>消息都是一问一答</li>
</ul>
</li>
</ul>
</li>
<li>示例<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2023.03.02.png" alt="|500"></li>
</ul>
<h4 id="可能四：操作契约（较小可能）"><a href="#可能四：操作契约（较小可能）" class="headerlink" title="可能四：操作契约（较小可能）"></a>可能四：操作契约（较小可能）</h4><ul>
<li>每一个操作契约的模版<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2011.44.46.png" alt="|"></li>
<li>首先根据SSD找出所有的操作，针对于每一个操作<ul>
<li>操作名称：<ul>
<li>SSD中的函数名</li>
</ul>
</li>
<li>交叉引用：<ul>
<li>SSD的用例名称</li>
</ul>
</li>
<li>前置条件<ul>
<li>执行之前的状态，比如xxx已经准备就绪</li>
</ul>
</li>
<li>后置条件<ul>
<li>描述操作结束之后产生的结果</li>
<li>着重关注：<ul>
<li><span style="background:#fff88f">对象实例创建和删除</span>。</li>
<li><span style="background:#fff88f">对象属性修改</span>。</li>
<li><span style="background:#fff88f">对象关联形成和断开</span>。</li>
</ul>
</li>
<li>不用强调怎么实现，只用强调结果</li>
</ul>
</li>
</ul>
</li>
<li>示例<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2023.08.46.png" alt="|"></li>
</ul>
<h4 id="可能五：动态结构设计（几乎没可能）"><a href="#可能五：动态结构设计（几乎没可能）" class="headerlink" title="可能五：动态结构设计（几乎没可能）"></a>可能五：动态结构设计（几乎没可能）</h4><ul>
<li>动态结构设计就是交互图，大概率放在应用题考</li>
</ul>
<h4 id="可能六：静态结构设计（较小可能）"><a href="#可能六：静态结构设计（较小可能）" class="headerlink" title="可能六：静态结构设计（较小可能）"></a>可能六：静态结构设计（较小可能）</h4><ul>
<li>根据一个用例中所有的交互图，扫描每一个交互图<ul>
<li>确定里面的软件对象（多个只保留一个）</li>
<li>确定软件对象所在的软件架构层次</li>
<li>确定软件对象之间的关系</li>
</ul>
</li>
<li>细化（基本上跟伪代码差不多了）<ul>
<li>确定每个软件类的属性以及类型定义</li>
<li>确定每个软件类的方法以及参数定义</li>
</ul>
</li>
<li>示例<br><img src="/../prtsc/Pasted%20image%2020240621231551.png"></li>
</ul>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul>
<li>吉人自有天相，好好复习吧</li>
</ul>
<h3 id="其他往年题"><a href="#其他往年题" class="headerlink" title="其他往年题"></a>其他往年题</h3><h4 id="交互图"><a href="#交互图" class="headerlink" title="交互图"></a>交互图</h4><ol>
<li>2017期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2023.08.46.png" alt="|"></li>
<li>2012期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.47.45.png" alt="|"><br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.48.46.png" alt="|"></li>
</ol>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><ol>
<li>2019期末</li>
<li>2017期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2020.21.47.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.40.40.png"></li>
<li>2011期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.50.16.png"></li>
<li>2010期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.52.52.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.52.58.png"></li>
<li>2013年期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2021.42.09.png"></li>
</ol>
<h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><ol>
<li>2017期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.39.54.png"></li>
<li>2011期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.49.47.png"></li>
<li>2010期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.52.08.png"></li>
</ol>
<h4 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h4><ol>
<li>2010期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.53.24.png"></li>
<li>2017期末<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.40.55.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-21%2017.41.14.png"></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Alley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/29/%E5%A4%A7%E4%B8%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">http://example.com/2024/06/29/%E5%A4%A7%E4%B8%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/">大三课程</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">大三数据库笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三数据库笔记</div></div></a></div><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三编译原理笔记</div></div></a></div><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三算法笔记</div></div></a></div><div><a href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="大三操作系统笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">大三操作系统笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alley</div><div class="author-info__description">学习与生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 软件工程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">软件的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">软件危机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E9%80%94%E5%BE%84"><span class="toc-number">1.3.</span> <span class="toc-text">软件危机的解决途径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%A6%81%E7%B4%A0"><span class="toc-number">1.4.</span> <span class="toc-text">软件工程要素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">第二章 软件生命周期模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.</span> <span class="toc-text">软件生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">软件生命周期模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%9E%8B%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">传统模型种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%9E%8B%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">新型软件生命周期模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">第三章 软件需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">需求分析的对象、任务和目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E3%80%81%E5%8A%9F%E8%83%BD%E5%8F%8A%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.2.</span> <span class="toc-text">数据、功能及行为建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E7%B1%BB%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">需求类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9C%80%E6%B1%82%E7%B1%BB%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">其他需求类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">第四章 面向对象需求分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UML-4-1%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">UML 4+1视图的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%9A%849%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%9B%BE"><span class="toc-number">4.2.</span> <span class="toc-text">UML的9个基本图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%BB%BA%E6%A8%A1"><span class="toc-number">4.3.</span> <span class="toc-text">面向对象的需求分析建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">领域模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.5.</span> <span class="toc-text">创建领域模型的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.6.</span> <span class="toc-text">类的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.7.</span> <span class="toc-text">用例模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE"><span class="toc-number">4.8.</span> <span class="toc-text">用例图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B%E4%B8%8E%E5%AD%90%E7%94%A8%E4%BE%8B"><span class="toc-number">4.9.</span> <span class="toc-text">基本用例与子用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">4.10.</span> <span class="toc-text">系统顺序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%A5%91%E7%BA%A6"><span class="toc-number">4.11.</span> <span class="toc-text">操作契约</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E5%88%99"><span class="toc-number">5.</span> <span class="toc-text">第六章 软件设计的概念及原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.1.</span> <span class="toc-text">软件概要设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.2.</span> <span class="toc-text">软件详细设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">软件设计模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text">软件的模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%86%85%E8%81%9A%E6%80%A7"><span class="toc-number">5.5.</span> <span class="toc-text">模块的内聚性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E8%80%A6%E5%90%88%E6%80%A7"><span class="toc-number">5.6.</span> <span class="toc-text">模块的耦合性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.7.</span> <span class="toc-text">面向对象的设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">第七章 面向对象设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8EUML"><span class="toc-number">6.1.</span> <span class="toc-text">面向对象的设计与UML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.2.</span> <span class="toc-text">面向对象设计的关键步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EBS%E7%BB%93%E6%9E%84-%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">(基于BS结构)模型的层次化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">面向对象的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%81%8C%E8%B4%A3%E5%88%86%E9%85%8D-Grasp-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">类职责分配(Grasp)模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8-Controller-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">控制器(Controller)模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%80%85-Creator-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.7.</span> <span class="toc-text">创建者(Creator)模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E4%B8%93%E5%AE%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.8.</span> <span class="toc-text">信息专家模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE"><span class="toc-number">6.9.</span> <span class="toc-text">创建设计类图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">第九章 程序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%96%87%E6%A1%A3%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">源程序文档化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E8%A8%80%E6%80%A7%E6%B3%A8%E9%87%8A"><span class="toc-number">7.2.</span> <span class="toc-text">序言性注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E6%B3%A8%E9%87%8A"><span class="toc-number">7.3.</span> <span class="toc-text">功能性注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">第十章 软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">软件测试流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">两种常用的测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">白盒测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95"><span class="toc-number">8.4.</span> <span class="toc-text">基本路径测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.5.</span> <span class="toc-text">控制流图的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E7%9A%84%E7%8E%AF%E8%B7%AF%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">8.6.</span> <span class="toc-text">控制流图的环路复杂度计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">8.7.</span> <span class="toc-text">导出测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">8.8.</span> <span class="toc-text">黑盒测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86"><span class="toc-number">8.9.</span> <span class="toc-text">等价类划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%8E%9F%E5%88%99"><span class="toc-number">8.10.</span> <span class="toc-text">划分等价类原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">8.11.</span> <span class="toc-text">确定测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E4%B8%BE%E4%BE%8B"><span class="toc-number">8.12.</span> <span class="toc-text">等价类划分举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">8.13.</span> <span class="toc-text">边界值分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE"><span class="toc-number">8.14.</span> <span class="toc-text">因果图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="toc-number">8.15.</span> <span class="toc-text">因果图中的符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E4%B8%AA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.16.</span> <span class="toc-text">五个软件测试的基本类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4"><span class="toc-number">9.</span> <span class="toc-text">第十一章 软件维护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">维护的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95-%E5%A4%A7%E9%A2%98%E4%B8%93%E7%B2%BE%E6%8C%87%E5%8D%97"><span class="toc-number">10.</span> <span class="toc-text">附录 大题专精指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B1-%E4%BA%A4%E4%BA%92%E5%9B%BE"><span class="toc-number">10.1.</span> <span class="toc-text">题型1:交互图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E9%A2%98"><span class="toc-number">10.1.1.</span> <span class="toc-text">样例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">10.1.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.1.3.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B2-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">10.2.</span> <span class="toc-text">题型2:白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E9%A2%98-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">样例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">10.2.3.</span> <span class="toc-text">步骤一：程序流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%B5%81%E5%9B%BE-%E7%8E%AF%E8%B7%AF%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">10.2.4.</span> <span class="toc-text">步骤二：程序流图+环路复杂性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E7%8B%AC%E7%AB%8B%E8%B7%AF%E5%BE%84%E9%9B%86"><span class="toc-number">10.2.5.</span> <span class="toc-text">步骤三：独立路径集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">10.2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B3-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">10.3.</span> <span class="toc-text">题型3:黑盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E9%A2%98-2"><span class="toc-number">10.3.1.</span> <span class="toc-text">样例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">10.3.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">10.3.3.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">10.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B4-%E7%BB%BC%E5%90%88%E9%A2%98"><span class="toc-number">10.4.</span> <span class="toc-text">题型4:综合题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E9%A2%98-3"><span class="toc-number">10.4.1.</span> <span class="toc-text">样例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-3"><span class="toc-number">10.4.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%B8%80%EF%BC%9A%E7%94%A8%E4%BE%8B-%E7%94%A8%E4%BE%8B%E5%9B%BE%EF%BC%88%E6%9E%81%E5%85%B6%E6%9C%89%E5%8F%AF%E8%83%BD%EF%BC%89"><span class="toc-number">10.4.3.</span> <span class="toc-text">可能一：用例+用例图（极其有可能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%BA%8C%EF%BC%9A%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%9E%81%E5%85%B6%E6%9C%89%E5%8F%AF%E8%83%BD%EF%BC%89"><span class="toc-number">10.4.4.</span> <span class="toc-text">可能二：领域模型（极其有可能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%B8%89%EF%BC%9ASSD%EF%BC%88%E8%BE%83%E5%B0%8F%E5%8F%AF%E8%83%BD%EF%BC%89"><span class="toc-number">10.4.5.</span> <span class="toc-text">可能三：SSD（较小可能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E5%9B%9B%EF%BC%9A%E6%93%8D%E4%BD%9C%E5%A5%91%E7%BA%A6%EF%BC%88%E8%BE%83%E5%B0%8F%E5%8F%AF%E8%83%BD%EF%BC%89"><span class="toc-number">10.4.6.</span> <span class="toc-text">可能四：操作契约（较小可能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%BA%94%EF%BC%9A%E5%8A%A8%E6%80%81%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%87%A0%E4%B9%8E%E6%B2%A1%E5%8F%AF%E8%83%BD%EF%BC%89"><span class="toc-number">10.4.7.</span> <span class="toc-text">可能五：动态结构设计（几乎没可能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E5%85%AD%EF%BC%9A%E9%9D%99%E6%80%81%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%BE%83%E5%B0%8F%E5%8F%AF%E8%83%BD%EF%BC%89"><span class="toc-number">10.4.8.</span> <span class="toc-text">可能六：静态结构设计（较小可能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">10.4.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BE%80%E5%B9%B4%E9%A2%98"><span class="toc-number">10.5.</span> <span class="toc-text">其他往年题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%9B%BE"><span class="toc-number">10.5.1.</span> <span class="toc-text">交互图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">10.5.2.</span> <span class="toc-text">白盒测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">10.5.3.</span> <span class="toc-text">黑盒测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E9%A2%98"><span class="toc-number">10.5.4.</span> <span class="toc-text">综合题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E5%A4%A7%E4%B8%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" title="大三软件工程">大三软件工程</a><time datetime="2024-06-29T12:22:03.000Z" title="Created 2024-06-29 20:22:03">2024-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记">大三数据库笔记</a><time datetime="2024-05-21T11:07:55.000Z" title="Created 2024-05-21 19:07:55">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记">大三算法笔记</a><time datetime="2024-05-21T11:04:16.000Z" title="Created 2024-05-21 19:04:16">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="大三操作系统笔记">大三操作系统笔记</a><time datetime="2024-05-21T11:00:36.000Z" title="Created 2024-05-21 19:00:36">2024-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/21/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记">大三编译原理笔记</a><time datetime="2024-05-21T10:58:47.000Z" title="Created 2024-05-21 18:58:47">2024-05-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Alley</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>