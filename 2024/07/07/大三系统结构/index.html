<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>大三系统结构 | Alley的深巷子</title><meta name="author" content="Alley"><meta name="copyright" content="Alley"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录了大三的系统结构复习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="大三系统结构">
<meta property="og:url" content="http://example.com/2024/07/07/%E5%A4%A7%E4%B8%89%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Alley的深巷子">
<meta property="og:description" content="记录了大三的系统结构复习笔记">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/touxiang1.jpg">
<meta property="article:published_time" content="2024-07-07T14:16:11.000Z">
<meta property="article:modified_time" content="2024-07-07T14:16:24.504Z">
<meta property="article:author" content="Alley">
<meta property="article:tag" content="大三课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/touxiang1.jpg"><link rel="shortcut icon" href="/images/touxiang1.jpg"><link rel="canonical" href="http://example.com/2024/07/07/%E5%A4%A7%E4%B8%89%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/index.html"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '大三系统结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-07 22:16:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/styles/main.css"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/live2d-widget/autoload.js"> </script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/touxiang1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/dingbu1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Alley的深巷子"><span class="site-name">Alley的深巷子</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">大三系统结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-07-07T14:16:11.000Z" title="Created 2024-07-07 22:16:11">2024-07-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-07-07T14:16:24.504Z" title="Updated 2024-07-07 22:16:24">2024-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="大三系统结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章-计算机系统结构的基本概念"><a href="#第一章-计算机系统结构的基本概念" class="headerlink" title="第一章 计算机系统结构的基本概念"></a>第一章 计算机系统结构的基本概念</h2><blockquote>
<p>30%+<br>大量的选择题、填空题<br>简答题<br>一道送分大题</p>
</blockquote>
<h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><ul>
<li>在计算机发展的开始25年中“计算机制造技术发展”和“计算机体系系统结构创新”都起着主导作用，使得计算机性能每年提高约25%</li>
<li>20世纪70年代末到80年代初，大规模集成电路和微处理器使得计算机性能年增长35%</li>
<li>20世纪80年代初，RISC（精简指令集计算机）的结构简化了指令系统，有效的提升了性能，计算机性能年增长达到了50%以上</li>
<li>2002年后计算机性能的年增长下降到约20%，系统结构从单纯依靠指令级并行转向开发线程级并行和数据级并行</li>
</ul>
<h3 id="1-2-计算机系统结构的概念"><a href="#1-2-计算机系统结构的概念" class="headerlink" title="1.2 计算机系统结构的概念"></a>1.2 计算机系统结构的概念</h3><h4 id="1-2-1-计算机系统的结构层次"><a href="#1-2-1-计算机系统的结构层次" class="headerlink" title="1.2.1 计算机系统的结构层次"></a>1.2.1 计算机系统的结构层次</h4><ul>
<li><font color="#d83931">计算机的多级层次结构，每一层以一种语言为特征</font><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2013.33.30.png"></li>
<li>L0硬连逻辑级（和L1合称计算机组织与实现）</li>
<li>L1微程序机器级——<span style="background:#fff88f">微指令集</span></li>
<li>L2传统机器级——<span style="background:#fff88f">传统的机器指令集</span><ul>
<li>有的计算机没有微程序技术，因此没有L1直接通过硬连逻辑解释执行L2指令集，速度快、被RISC处理器所采用</li>
</ul>
</li>
<li>L3操作系统虚拟机（软件实现的机器）——<span style="background:#fff88f">传统机器级指令</span>+操作系统级指令<ul>
<li>操作系统级指令实现对操作系统功能的调用（开关读写文件等）</li>
</ul>
</li>
<li>L4汇编语言虚拟机——<span style="background:#fff88f">汇编语言</span><ul>
<li>汇编程序把汇编语言翻译成L2、3级语言</li>
</ul>
</li>
<li>L5高级语言虚拟机——<span style="background:#fff88f">高级语言</span><ul>
<li>编译器把高级语言程序翻译成L3、4级语言</li>
</ul>
</li>
<li>L6应用语言虚拟机——<span style="background:#fff88f">应用语言</span>（如人工智能、教育、管理等专业领域虚拟机）<ul>
<li>应用程序包把应用语言程序翻译成L5级语言</li>
</ul>
</li>
<li>L1～3解释、L4～6翻译<ul>
<li>共同点：<ul>
<li>执行多条低一级指令来实现高一级指令</li>
</ul>
</li>
<li>不同点：<ul>
<li>翻译：先把高级程序全部转换成低一级程序，然后再执行低一级程序</li>
<li>解释：每当一条高级指令译码、直接执行一串等效的低一级指令</li>
</ul>
</li>
<li>解释比翻译执行花的时间更多，但占用存储空间小</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-计算机系统结构的定义"><a href="#1-2-2-计算机系统结构的定义" class="headerlink" title="1.2.2 计算机系统结构的定义"></a>1.2.2 计算机系统结构的定义</h4><ul>
<li><font color="#d83931">定义一：程序员所看到的计算机属性，即概念型结构和功能特性</font><ul>
<li>不同级的程序员所看到的计算机具有不同的属性</li>
<li>不同的计算机系统在传统机器级和汇编语言级程序员眼中完全不同，但在高级语言程序员眼中几乎没有差别——<span style="background:#fff88f">透明性</span>，低层属性对高层透明</li>
</ul>
</li>
<li><font color="#d83931">定义二：计算机系统的软、硬件的界面，即机器语言程序员所看到的传统机器级所具有的属性</font></li>
<li><font color="#d83931">广义系统结构定义：指令集结构、组成和硬件</font></li>
<li>为了程序能在计算机上运行所需遵循的计算机属性：指令系统、数据表示、寻址规则、寄存器定义、中断系统、机器工作状态定义+转换、存储系统、信息保护、I&#x2F;O结构</li>
</ul>
<h4 id="1-2-3-计算机组成和计算机实现"><a href="#1-2-3-计算机组成和计算机实现" class="headerlink" title="1.2.3 计算机组成和计算机实现"></a>1.2.3 计算机组成和计算机实现</h4><ul>
<li><font color="#d83931">计算机组成：计算机系统结构的逻辑实现</font>，如物理机器级中的数据流和控制流的组成以及逻辑设计<ul>
<li>着眼于各事件的<span style="background:#fff88f">排序方式和控制方式、</span>各部件的功能以及各部件之间的联系</li>
</ul>
</li>
<li><font color="#d83931">计算机实现：计算机组成的物理实现</font>，如处理机和主存的物理结构、器件底板信号传输电源冷却整机装配等<ul>
<li>着眼于<span style="background:#fff88f">器件技术和微组装技术</span></li>
</ul>
</li>
<li>举例：乘法<ul>
<li>是否有乘法指令？——计算机系统结构</li>
<li>乘法器实现还是多步加法器实现？——计算机组成</li>
<li>乘法器的物理器件和微组装？——计算机实现</li>
</ul>
</li>
<li>系列机：相同的系统结构、不同的组成和实现</li>
</ul>
<h4 id="1-2-4-计算机系统结构的分类"><a href="#1-2-4-计算机系统结构的分类" class="headerlink" title="1.2.4 计算机系统结构的分类"></a>1.2.4 计算机系统结构的分类</h4><ul>
<li><font color="#d83931">冯氏分类法</font><ul>
<li>用系统最<span style="background:#fff88f">大并行度分类</span>（<span style="background:#fff88f">单位时间内能够处理的最大二进制位数</span>）</li>
</ul>
</li>
<li><font color="#d83931">Flynn分类法</font><ul>
<li>按照指令流和数据流的多倍性进行分类<ul>
<li>指令流：计算机执行的指令序列</li>
<li>数据流：指令流调用的数据序列</li>
<li>多倍性：系统受限的部件上同时处于同一执行阶段的指令或数据的最大数目</li>
</ul>
</li>
<li><span style="background:#fff88f">具体分类</span>：<ul>
<li>单指令流单数据流SISD<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2013.34.22.png"></li>
<li>单指令流多数据流SIMD<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2013.34.33.png"></li>
<li>多指令流单数据流MISD<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2013.34.44.png"></li>
<li>多指令流多数据流MIMD<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2013.35.00.png"></li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">Handler分类法</font><ul>
<li>根据并行度和流水线分类，计算机的硬件结构分成三个层次，并分别考虑它们的可并行性和流水处理程度<ul>
<li>PCU <span style="background:#fff88f">程序控制部件的个数k</span><ul>
<li>CPU个数</li>
</ul>
</li>
<li>ALU <span style="background:#fff88f">算术逻辑部件(或运算部件PE)的个数d</span><ul>
<li>ALU部件个数</li>
</ul>
</li>
<li>ELC 每<span style="background:#fff88f">个算数逻辑部件包含基本逻辑线路电路的套数</span><strong>ω</strong><ul>
<li>字长</li>
</ul>
</li>
</ul>
</li>
<li><span style="background:#fff88f">表示方法</span><ul>
<li><strong>t(</strong> 系统型号) &#x3D; (k, d, ω)</li>
<li>t(系统型号) &#x3D; (k x k’, d x d’, ω x ω’)<ul>
<li>**k’:宏流水线中<span style="background:#fff88f">程序控制部件的个数</span></li>
<li>d’:指令流水线中算数逻辑部件的个数<ul>
<li><span style="background:#fff88f">几级流水</span></li>
</ul>
</li>
<li>ω’:操作流水线中基本逻辑线路的套数<ul>
<li><span style="background:#fff88f">多少位流水线处理</span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-定量分析技术"><a href="#1-3-定量分析技术" class="headerlink" title="1.3 定量分析技术"></a>1.3 定量分析技术</h3><h4 id="1-3-1-计算机系统设计的定量原理"><a href="#1-3-1-计算机系统设计的定量原理" class="headerlink" title="1.3.1 计算机系统设计的定量原理"></a>1.3.1 计算机系统设计的定量原理</h4><ol>
<li><font color="#d83931">以经常性事件为重点</font><ul>
<li>要按照对经常发生的情况采用<span style="background:#fff88f">优先优化</span></li>
</ul>
</li>
<li><font color="#d83931">Amdahl定律</font><br> -<span style="background:#fff88f"> 加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比</span>（用得少的东西优化再好也没用）<ul>
<li><span style="background:#fff88f"><font color="#d83931">加速比</font></span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2013.35.14.png"><ul>
<li>依赖因素一：可改进部分的执行时间占总执行时间的比例——<span style="background:#fff88f">可改进比例</span></li>
<li>依赖因素二：可改进部分改进以后性能提高的倍数——<span style="background:#fff88f">部件加速比</span></li>
</ul>
</li>
<li>总执行时间<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2013.35.23.png"></li>
<li>引申结论：仅针对计算任务的一部分进行性能改进，越改进性能提升越小（边际递减）</li>
</ul>
</li>
<li><font color="#d83931">CPU性能公式</font><ul>
<li>CPU时间&#x3D;执行程序需要的时钟周期数 * 时钟周期时长</li>
<li><font color="#d83931">CPI</font>（单指令平均周期数）&#x3D;执行程序需要的时钟周期数&#x2F;执行的指令条数</li>
<li><span style="background:#fff88f">性能公式</span>：CPU时间&#x3D;IC * CPI * 时钟周期时间</li>
<li>CPU时钟周期数&#x3D;∑（CPIᵢ * ICᵢ）<ul>
<li>每个指令需要的周期数x每个指令的个数<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2014.29.31.png"></li>
</ul>
</li>
<li><span style="background:#fff88f">CPU性能&#x3D;CPU执行时间</span></li>
</ul>
</li>
<li><font color="#d83931">程序的局部性原理</font><ul>
<li>程序执行时间的90%都是在执行程序中10%的代码</li>
<li>数据访问也有局部性但是弱于代码访问的局部性</li>
</ul>
</li>
</ol>
<h4 id="1-3-2-计算机系统的性能评测"><a href="#1-3-2-计算机系统的性能评测" class="headerlink" title="1.3.2 计算机系统的性能评测"></a>1.3.2 计算机系统的性能评测</h4><ul>
<li><font color="#d83931">执行时间和吞吐率</font><ul>
<li>执行时间——执行单个程序所花的时间少</li>
<li><span style="background:#fff88f">吞吐率</span>——<span style="background:#fff88f">单位时间里完成的任务</span>多</li>
<li>性能为n倍&#x3D;执行时间为1&#x2F;n</li>
</ul>
</li>
<li><font color="#d83931">指令执行速度</font><ul>
<li><span style="background:#fff88f">MIPS</span>（每秒执行的指令的百万数）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2014.30.18.png"><ul>
<li>Fz为工作主频</li>
</ul>
</li>
<li><span style="background:#fff88f">MFLOPS</span>（每秒执行的浮点运算的百万数）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2014.30.25.png"></li>
</ul>
</li>
<li>基准测试程序<ul>
<li>让所有的制造商产品测试同一套测试程序，采用相同的编译器和标志，尽量全面的反映两台计算机的相对性能</li>
</ul>
</li>
<li>性能比较<ul>
<li>比较各个电脑运行测试程序的总执行时间</li>
<li>比较加权执行时间</li>
</ul>
</li>
</ul>
<h3 id="1-4-计算机系统结构的发展"><a href="#1-4-计算机系统结构的发展" class="headerlink" title="1.4 计算机系统结构的发展"></a>1.4 计算机系统结构的发展</h3><h4 id="1-4-1-冯·诺伊曼结构"><a href="#1-4-1-冯·诺伊曼结构" class="headerlink" title="1.4.1 冯·诺伊曼结构"></a>1.4.1 冯·诺伊曼结构</h4><ul>
<li><font color="#d83931">冯诺伊曼结构计算机</font><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2014.30.38.png"><ul>
<li>存储程序原理的基本点是<span style="background:#fff88f">指令驱动</span></li>
<li><font color="#d83931">主要特点</font>：<ul>
<li>&#x3D;&#x3D;以运算器为中心&#x3D;&#x3D;，输入输出&#x2F;存储器的指令传输都要经过运算器，联系由控制器统一控制</li>
<li>&#x3D;&#x3D;指令和数据同样对待&#x3D;&#x3D;，指令组成的程序可以修改</li>
<li>&#x3D;&#x3D;存储器按地址访问&#x3D;&#x3D;，按照顺序线性编址的一维结构</li>
<li>&#x3D;&#x3D;顺序执行指令&#x3D;&#x3D;，程序的分支由转移指令实现，由指令计数器PC指明当前正在执行的指令在存储器中的地址</li>
<li>&#x3D;&#x3D;指令由操作码和地址码组成&#x3D;&#x3D;，操作码指明操作类型，地址码指明操作数地址和存放运算结果的地址。操作数的类型由操作码决定</li>
<li>&#x3D;&#x3D;指令和数据均已二进制表示&#x3D;&#x3D;</li>
</ul>
</li>
<li><font color="#d83931">后人改进</font><ul>
<li>对于<font color="#d83931">输入输出</font>改进<ul>
<li>通过从CPU<span style="background:#fff88f">分离输入输出管理工作来避免运算器成为整个系统的瓶颈</span>!<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2014.30.54.png"></li>
<li>CPU不用等待I&#x2F;O执行结果，直接继续计算，I&#x2F;O通过中断提醒CPU处理，实现了一定程度的并行工作</li>
<li>仍以运算器为中心</li>
</ul>
</li>
<li>DMA直接<font color="#d83931">存储器</font>访问<ul>
<li>外设和存储器之间直接建立数据通路，不必经过运算器</li>
<li>DMA在完成所指定的<span style="background:#fff88f">一批数据的传送</span>之后才向CPU发结束信号，使CPU进行一些事后处理工作</li>
</ul>
</li>
<li>采用并行处理技术<ul>
<li>先后出现向量计算机、阵列处理机、多处理机等并行处理计算机</li>
</ul>
</li>
<li><font color="#d83931">存储器</font>组织结构发展<ul>
<li>CAM把查找、比较的操作交给存储器硬件完成。</li>
<li><span style="background:#fff88f">相联处理机</span>以相连存储器为核心，让相连存储器除了完成信息检索任务外还能进行一些算术逻辑运算</li>
<li><span style="background:#fff88f">通用寄存器组</span></li>
<li><span style="background:#fff88f">设置Cache</span></li>
</ul>
</li>
<li><font color="#d83931">指令集</font>的发展<ul>
<li>随着硬件技术的发展，越来越多的功能交给硬件来实现</li>
<li>70～80年代的计算机系统指令条数达到300～500条，成为<span style="background:#fff88f">CISC</span><span style="background:#fff88f">复杂指令集计算机</span></li>
<li>1979年，<span style="background:#fff88f">RISC</span><span style="background:#fff88f">精简指令集计算机</span>的思想出现</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-4-2-软件对系统结构的影响"><a href="#1-4-2-软件对系统结构的影响" class="headerlink" title="1.4.2 软件对系统结构的影响"></a>1.4.2 软件对系统结构的影响</h4><ul>
<li>软件的<span style="background:#fff88f">可移植性</span><ul>
<li>一个软件可以不经修改或者只需少量修改就可以由一台计算机移植到另一台计算机上正确地运行。差别只是执行时间的不同。我们称这两台计算机是<font color="#d83931">软件兼容</font>的</li>
</ul>
</li>
<li><font color="#d83931">系列机</font><ul>
<li><span style="background:#fff88f">具有相同的系统结构，但具有不同组成和实现的一系列不同型号的机器</span></li>
<li>拥有相同的指令集，但是低档机的指令分析与执行顺序进行，高档机采用重叠、流水的方式并行处理</li>
<li>先确定系统结构，软件设计者设计软件，硬件设计者再选择不同的器件和实现技术来提供不同档次的计算机</li>
<li>较好地解决了系统结构相对稳定与器件硬件技术飞速发展的矛盾</li>
<li>软件兼容方式（一般支持向上、<span style="background:#fff88f">向后</span>）：<ul>
<li>向上兼容：不修改就能运行于更高档计算机</li>
<li>向下兼容：不修改就能运行于更低档计算机</li>
<li>向前兼容：不修改就能运行于更古早计算机</li>
<li><span style="background:#fff88f">向后兼容</span>：不修改就能运行于更新潮计算机</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">模拟和仿真</font><ul>
<li>在一种系统结构上实现另一种系统结构（指令集）</li>
<li>模拟<ul>
<li><span style="background:#fff88f">用软件方法在宿主机上实现虚拟机的指令集</span></li>
<li>虚拟机的每一条指令都用宿主机的一段程序进行解释执行</li>
<li>还需要模拟存储系统、I&#x2F;O系统、操作系统</li>
<li>纯<span style="background:#fff88f">软件模拟</span>，性能较差</li>
</ul>
</li>
<li>仿真<ul>
<li><span style="background:#fff88f">用宿主机的微程序取去解释目标机的指令集</span></li>
<li>还需要反正存储系统、I&#x2F;O系统、控制台操作</li>
</ul>
</li>
<li>仿真微程序存放在控制存储器中，运行速度比模拟方法快，但是只能在系统结构差距不大的计算机之间使用</li>
</ul>
</li>
<li>统一高级语言——<font color="#d83931">移植</font><ul>
<li>全世界都用java</li>
</ul>
</li>
</ul>
<h4 id="1-4-3-器件发展对系统结构的影响"><a href="#1-4-3-器件发展对系统结构的影响" class="headerlink" title="1.4.3 器件发展对系统结构的影响"></a>1.4.3 <font color="#d83931">器件发展对系统结构的影响</font></h4><ul>
<li><span style="background:#fff88f">器件发展是推动计算机系统结构发展最活跃的因素</span><ul>
<li>系统结构和组成技术的新发展和新思维是否能用的上，最终取决于器件</li>
<li>可靠性在数量级的提高– 器件的高可靠性提高成就了流水线技术</li>
<li>高速+廉价存储器– 支撑了Cache&#x2F;虚存的实现</li>
<li>PROM&#x2F;EPROM – 使得微程序技术的广泛使用</li>
</ul>
</li>
<li><font color="#d83931">摩尔定律</font>：集成电路芯片的晶体管数目每隔18个月翻一番<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-06%2014.33.03.png"><ul>
<li>当处理器的性能以惊人的速度向前发展的时候，其他部件（包括I&#x2F;O系统）的速度没有跟上-寻求性能平衡的需要：调整组织与结构</li>
</ul>
</li>
<li>量子计算</li>
</ul>
<h4 id="1-4-4-应用对系统结构的影响"><a href="#1-4-4-应用对系统结构的影响" class="headerlink" title="1.4.4 应用对系统结构的影响"></a>1.4.4 <font color="#d83931">应用对系统结构的影响</font></h4><ul>
<li>系统效率的高低是关键性问题</li>
<li><span style="background:#fff88f">应用需求是促使计算机系统结构发展的最根本的动力</span></li>
<li><span style="background:#fff88f">针对于特殊领域通用计算机满足不了应用需求，需要专门设计高性能的系统结构</span></li>
<li>专用计算机会搭载专用的系统结构来不惜一切代价的提升性能</li>
</ul>
<h3 id="1-5-计算机系统结构中并行性的发展"><a href="#1-5-计算机系统结构中并行性的发展" class="headerlink" title="1.5 计算机系统结构中并行性的发展"></a>1.5 计算机系统结构中并行性的发展</h3><h4 id="1-5-1-并行性的概念"><a href="#1-5-1-并行性的概念" class="headerlink" title="1.5.1 并行性的概念"></a>1.5.1 并行性的概念</h4><ul>
<li>并行性：计算机在同一时刻进行多种运算&#x2F;操作<ul>
<li><span style="background:#fff88f">同时性</span>：两个（以上）的事件同一时刻发生</li>
<li><span style="background:#fff88f">并发性</span>：两个（以上）的事件同一时间间隔发生</li>
</ul>
</li>
<li><font color="#d83931">并行性等级（处理数据）</font><ul>
<li><span style="background:#fff88f">字串位串</span>：一次处理一个字的一位，无并行性</li>
<li><span style="background:#fff88f">字串位并</span>：一次处理一个字的所有位，字和字串行</li>
<li><span style="background:#fff88f">字并位串</span>：一次处理多个字的同一位，并行度高</li>
<li><span style="background:#fff88f">全并行</span>：一次处理许多字的许多位</li>
</ul>
</li>
<li><font color="#d83931">并行性等级（执行程序）</font><ul>
<li><font color="#d83931">指令内部并行</font>：<span style="background:#fff88f">单条指令的微操作</span><span style="background:#fff88f">并行</span></li>
<li><font color="#d83931">指令级并行ILP</font>：<span style="background:#fff88f">并行执行多条指令</span></li>
<li><font color="#d83931">线程级并行TLP</font>：<span style="background:#fff88f">并行执行多个线程</span>（通常是一个进程派生多个线程）</li>
<li><font color="#d83931">任务级并行</font>：<span style="background:#fff88f">并行执行多个过程</span>&#x2F;任务</li>
<li><font color="#d83931">作业级并行</font>：<span style="background:#fff88f">并行执行多个作业</span>&#x2F;程序</li>
</ul>
</li>
<li>单处理机的高级并行需要通过软件（操作系统的进程&#x2F;作业管理）来实现，多处理机系统由硬件实现</li>
</ul>
<h4 id="1-5-2-提高并行性的技术途径"><a href="#1-5-2-提高并行性的技术途径" class="headerlink" title="1.5.2 提高并行性的技术途径"></a>1.5.2 提高并行性的技术途径</h4><ul>
<li><font color="#d83931">基本思想</font><ul>
<li><font color="#d83931">时间重叠</font>：<span style="background:#fff88f">轮流重叠使用同一套硬件</span>的各个部分<ul>
<li>流水线技术</li>
</ul>
</li>
<li><font color="#d83931">资源重复</font>：<span style="background:#fff88f">重复设置硬件资源</span>提高系统性能<ul>
<li>加钱</li>
</ul>
</li>
<li><font color="#d83931">资源共享</font>：<span style="background:#fff88f">多个任务按照一定时间顺序轮流使用一套硬件设备</span><ul>
<li>多道程序、分时系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-5-3-单机系统中并行性的发展"><a href="#1-5-3-单机系统中并行性的发展" class="headerlink" title="1.5.3 单机系统中并行性的发展"></a>1.5.3 单机系统中并行性的发展</h4><ul>
<li>时间重叠<ul>
<li>把一件工作分割成若干相互联系的部分，交给专门的部件分别完成，再重叠起来多个工作</li>
</ul>
</li>
<li>资源重复<ul>
<li>通用部件分割为专业部件（如加法部件、乘法部件）再重复设置</li>
</ul>
</li>
<li>资源共享<ul>
<li>通过单处理机模拟多处理机（如分时系统）</li>
</ul>
</li>
</ul>
<h4 id="1-5-4-多机系统中并行性的发展"><a href="#1-5-4-多机系统中并行性的发展" class="headerlink" title="1.5.4 多机系统中并行性的发展"></a>1.5.4 多机系统中并行性的发展</h4><ul>
<li><span style="background:#fff88f">紧密耦合系统</span>（直接耦合系统）<ul>
<li>计算机之间<span style="background:#fff88f">物理连接频带较高</span>（总线&#x2F;高速开关），共享主存，信息传输速率高，可以快速并行处理多个作业和任务</li>
</ul>
</li>
<li><span style="background:#fff88f">松散耦合系统</span>（简介耦合系统）<ul>
<li>计算机之间通过通道&#x2F;通信线路实现互联，共享外存设备</li>
<li>相互作用在文件&#x2F;数据一级上进行的</li>
<li>比如不同计算机功能分工，结果输送到共享外存供其他计算机处理</li>
<li>计算机网络通过通信线路连接实现更大范围资源共享</li>
</ul>
</li>
<li><span style="background:#fff88f">时间重叠</span><ul>
<li>处理功能分散给专门的处理机完成</li>
<li>处理机之间的耦合度加强，形成异构型多处理机系统，多个不同类型+功能的处理机按照作业顺序利用时间重叠依次对多个任务加工，各自完成规定的功能动作</li>
</ul>
</li>
<li><span style="background:#fff88f">容错系统</span><ul>
<li>多处理机可以通过设置多台相同类型的计算机构成容错系统</li>
<li>可重构系统中几台计算机都能正常工作，遇到故障后系统会重新组织分工，降低档次继续运行知道排除故障为止</li>
</ul>
</li>
<li><span style="background:#fff88f">同构多处理机系统</span><ul>
<li>为了并行处理的任务在处理机之间方便调度，因此处理机需要有同等的功能</li>
<li>多个同类型&#x2F;功能的处理机组成，可以同时处理同一作业中能够并行执行的多个任务</li>
</ul>
</li>
</ul>
<h2 id="第二章-计算机指令集结构"><a href="#第二章-计算机指令集结构" class="headerlink" title="第二章 计算机指令集结构"></a>第二章 计算机指令集结构</h2><blockquote>
<p>阿巴，应该不考，白弄了</p>
</blockquote>
<h3 id="2-1-指令集结构的分类"><a href="#2-1-指令集结构的分类" class="headerlink" title="2.1 指令集结构的分类"></a>2.1 指令集结构的分类</h3><ul>
<li>存储操作数的存储单元的类型决定了不同指令集结构的区别，比如堆栈结构、累加器结构、通用寄存器结构<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-05-28%2017.16.16.png"><ul>
<li>不同类型的结构操作数的位置、个数、给出方式都有所不同，比如堆栈中操作数隐式（都在栈顶），累加器的一个操作数是隐式（累加器），通用寄存器结构都是显式给出</li>
<li>通用寄存器结构在灵活性和提高性能方面有明显的优势：<ul>
<li>寄存器访问速度快</li>
<li>编译器能更容易且有效的分配寄存器</li>
<li>寄存器可以存放变量</li>
</ul>
</li>
<li>ALU中操作数个数和存储器个数分类<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-05-28%2017.24.02.png" alt="|550"></li>
<li>三种方式的优劣<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-05-28%2017.32.32.png" alt="|550"></li>
<li>现在MM已经被淘汰，RR备受青睐</li>
</ul>
</li>
</ul>
<h3 id="2-2-寻址方式"><a href="#2-2-寻址方式" class="headerlink" title="2.2 寻址方式"></a>2.2 寻址方式</h3><ul>
<li>当前指令集结构所使用的操作数寻址方式<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-05-28%2017.34.52.png"></li>
<li>从统计结果来看，偏移寻址和立即数寻址使用的频度最高<ul>
<li>偏移的问题是不知道偏移量的取值范围，所以不知道该留多少字段给偏移量</li>
<li>立即数也是类似</li>
</ul>
</li>
</ul>
<h3 id="2-3-指令集结构的功能设计"><a href="#2-3-指令集结构的功能设计" class="headerlink" title="2.3 指令集结构的功能设计"></a>2.3 指令集结构的功能设计</h3><ul>
<li>本质就是确定哪些功能硬件实现，哪些是软件<ul>
<li>硬件速度快、成本高、灵活性差</li>
<li>软件速度慢、价格低、灵活性好</li>
</ul>
</li>
<li>指令集的基本要求：完整性、规整性、高效率和兼容性<ul>
<li>完整性：在一个有限的存储空间内指令集所提供的指令足够使用，功能齐全、使用方便</li>
<li>规整性：包括对称性和均匀性<ul>
<li>对称性：所有与指令集相关的存储单元的使用、操作码的设置都是对称的</li>
<li>均匀性：对于不同的操作数类型、字长、操作种类和数据存储单元、指令的设置都要同等对待</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-1-CISC指令集结构的功能设计"><a href="#2-3-1-CISC指令集结构的功能设计" class="headerlink" title="2.3.1 CISC指令集结构的功能设计"></a>2.3.1 CISC指令集结构的功能设计</h4><ul>
<li>面向目标程序增强指令功能<ul>
<li>增强运算型指令的功能：如函数运算、多项式计算、十进制计算等</li>
<li>增强数据传送指令的功能：设计数据块在寄存器、主存传送的指令</li>
<li>增强程序控制指令的功能：转移指令、子程序控制指令、增强循环指令</li>
</ul>
</li>
<li>面向高级语言的优化实现来改进指令集<ul>
<li>增强对高级语言和编译器的支持</li>
<li>高级语言计算机：机器直接用硬件执行高级语言</li>
</ul>
</li>
<li>面向操作系统的优化实现改进指令集<ul>
<li>处理机工作状态和访问方式的切换</li>
<li>进程的管理和切换</li>
<li>存储管理和信息保护</li>
<li>进程的同步与互斥、信号灯的管理</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-RISC指令集结构的功能设计"><a href="#2-3-2-RISC指令集结构的功能设计" class="headerlink" title="2.3.2 RISC指令集结构的功能设计"></a>2.3.2 RISC指令集结构的功能设计</h4><ul>
<li>CISC的问题<ul>
<li>各种指令使用频度悬殊</li>
<li>指令集庞大、条数众多、很少用到</li>
<li>部分指令操作复杂，CPI较大</li>
<li>规整性差，不利于流水线</li>
</ul>
</li>
<li>RISC的原则<ul>
<li>指令条数少+简单</li>
<li>简单而统一的指令格式、减少寻址方式</li>
<li>执行在单个机器周期内完成</li>
<li>只有load-store访问存储器</li>
<li>大多数指令硬连逻辑实现</li>
<li>强调优化编译器，为高级语言程序生成优化代码</li>
<li>充分利用流水线</li>
</ul>
</li>
</ul>
<h4 id="2-3-3-控制指令"><a href="#2-3-3-控制指令" class="headerlink" title="2.3.3 控制指令"></a>2.3.3 控制指令</h4><ul>
<li>控制指令的分类<ul>
<li>条件分支（使用最多）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-05-29%2017.21.01.png"></li>
<li>跳转</li>
<li>过程调用</li>
<li>过程返回</li>
</ul>
</li>
</ul>
<h3 id="2-4-操作数的类型和大小"><a href="#2-4-操作数的类型和大小" class="headerlink" title="2.4 操作数的类型和大小"></a>2.4 操作数的类型和大小</h3><ul>
<li>数据表示：计算机硬件能够直接识别、指令集能够直接调用的数据类型：整数、布尔、实数、字符、字符串</li>
<li>数据结构：由软件进行处理和实现的各种数据类型</li>
<li>表示操作数类型的方法<ul>
<li>指令中的操作码指定（比如整数加、无符号加）</li>
<li>给数据打tag，自己带标识符</li>
</ul>
</li>
</ul>
<h3 id="2-5-指令格式的设计"><a href="#2-5-指令格式的设计" class="headerlink" title="2.5 指令格式的设计"></a>2.5 指令格式的设计</h3><ul>
<li>指令由操作码+地址码组成</li>
<li>指令的长度是否一致会影响性能以及目标代码的长度<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-05-29%2017.33.42.png" alt="|500"></li>
</ul>
<h3 id="2-6-MIPS指令集结构"><a href="#2-6-MIPS指令集结构" class="headerlink" title="2.6 MIPS指令集结构"></a>2.6 MIPS指令集结构</h3><ul>
<li>典型的RISC架构</li>
</ul>
<h4 id="2-6-1-MIPS的寄存器"><a href="#2-6-1-MIPS的寄存器" class="headerlink" title="2.6.1 MIPS的寄存器"></a>2.6.1 MIPS的寄存器</h4><ul>
<li>有32个64位通用寄存器R0～R31<ul>
<li>R0永远是0</li>
</ul>
</li>
<li>有32个64位浮点数寄存器F0～F31</li>
<li>MIPS提供单精度&#x2F;双精度操作的指令，并且提供两种寄存器之间传送数据的指令</li>
</ul>
<h4 id="2-6-2-MIPS的数据表示"><a href="#2-6-2-MIPS的数据表示" class="headerlink" title="2.6.2 MIPS的数据表示"></a>2.6.2 MIPS的数据表示</h4><ul>
<li>整数：字节（8位）、半字（16位）、字（32位）、双字（64位）</li>
<li>浮点数：单精度（32位）、双精度（64位）</li>
</ul>
<h4 id="2-6-3-MIPS的数据寻址方式"><a href="#2-6-3-MIPS的数据寻址方式" class="headerlink" title="2.6.3 MIPS的数据寻址方式"></a>2.6.3 MIPS的数据寻址方式</h4><ul>
<li>只有立即数寻址和偏移量寻址<ul>
<li>立即数&#x2F;偏移量字段均为16位</li>
</ul>
</li>
<li>寄存器间接寻址&#x3D;偏移量为0寻址</li>
<li>绝对寻址&#x3D;以R0为基准的偏移量寻址</li>
<li>MIPS是以字节寻址、地址为64位<ul>
<li>所有存储器访问必须边界对齐</li>
</ul>
</li>
</ul>
<h4 id="2-6-4-MIPS的指令格式"><a href="#2-6-4-MIPS的指令格式" class="headerlink" title="2.6.4 MIPS的指令格式"></a>2.6.4 MIPS的指令格式</h4><ul>
<li>I类指令<ul>
<li>有load指令、store指令、立即数指令、分支指令、寄存器跳转指令、寄存器链接跳转指令，立即数字段为16位、提供立即数&#x2F;偏移量<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-05-29%2017.54.33.png"></li>
<li>load：Regs[rs]+immediate<ul>
<li>访问地址“寄存器rs的值加立即数”然后存入寄存器rt</li>
</ul>
</li>
<li>store：Regs[rs]+immediate<ul>
<li>取出寄存器rt的数然后存入地址“寄存器rs的值加立即数”</li>
</ul>
</li>
<li>立即数：Regs[rt] &lt;- Reg[rs] op immediate<ul>
<li>寄存器rs的值与立即数运算然后存入寄存器rt</li>
</ul>
</li>
<li>分支指令：PC+immediate<ul>
<li>转移到地址“寄存器PC的值加立即数”</li>
<li>rt字段无用</li>
</ul>
</li>
<li>寄存器跳转：Reg[rs]<ul>
<li>转移到地址“寄存器rs的值”</li>
</ul>
</li>
</ul>
</li>
<li>R类指令<ul>
<li>有ALU指令、专用寄存器读&#x2F;写指令、move指令等. </li>
<li>ALU：Reg[rd]&lt;-Regs[rs] funct Regs[rt]<ul>
<li>funcy为具体运算操作编码</li>
</ul>
</li>
</ul>
</li>
<li>J类指令<ul>
<li>有跳转指令、跳转并链接指令、自陷指令与异常返回指令，低26位为偏移量，相加PC得到跳转地址<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2014.01.51.png"></li>
</ul>
</li>
</ul>
<h4 id="2-6-5-MIPS的操作"><a href="#2-6-5-MIPS的操作" class="headerlink" title="2.6.5 MIPS的操作"></a>2.6.5 MIPS的操作</h4><ul>
<li>MIPS可以分为4类：load&amp;store、ALU操作、分支&amp;跳转、浮点操作</li>
<li>除了R0（恒为0）之外所有的寄存器都可以load&#x2F;store<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2014.24.15.png" alt="|625"></li>
<li>所有的ALU指令都是RR型或立即数行，操作包括算术和逻辑操作：加减与或异或和移位等<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2014.27.06.png" alt="|625"><ul>
<li>R0永远为0，因此可以合成操作<ul>
<li>如：DADD R1,R0,R2——把R2数据传送到R1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-6-6-MIPS的控制指令"><a href="#2-6-6-MIPS的控制指令" class="headerlink" title="2.6.6 MIPS的控制指令"></a>2.6.6 MIPS的控制指令</h4><ul>
<li>跳转是无条件转移，分为直接跳转和目标地址由寄存器给出的间接跳转<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2014.42.43.png" alt="|625"></li>
<li>分支都是条件转移、条件由指令决定</li>
</ul>
<h4 id="2-6-7-MIPS的浮点操作"><a href="#2-6-7-MIPS的浮点操作" class="headerlink" title="2.6.7 MIPS的浮点操作"></a>2.6.7 MIPS的浮点操作</h4><ul>
<li>操作码给出操作数是单精度SP还是双精度UP<ul>
<li>后缀S表示操作数单精度、D表示双精度</li>
<li>如SUB.D和SUB.S</li>
</ul>
</li>
</ul>
<h2 id="第三章-流水线技术-向量处理机"><a href="#第三章-流水线技术-向量处理机" class="headerlink" title="第三章 流水线技术+向量处理机"></a>第三章 流水线技术+向量处理机</h2><ul>
<li>流水线技术：最重要的内容，几乎贯穿各章<blockquote>
<p>17%<br>时空图<br>简答题一道<br>大题一道</p>
</blockquote>
</li>
<li>向量处理机：流水线的重要应用<blockquote>
<p>10%<br>简答题一道<br>大题一道（小概率）<br>ps：链接+编队</p>
</blockquote>
</li>
</ul>
<h3 id="3-1-流水线的基本概念"><a href="#3-1-流水线的基本概念" class="headerlink" title="3.1 流水线的基本概念"></a>3.1 流水线的<font color="#d83931">基本概念</font></h3><h4 id="3-1-1-什么是流水线"><a href="#3-1-1-什么是流水线" class="headerlink" title="3.1.1 什么是流水线"></a>3.1.1 <span style="background:#fff88f">什么是流水线</span></h4><ul>
<li>把一个重复的过程分解为若干个子过程，每隔子过程由专门的功能部件来实现。把多个处理过程在时间上错开，依次通过各个功能段，每个子过程可以与其他子过程并行执行——流水线技术<ul>
<li>流水线的每个子过程称为流水线的级、段</li>
<li>流水线的段数又称为流水线的深度</li>
</ul>
</li>
<li>指令流水线：流水线用于指令解释执行过程<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2015.12.09.png" alt="|500"></li>
<li>运算流水线：流水线用于运算的执行过程<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2015.13.48.png" alt="|500"></li>
<li><font color="#d83931">时空图</font>：<span style="background:#fff88f">横坐标代表时间、纵坐标代表空间</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2015.14.18.png" alt="|500"></li>
<li>流水线的特点<ul>
<li>流水线把一个处理过程分解为若干个子过程，依靠多个独立的功能部件的并行工作来缩短程序的执行时间</li>
<li>流水线的各段时间应该尽可能相等，否则流水线会阻塞、断流，时间长的段会成为流水线的瓶颈</li>
<li>每一个功能部件后都需要有一个缓冲寄存器（锁存器）称为流水寄存器，用于在相邻的两段之间传送数据，并把各段的处理工作相互隔离</li>
<li>流水线适合大量重复的时序过程</li>
<li>流水线需要有通过时间（进入流水线）和排空时间（离开流水线）</li>
</ul>
</li>
</ul>
<h4 id="3-1-2-流水线的分类"><a href="#3-1-2-流水线的分类" class="headerlink" title="3.1.2 流水线的分类"></a>3.1.2 <font color="#d83931">流水线的分类</font></h4><ol>
<li><span style="background:#fff88f">单功能流水线与多功能流水线</span><ol>
<li>单功能流水线：只能完成一种固定功能的流水线</li>
<li>多功能流水线：流水线的各段可以进行不同的链接以实现不同的功能<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2015.49.59.png" alt="|500"></li>
</ol>
</li>
<li><span style="background:#fff88f">静态流水线和动态流水线</span><ol>
<li>静态流水线：同一时间内各段只能按照同一种功能的连接方式工作，如果要按照另一种连接实现其他功能必须等原来连接方式处理的所有任务都流出流水线后才能改变连接<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2015.51.23.png" alt="|500"></li>
<li>动态流水线：同一时间内多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2015.51.34.png" alt="|500"></li>
</ol>
</li>
<li><span style="background:#fff88f">部件级、处理机级、处理机间级</span><ol>
<li>部件级流水线：<span style="background:#fff88f">运算部件分段</span>来让运算操作流水方式进行（运算操作流水线）</li>
<li>处理机级流水线：<span style="background:#fff88f">把指令的解释过程按</span>照流水方式处理（<span style="background:#fff88f">指令流水线</span>）</li>
<li>处理机间流水线：由两个或者两个<span style="background:#fff88f">以上的处理机川行</span><span style="background:#fff88f">起来</span>，每个处理机类似一“段”（<span style="background:#fff88f">宏流水线</span>）</li>
</ol>
</li>
<li><span style="background:#fff88f">线性流水线与非线性流水线</span><ol>
<li>线性流水线：流水线的各段串行连接、没有反馈回路，数据流过流水线的各段时，每个段最多只流过一次</li>
<li>非线形流水线：流水线中除了有串行的连接还有<span style="background:#fff88f">反馈回路</span>，常用于递归或者组成多功能流水线<ul>
<li>非线型流水线的调度：确定什么时候引进新的任务来让该任务不会与先前进入流水线的任务发生冲突</li>
</ul>
</li>
</ol>
</li>
<li><span style="background:#fff88f">顺序流水线与乱序流水线</span><ol>
<li>顺序流水线：流水线输出端任务流出的顺序和输入端流入的顺序完全相同</li>
<li>乱序流水线：允许流入顺序和流出顺序不同</li>
</ol>
</li>
</ol>
<ul>
<li>指令执行部件中采用了流水线的处理机称为流水线处理机，如果处理机不具有向量数据表示和向量指令，仅对标量数据进行流水处理称为标量处理机</li>
<li>向量流水处理机是具有向量数据表示和向量指令的处理机</li>
</ul>
<h3 id="3-2-流水线的性能指标"><a href="#3-2-流水线的性能指标" class="headerlink" title="3.2 流水线的性能指标"></a>3.2 流水线的<font color="#d83931">性能指标</font></h3><h4 id="3-2-1-吞吐率"><a href="#3-2-1-吞吐率" class="headerlink" title="3.2.1 吞吐率"></a>3.2.1 <font color="#d83931">吞吐率</font></h4><ul>
<li><span style="background:#fff88f">吞吐率是单位时间内流水线所完成的任务数量</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2016.23.43.png" alt="|450"></li>
<li>各段时间均相等的流水线<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2016.25.05.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2016.27.00.png"><ul>
<li><span style="background:#fff88f">任务数量越多，吞吐率越接近最大吞吐率</span></li>
</ul>
</li>
<li>各段时间不完全相等的流水线<ul>
<li>流水线中时间最长的段被称为<span style="background:#fff88f">瓶颈段</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2017.53.21.png"></li>
<li>画个图更清楚</li>
<li>解决瓶颈段的方法<ul>
<li><span style="background:#fff88f">细分瓶颈段</span>，分给多个操作部件，断成阶梯式</li>
<li><span style="background:#fff88f">重复</span><span style="background:#fff88f">设置瓶颈段</span><ul>
<li>需要数据分配器、逻辑比较复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-2-加速比"><a href="#3-2-2-加速比" class="headerlink" title="3.2.2 加速比"></a>3.2.2 <font color="#d83931">加速比</font></h4><ul>
<li>完成同样一批任务、<span style="background:#fff88f">不用流水线所消耗的时间与使用流水线消耗的时间之比为加速比</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2018.40.42.png"></li>
<li>流水线对策加速比<ul>
<li>各段时间相等：n越大得到的加速比也就越大<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2018.42.38.png"></li>
<li>各段时间不等：求法与前面类似<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2018.43.49.png"></li>
</ul>
</li>
</ul>
<h4 id="3-2-3-效率"><a href="#3-2-3-效率" class="headerlink" title="3.2.3 效率"></a>3<font color="#d83931">.</font>2.3 <font color="#d83931">效率</font></h4><ul>
<li>效率指流水线中的设备实际使用时间与整个运行时间的比值，即流水线的利用率<ul>
<li>各段时间相等：各段效率相同<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2018.46.26.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2018.47.16.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2018.48.25.png"></li>
<li>各段时间不等<ul>
<li>画图求面积比值即可<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2019.03.11.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-4-流水线性能分析举例"><a href="#3-2-4-流水线性能分析举例" class="headerlink" title="3.2.4 流水线性能分析举例"></a>3.2.4 流水线性能分析举例</h4><ul>
<li>流水线分析的时候需要注意的点<ul>
<li>如果计算的结果有&#x3D;&#x3D;先后关系&#x3D;&#x3D;，那么只有在先运算的结果得出之后才能进行之后的运算（比如a+b算完了才能开始算(a+b)* c)</li>
<li>注意区分&#x3D;&#x3D;静态和动态&#x3D;&#x3D;，只有动态才可以把不把同的任务重叠在一起</li>
</ul>
</li>
<li>分析顺序<ul>
<li>确定运算的顺序</li>
<li>画出完成的时空图</li>
<li>计算对应的性能指标</li>
</ul>
</li>
</ul>
<h4 id="3-2-5-流水线设计中的若干问题"><a href="#3-2-5-流水线设计中的若干问题" class="headerlink" title="3.2.5 流水线设计中的若干问题"></a>3.2.5 流水线设计中的若干问题</h4><ul>
<li>瓶颈问题<ul>
<li>计算机的时钟周期取决于瓶颈段的延迟时间</li>
<li>需要尽可能的让流水线的各个时间段相等</li>
</ul>
</li>
<li>流水线的额外开销<ul>
<li>指流水寄存器延迟和时钟偏移开销<ul>
<li>寄存器需要建立时间和传输延迟<ul>
<li>建立时间指触发写操作的时钟信号到达之前寄存器输入必须保证稳定的时间</li>
<li>传输延迟是指时钟信号到达后寄存器输出可用的时间</li>
</ul>
</li>
<li>时钟偏移开销是指流水线中时钟到达各流水寄存器的最大差值时间</li>
</ul>
</li>
<li>需要使用高性能的锁存器作为流水寄存器</li>
</ul>
</li>
<li>冲突问题<ul>
<li>如果流水线中的指令之间存在关联，则他们可能要互相等待、引起流水线的停顿，那么如何处理好冲突问题，是流水线设计中要解决的重要问题之一</li>
</ul>
</li>
</ul>
<h3 id="3-3-流水线的相关与冲突"><a href="#3-3-流水线的相关与冲突" class="headerlink" title="3.3 流水线的相关与冲突"></a>3.3 流水线的相关与冲突</h3><h4 id="3-3-1-一个经典的5段流水线"><a href="#3-3-1-一个经典的5段流水线" class="headerlink" title="3.3.1 一个经典的5段流水线"></a>3.3.1 一个经典的5段流水线</h4><ul>
<li><font color="#d83931">一条指令的执行过程分为以下5个周期</font><ul>
<li>取指令周期——<span style="background:#fff88f">IF</span><ul>
<li>根据PC指示的地址从存储器中取出指令并放入指令寄存器IR，同时PC+4（一个指令4B的话），指向顺序的下一条指令</li>
</ul>
</li>
<li>指令译码&#x2F;读寄存器周期——<span style="background:#fff88f">ID</span><ul>
<li>对于<span style="background:#fff88f">指令进行译码</span>，并通过IR中的寄存器编号去访问<span style="background:#fff88f">通用寄存器组</span>、读出需要的操作数</li>
</ul>
</li>
<li>执行&#x2F;有效地址计算周期——<span style="background:#fff88f">EX</span><ul>
<li>ALU对在上一个周期准备好的操作数进行运算或处理，不同指令所进行的错做不同<ul>
<li>存储器访问指令：ALU把指定寄存器的内容和偏移量相加形成访存的有效地址</li>
<li>寄存器-寄存器ALU指令：ALU按照操作码指定的操作对于通用寄存器组中读取的数据进行运算</li>
<li>寄存器-立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的第一操作数和立即数进行运算</li>
<li>分支指令：<span style="background:#fff88f">ALU把偏移量和PC相加形成转移目标的地址</span>，同时判断前一个周期读出的操作数，确定分支条件是否成立</li>
</ul>
</li>
</ul>
</li>
<li>存储器访问&#x2F;分支完成周期<span style="background:#fff88f">MEM</span><ul>
<li>load&amp;store指令：<ul>
<li>load用上一个周期计算出的有效地址从存储器中读取相应数据</li>
<li>store把指定的数据写入这个有效地址所制定的存储器单元</li>
</ul>
</li>
<li>分支指令：<span style="background:#fff88f">如果前一个周期判定分支成功，则把转移地址送入PC</span></li>
</ul>
</li>
<li>写回周期<span style="background:#fff88f">WB</span><ul>
<li>ALU运算&#x2F;load在这个周期把结果数据写入通用寄存器组</li>
</ul>
</li>
</ul>
</li>
<li><span style="background:#fff88f">分支指令需要4个周期、store指令需要4个周期、其他指令需要5个周期</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2019.53.13.png"></li>
<li>多种时空图的画法<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2019.54.26.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-02%2019.54.40.png"></li>
<li>注意：<ul>
<li><span style="background:#fff88f">IF段和MEM</span>段都会访存有冲突的可能——指令cache</li>
<li><span style="background:#fff88f">ID段需要读通用寄存器，WB段需要对写通用寄存器——写操作前半拍、读操作后半拍</span></li>
</ul>
</li>
</ul>
<h4 id="3-3-2-相关与流水线冲突"><a href="#3-3-2-相关与流水线冲突" class="headerlink" title="3.3.2 相关与流水线冲突"></a>3.3.2 <font color="#d83931">相关与流水线冲突</font></h4><ul>
<li>相关<ul>
<li>相关指两条指令之间存在某种依赖关系，存在相关的两条指令可能不能在流水线中重叠执行或者只能部分重叠</li>
<li>相关的分类：数据相关、名相关、控制相关<ul>
<li><font color="#d83931">数据相关</font><ul>
<li>对于两条指令i、j，如果<ul>
<li>j使用i产生的结果</li>
<li>j与k数据相关、且k与i数据相关</li>
</ul>
</li>
<li>数据相关具有<span style="background:#fff88f">传递性</span></li>
<li>数据相关反映了数据的<span style="background:#fff88f">流动关系</span>，即如何从其生产者流动到其消费者</li>
</ul>
</li>
<li><font color="#d83931">名相关</font><ul>
<li>两条指令<span style="background:#fff88f">使用相同的名但是之间没有数据流动</span>——名相关</li>
<li><font color="#d83931">反相关</font>：i读完j后写（<span style="background:#fff88f">读后写</span>）</li>
<li><font color="#d83931">输出相关</font>：i写完j后写（<span style="background:#fff88f">写后写</span>）</li>
<li>如果把其中一条指令使用的名换成别的<span style="background:#fff88f">并不影响另外一条指令的正确执行</span><ul>
<li>可以通过改变指令中操作数的名来消除名相关——换名技术</li>
</ul>
</li>
<li>换名例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2016.38.06.png"></li>
</ul>
</li>
<li><font color="#d83931">控制相关</font><ul>
<li><span style="background:#fff88f">分支指令引起的相关</span>，需要根据分支指令的执行结果来确定后续指令是否执行<ul>
<li>如if p then q 则q和p控制相关</li>
</ul>
</li>
<li>两个限制<ul>
<li>与分支指令控制相关的指令不能移动到分支之前（<span style="background:#fff88f">该受控保证受控制</span>）</li>
<li>如果一个指令与分支指令不存在控制相关就不能把该指令移动到分支之后（<span style="background:#fff88f">不受控保证不控制</span>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">流水线冲突</font><ul>
<li>分类：<span style="background:#fff88f">结构冲突</span>、<span style="background:#fff88f">数据冲突</span>、<span style="background:#fff88f">控制冲突</span><ul>
<li><font color="#d83931">结构冲突</font><ul>
<li>定义：某种指令组合因为<span style="background:#fff88f">资源冲突</span>（资源不足）而不能正常执行——结构冲突</li>
<li>解决：在两条指令需要访问同一个资源的时候推迟其中一个指令一个周期<ul>
<li><font color="#ff0000">称为“流水线气泡”或“气泡</font></li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">数据冲突</font><ul>
<li>定义：相关的指令考的足够近的时候，流水线的重叠执行&#x2F;重新排序<span style="background:#fff88f">会改变指令读写操作数的顺序</span>，产生数据冲突</li>
<li>可能发生的数据冲突<ul>
<li><font color="#d83931">写后读冲突RAW</font>：前面的指令还没写后面就读了</li>
<li><font color="#d83931">写后写冲突WAW</font>：前面的指令还没写完后面就写了（<ul>
<li>五段流水线<span style="background:#fff88f">只有WB段写寄存器，不会有该类冲突</span>）</li>
</ul>
</li>
<li><font color="#d83931">读后写冲突WAR</font>：前面的指令还没读完后面就写了<ul>
<li>五段流水线中前面的读&lt;前面的写&lt;后面的写，所以也<span style="background:#fff88f">不会有该类冲突</span></li>
</ul>
</li>
</ul>
</li>
<li>&#x3D;&#x3D;对于寄存器堆的操作，采用前半周期写入，后半周期读出&#x3D;&#x3D;</li>
<li>通过<font color="#d83931">定向技术</font>减少数据冲突引起的停顿<ul>
<li>在某条指令产生计算结果之前，其他指令并不真正需要计算结果，如果能将计算结果产生的地方直接送到其他指令需要他的地方就可以避免停顿<ul>
<li><font color="#245bdb">正常需要乖乖存到寄存器里，然后后人再去寄存器里拿，现在改成上一个指令刚算完还没存呢直接塞给下一个指令的计算入口</font></li>
</ul>
</li>
<li>如果定向硬件检测到前一个ALU运算结果写入的寄存器就是ALU操作的源寄存器时，控制逻辑就选择定向的数据作为ALU的输入<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2017.38.30.png"></li>
</ul>
</li>
<li>需要停顿的数据冲突<ul>
<li>不是所有数据冲突都可以定向来解决（下一个算的时间远早于上一个求出来的时间）</li>
<li>流水线互锁机制：检测发现数据冲突，并使流水线停顿直到冲突消失<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2017.42.22.png"></li>
<li>本质：定向的箭头永远只能从左到右画，如果画不了就用气泡等到能画为止</li>
</ul>
</li>
<li>依靠<span style="background:#fff88f">编译器</span>解决数据冲突<ul>
<li>对于无法用定向技术解决的数据冲突，通过编译时让编译器重新组织指令顺序来消除冲突，称为“指令调度”&#x2F;“流水线调度”</li>
<li>通过调整加大某些指令的距离，可以增加定向技术的使用成功率</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">控制冲突</font><ul>
<li>分支如果成功需要把PC值改变为分支转移的目标地址，分支失败PC值要保持正常递增，指向顺序的下一条指令</li>
<li>冻结&#x2F;排空法<ul>
<li>最简单的处理方法，只要遇到分支指令就暂停之后的指令直到分支指令算出分支结果</li>
<li>会有三个时钟周期的延迟——<span style="background:#fff88f">分支延迟</span></li>
<li>实现简单<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2018.31.31.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2018.31.57.png"></li>
<li>问题：分支指令出现的频率接近30%，如果每个分支指令都带来3个周期的延迟会连带来很大的性能损失</li>
<li>改进方法：<ul>
<li>尽早判断分支是否成功</li>
<li>尽早算出分支目标地址</li>
</ul>
</li>
</ul>
</li>
<li>（以下的实现方法中，ID段可以直接完成分支判断和目标地址计算）</li>
<li><font color="#d83931">预测分支失败法</font><ul>
<li>在译码段ID检测到分支指令的时候优先默认按照分支失败（继续顺序执行）来向流水线填入指令<ul>
<li>如果确定分支失败，那么预测准确，流水线正常流动</li>
<li>如果确定分支成功，那么预测偏差，分支之后填入的指令转换为空操作然后跳转到目标地址重新取指令执行<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2018.37.27.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2018.37.37.png"></li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">预测分支成功法</font><ul>
<li>当流水线ID段检测到分支指令后，一旦计算出了分支的目标地址（不管分支结果）就直接开始从目标地址取指令执行</li>
<li>五段流水线中这种方法没有作用，分支结果会和目标地址同一时间算出来</li>
</ul>
</li>
<li><font color="#d83931">延迟分支</font><ul>
<li>在分支指令后面加上几条指令，无论分支是否成功都按照顺序执行这些指令（把分支指令绑定一些其他指令成一个指令块，保证指令块后的下一条指令一定时分支结果已经计算了出来）</li>
<li>分支后面的则m条指令的位置被称为<font color="#d83931">延迟槽</font></li>
<li>延迟分支实际上使用延迟槽中的指令来掩盖分支延迟，只要分支延迟槽中的指令是有用的，那么流水线中就没有停顿</li>
<li>该如何选择有用的指令调度到延迟槽？<ul>
<li><span style="background:#fff88f">从前调</span><span style="background:#fff88f">度</span><ul>
<li>把位于分支指令之前的一条独立指令移动到延迟槽（不能把分支指令前需要的相关指令移动到延迟槽）</li>
</ul>
</li>
<li><span style="background:#fff88f">从目标处调度</span><ul>
<li>把要跳转到的指令复制一份到延迟槽（类似于直接预测分支成功，提前把成功的第一句给算了）</li>
</ul>
</li>
<li><span style="background:#fff88f">从失败处调度</span><ul>
<li>把失败要执行的第一句指令移动到延迟槽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分支取消<ul>
<li>分支指令隐含了预测的分支执行方向</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-流水线的实现"><a href="#3-4-流水线的实现" class="headerlink" title="3.4 流水线的实现"></a>3.4 <font color="#d83931">流水线的实现</font></h3><h4 id="3-4-1-MIPS的一种简单实现"><a href="#3-4-1-MIPS的一种简单实现" class="headerlink" title="3.4.1 MIPS的一种简单实现"></a>3.4.1 MIPS的一种简单实现</h4><p><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2018.58.47.png"></p>
<ul>
<li>各个寄存器<ul>
<li>NPC：存放下一条指令的地址</li>
<li>IR：指令寄存器、存储当前正在处理的指令</li>
<li>A：第一操作数寄存器，存放从通用寄存器读出来的操作数</li>
<li>B：第二操作数寄存器，功能与A类似</li>
<li>Imm：存放符号扩展后的立即数操作数</li>
<li>cond：存放条件判定的结果，为“真”表示分支成功</li>
<li>ALUo：存放ALU的运算结果</li>
<li>LMD：存放load从存储器读出的数据</li>
</ul>
</li>
<li>执行一条指令的具体操作<ul>
<li>取指令周期IF<ul>
<li>根据PC取出指令并放入指令寄存器IR、同时PC+4指向下一条指令<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2019.39.36.png" alt="|400"></li>
</ul>
</li>
<li>译码周期ID<ul>
<li>把读出的操作数存入寄存器、IR的低16位进行位拓展之后存入Imm<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2019.40.16.png" alt="|450"></li>
</ul>
</li>
<li>执行&#x2F;有效地址计算周期EX<ul>
<li>存储器访问指令：ALU把操作数相加形成有效地址并存入临时寄存器![[截屏2024-06-03 19.43.29.png|375]]</li>
<li>寄存器-寄存器ALU指令：根据func字段进行运算并将结果存入临时寄存器<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2019.44.43.png" alt="|375"></li>
<li>寄存器-立即值指令：根据op进行运算并将结果存入临时寄存器，立即数在上一周期已经符号位拓展<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2019.46.00.png" alt="|400"></li>
<li>分支指令：ALU先将NPC和Imm×4的值相加得到转移目标的地址，同时对于之前存入寄存器A做判断决定分支是否成功，判断的结果存入寄存器<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2019.48.36.png" alt="|475"></li>
</ul>
</li>
<li>存储器访问MEM<ul>
<li>所有指令都在改周期对PC进行更新，非分支指令都是做PC←NPC</li>
<li>存储器访问指令：要么从存储取值存入寄存器，要么从寄存器取值存入存储<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2019.51.16.png"></li>
<li>分支指令：如果cond为真转移成功，否则失败<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2019.51.31.png"></li>
</ul>
</li>
<li>写回周期WB<ul>
<li>寄存器-寄存器ALU指令：Regs[rd]←ALUo</li>
<li>寄存器-立即数ALU指令：Regs[rt]←ALUo</li>
<li>load指令：Regs[rt]←LMD</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-2-基本的MIPS流水线"><a href="#3-4-2-基本的MIPS流水线" class="headerlink" title="3.4.2 基本的MIPS流水线"></a>3.4.2 基本的MIPS流水线</h4><p><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2020.33.09.png"></p>
<ul>
<li>设置了流水寄存器<ul>
<li>段与段之间设置，名称由左右两段名称拼接而成（如ID&#x2F;EX）</li>
<li>作用：<ul>
<li>把各段工作隔开，使它们不会互相干扰</li>
<li>保存相应段的处理结果</li>
<li>向后传递后面将要用到的数据或控制信息</li>
</ul>
</li>
<li>如果把PC看成IF段的流水寄存器，那么每一段都有一个流水寄存器，位于流水段的前面，提供指令在该段执行所需要的所有数据和控制信息</li>
</ul>
</li>
<li>增加了向后传递IR和从MEM&#x2F;WB.IR回送到通用寄存器组的链接</li>
<li>将PC的修改挪到了IF段，以便PC能及时+4，为下一条指令做好准备<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2020.38.22.png" alt="|675"></li>
<li>控制流水线工作——控制4个多路器<ul>
<li>MUX2：ID&#x2F;EX.IR中是分支走NPC，否则走A</li>
<li>MUX3：ID&#x2F;EX.IR中是RR型ALU走B，否则走Imm</li>
<li>MUX1：EX&#x2F;MEM.IR是分支且cond为真走ALUo，否则走PC+4</li>
<li>MUX4：MEM&#x2F;WB.IR是load走LMD，否则走ALUo</li>
</ul>
</li>
<li>解决冲突<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2020.44.42.png"><ul>
<li>所有的数据冲突可以在ID段检测到，如果存在数据冲突就在流出ID段之前暂停，完成流水线互锁，如果采用定向技术，也会在ID段确认需要什么样的定向，设置相应的控制</li>
<li>因为load引起的互锁称为load互锁</li>
<li>硬件如果遇到上述RAW冲突，流水线互锁就会在流水线中插入停顿（操作码改为全0，然后重新吧IF&#x2F;ID送回入口）</li>
<li>定向通过比较流水寄存器中的寄存器地址来确定</li>
</ul>
</li>
</ul>
<h3 id="3-5-向量处理机"><a href="#3-5-向量处理机" class="headerlink" title="3.5 向量处理机"></a>3.5 向量处理机</h3><ul>
<li>流水线非常适合进行大批量重复且互相没有关联的计算，比如向量的计算，<span style="background:#fff88f">有的流水线处理机就设置了向量数据表示和对应的向量指令，被称为向量处理机</span></li>
</ul>
<h4 id="3-5-1-向量处理方式"><a href="#3-5-1-向量处理方式" class="headerlink" title="3.5.1 向量处理方式"></a>3.5.1<font color="#d83931"> </font><font color="#d83931">向量处理方式</font></h4><ul>
<li>三种：横向处理方式、纵向处理方式、纵横处理方式</li>
<li>例子：D&#x3D;Ax(B+C)，ABCD均是长度为N的向量</li>
<li><span style="background:#fff88f">横向处理方</span><span style="background:#fff88f">式</span><ul>
<li>向量计算按照行的方式从左到右进行，逐个求结果的一位（从d ₁求到d ₙ）<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2020.55.56.png"></li>
<li><span style="background:#fff88f">会发生N次数据相关和2N次功能切换</span><ul>
<li>kᵢ←bᵢ+cᵢ</li>
<li>dᵢ←kᵢ×aᵢ</li>
</ul>
</li>
</ul>
</li>
<li>纵向处理方式<ul>
<li>向量从上向下计算（一行一行算）</li>
<li>先把一个中间值的每一位都算完，再算下一个中间值</li>
<li>每条指令内部都是单一的晕眩</li>
<li>只会<span style="background:#fff88f">发生1次数据相关和1次功能切换</span></li>
</ul>
</li>
<li>适用于向量处理机<ul>
<li>需要存储器不断提供源操作数数据流，不断从运算部件接受结果，需要对于通信带宽有很高的要求</li>
</ul>
</li>
<li>纵横处理方式<ul>
<li>上述两种方式的结合，把向量分成若干组，组内纵向方式处理，依次处理各组</li>
<li>设N&#x3D;S* n+r<ul>
<li>N为向量长度、S为组数、n为每组长度、r为余数</li>
<li>共n+1组</li>
</ul>
</li>
<li>运算过程<ul>
<li>先算第一组（第一宽列）、然后第二组以此类推——类横向</li>
<li>每一宽列中是一行一行算——纵向</li>
</ul>
</li>
<li>每n个元素为一组进行分组处理，可以设置能快速访问的向量寄存器，用于存放源向量、目的向量以及中间结果，让运算部件的输入输出段都与向量寄存器相连，构成寄存器-寄存器型操作的运算流水线<ul>
<li>其实就是纵横&#x3D;纵向+流水线</li>
</ul>
</li>
<li><span style="background:#fff88f">1次数据交换和2次功能切换</span></li>
</ul>
</li>
<li>数据相关次数、功能切换次数</li>
</ul>
<h4 id="3-5-2-向量处理机的结构"><a href="#3-5-2-向量处理机的结构" class="headerlink" title="3.5.2 向量处理机的结构"></a>3.5.2 向量处理机的结构</h4><p><font color="#d83931">存储器-存储器结构</font><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-13%2022.01.29.png"></p>
<ul>
<li>适合<span style="background:#fff88f">纵向处理方式</span>。</li>
<li>操作数缓冲栈和写结果缓冲栈主要用于解决访问存储器冲突</li>
<li>源向量和目的向量都存放在存储器中，运算的中间结果需要送回存储器。</li>
<li>对应的向量分量能并发访问，计算结果能并行地保存</li>
<li>普通存储器的 3 倍带宽：3 条独立数据通路，一个时钟周期读出两个操作数并写回一个结果<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-13%2022.01.50.png"><br><font color="#d83931">寄存器-寄存器结构</font></li>
<li>要求：设置能快速访问的向量寄存器，用于存放源向量、目的向量及中间结果，让运算部件的输入、输出端都与向量寄存器相联，构成寄存器－寄存器型操作的运算流水线<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-13%2022.03.06.png"><ul>
<li>若干级<span style="background:#fff88f">中间存储器</span>形成有层次结构的存储系统，相当于寄存器。</li>
<li>访问中间存储器速度<span style="background:#fff88f">更快</span></li>
<li>通过中间存储器形成新的数据结构，高效</li>
<li>中间存储器高带宽、多种寻址方式、支持流水线链接技术</li>
</ul>
</li>
<li>功能部件<ul>
<li>12条并行工作的单功能流水线，可分别进行地址、向量、标量运算</li>
<li>为向量运算提供了6个单功能流水部件<ul>
<li>整数加（3拍）</li>
<li>逻辑运算（2）</li>
<li>移位（4）</li>
<li>浮点加（6）</li>
<li>浮点乘（7）</li>
<li>浮点迭代求倒数（14）</li>
</ul>
</li>
<li>一拍一个时钟周期（12.5ns）</li>
</ul>
</li>
<li>向量寄存器组V<ul>
<li>512个64位寄存器组成，分为8块V ₀～V7<ul>
<li>每一块称为一个向量寄存器，可以存放一个长度不超过64的向量<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2021.14.53.png"></li>
</ul>
</li>
<li>每个向量寄存器每拍可以提供一个数据元素或者接受一个结果元素</li>
</ul>
</li>
<li>标量寄存器S和快速暂存器T<ul>
<li>标量寄存器8个</li>
<li>快速暂存器T负责标量寄存器和主存储器之间的缓冲</li>
</ul>
</li>
<li>向量屏蔽寄存器VM<ul>
<li>64位，每一位对应向量寄存器的一个单元（一横条）</li>
<li>用于向量的贵宾归并、压缩、单独运算等</li>
<li>每个向量寄存器都有和6个功能部件的单独互通总线</li>
</ul>
</li>
<li>V ᵢ冲突<ul>
<li>并行工作的各指令使用了相同的Vᵢ</li>
<li>向量长度可能不同，无法同时提供两个Vᵢ，必须第一个释放了才能执行第二个</li>
</ul>
</li>
<li>功能部件冲突<ul>
<li>两个指令都使用同一个功能部件</li>
<li>必须第一个指令执行完毕第二个指令才能执行<br><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2021.24.46.png" alt="|575"></li>
</ul>
</li>
</ul>
<h4 id="3-5-3-提高向量处理机性能的方法"><a href="#3-5-3-提高向量处理机性能的方法" class="headerlink" title="3.5.3 提高向量处理机性能的方法"></a>3.5.3 提高向量处理机性能的方法</h4><ul>
<li><font color="#d83931">设置多个功能部件</font><ul>
<li>向量部件：向量加、移位、逻辑运算</li>
<li>浮点部件：浮点加、浮点乘、浮点求倒数</li>
<li>标量部件：标量加、移位、逻辑运算、数“1”&#x2F;计数</li>
<li>地址运算部件：整数加、整数乘</li>
</ul>
</li>
<li><font color="#d83931">链接技术</font>（<font color="#d83931">相关性、同周期、同时</font>）<ul>
<li>具有&#x3D;&#x3D;写后读的两条指令&#x3D;&#x3D;在不出现冲突的情况下，把功能部件链接在一起进行流水处理</li>
<li>可以理解为流水线的&#x3D;&#x3D;定向技术&#x3D;&#x3D;在向量处理机中的运用</li>
<li>前面功能部件的结果一产生就可以被后面的功能部件所使用，不用等待结果向量全部生成后再使用</li>
<li>链接条件![[截屏2024-06-13 22.15.21.png]]<ul>
<li>空间：无向量<span style="background:#fff88f">寄存器</span>、<span style="background:#fff88f">功能部件</span>冲突</li>
<li>时间：<ul>
<li>上一指令的第一个结果分量送入结果向量寄存器的时钟周期</li>
<li>如果后一指令的源操作数分别是前两指令的结果寄存器，那么前两指令产生结果时间必须相等，长度也必须相等</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">链接运算时间</font><ul>
<li>记住访存6拍、浮点加6拍、浮点乘7拍</li>
<li>寄存器进运算功能部件、功能部件进寄存器、存储进访存、访存进寄存器，一般都是一拍（题目会给）</li>
<li>一般一条指令的时间为1+6&#x2F;7+1+N-1<ul>
<li>放进去+做+拿出来+流水线的后N-1拍</li>
</ul>
</li>
<li>画图![[截屏2024-06-13 22.26.58.png|475]]</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">分段开采技术</font><ul>
<li>当向量长度大于向量寄存器长度时，需要把长向量分成长度固定的段然后分段处理，每次循环之处理一个向量段称为分段开采技术</li>
<li>由软硬件控制完成，对程序员透明</li>
<li>先循环算每一个64位，最后再算一个余数位</li>
</ul>
</li>
<li><font color="#d83931">循环开采技术</font></li>
<li><font color="#d83931">多处理机系统</font><ul>
<li>得加钱</li>
</ul>
</li>
</ul>
<h4 id="3-5-4-向量处理机的性能评价"><a href="#3-5-4-向量处理机的性能评价" class="headerlink" title="3.5.4 向量处理机的性能评价"></a>3.5.4 向量处理机的性能评价</h4><ul>
<li><font color="#d83931">编队</font><ul>
<li>在同一个时钟周期内可一起开始执行的几条向量指令</li>
<li>同一个编队中的指令不存在功能部件冲突和数据相关</li>
</ul>
</li>
<li><font color="#d83931">向量指令的处理时间T</font><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-13%2022.39.14.png"><ul>
<li>编队内并行执行，时间由最长的决定</li>
<li>流水线中，一个编队的执行时间就是填入时间最长的指令+流水n段</li>
<li>因为每个编队中的流水n段都相同（都是一拍出一个）所以合并成mn，每个编队最大填入拼在一起成中填入时间</li>
<li>例题<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2021.46.42.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2021.47.05.png"></li>
</ul>
</li>
<li><font color="#d83931">向量处理机的峰值性能</font>&#x3D;<span style="background:#fff88f">MFLOPS</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2021.41.14.png"></li>
<li><font color="#d83931">半性能向量长度</font><ul>
<li>指运行性能到达峰值一半所满足的最小向量长度<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2021.43.13.png" alt="|500"></li>
</ul>
</li>
<li><font color="#d83931">向量长度临界值</font><ul>
<li>向量方式的处理速度优于标量串行方式处理速度的最小向量长度（太短了就没意义了）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-03%2021.45.44.png"></li>
</ul>
</li>
</ul>
<h2 id="第四章-指令级并行（难点）"><a href="#第四章-指令级并行（难点）" class="headerlink" title="第四章 指令级并行（难点）"></a>第四章 指令级并行（难点）</h2><blockquote>
<p>17%<br>简答题<br>大题一道（动态调度）<br>ps：tomasulo+ROB，计分牌算法</p>
</blockquote>
<h3 id="4-1-指令级并行的概念"><a href="#4-1-指令级并行的概念" class="headerlink" title="4.1 指令级并行的概念"></a>4.1 指令级并行的概念</h3><ul>
<li>指令之间存在的潜在的并行性称为指令级并行ILP</li>
<li>流水线处理机的时机CPI等于理想流水线CPI加停顿![[截屏2024-06-05 14.23.52.png]]<ul>
<li>理想CPI四最高性能指标</li>
</ul>
</li>
<li>如果一连串连续的代码除了入口和出口之外没有其他分支指令和转入点，则称之为基本的“程序块” <ul>
<li>由于分支指令众多，所以块中能开发的并行性有限</li>
<li>想要明显的提升性能，必须跨越多个基本块开发ILP</li>
</ul>
</li>
<li>数据相关限制了所能开发的ILP，解决方法<ul>
<li>保持相关，但避免发生冲突（如指令调度）</li>
<li>通过代码变换消除相关</li>
</ul>
</li>
<li>由于相关的存在，必须保持程序顺序——由源程序确定的在完全串行的方式下指令的执行顺序<ul>
<li>后续各种软硬件技术的目标是尽可能开发并行性，只有在可能影响程序正确性的情况下才保持程序顺序</li>
<li>而控制相关的依赖关系如果不遵守并不会对程序的正确性产生影响，因此不需要严格保持</li>
</ul>
</li>
<li><font color="#d83931">对于正确的执行程序来说，必须保持的最关键的两个属性是数据流和异常行为</font><ul>
<li>保持异常行为指无论怎么改变指令的执行顺序都不能改变程序中异常的发生情况——指令执行顺序的改变不能导致程序中发生新的异常</li>
<li><span style="background:#fff88f">数据流是数据值从产生者指令到消费者指令的实际流动</span>，指令的数据可以有多个来源，因此仅仅保持<span style="background:#fff88f">数据的相关性</span>是不够的，一条指令可能数据相关于多条先前的指令，而程序顺序决定了哪条指令真正是所需数据的生产者<ul>
<li>只有加上保持<span style="background:#fff88f">控制顺序</span>才能保持程序顺序<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2015.13.03.png"></li>
</ul>
</li>
<li>数据相关：DADDU在OR前、DSUBU在OR前</li>
<li>控制相关：分支成功DADDU、分支失败DSUBU，DSUBU必须在控制之下</li>
<li><span style="background:#fff88f">有时不遵守控制相关不改变异常行为和数据流</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-07%2000.11.25.png" alt="|450"><ul>
<li>此时如果执意把DSUBU提到分支前的话<ul>
<li>分支成功，虽然多算了个R4，但R4没被使用，改了R4的值不影响后续结果</li>
<li>分支失败，都算了，先算后算无所谓</li>
</ul>
</li>
<li>只要不影响结果，就可以不遵守控制相关<ul>
<li>前瞻执行不仅能解决异常，还能在保持数据流的情况下减少控制相关对于ILP的影响</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-指令的动态调度"><a href="#4-2-指令的动态调度" class="headerlink" title="4.2 指令的动态调度"></a>4.2 指令的动态调度</h3><ul>
<li>静态调度流水线：当取出的指令与流水线中的流水中执行的指令不存在数据相关&#x2F;可通过定向机制隐藏相关，则流出该指令，若不能隐藏（必须等流水线结果），那么流水线会停顿<ul>
<li>静态调度流水线依靠编译器对代码静态调度以减少相关和冲突，静态是因为是在编译期间进行调度和优化，不是执行过程中</li>
<li>静态调度通过拉开距离来减少可能产生的停顿</li>
</ul>
</li>
<li>动态调度流水线：在程序执行的过程中依靠硬件对指令执行顺序进行重新安排，减少数据相关导致的停顿<ul>
<li>能够处理一些编译时情况不明的相关（如存储器访问相关）</li>
<li>简化编译器工作</li>
<li>能够让本来是面向某一流水线优化编译的代码在其他流水线上也能高效的执行（每个流水线自己动态调度）</li>
</ul>
</li>
</ul>
<h4 id="4-2-1-动态调度的基本思想"><a href="#4-2-1-动态调度的基本思想" class="headerlink" title="4.2.1 动态调度的基本思想"></a>4.2.1 动态调度的基本思想</h4><ul>
<li>简单流水线中，指令顺序流入流出，如果一条指令在流水线中停顿，则后面所有的指令都停止前进，如果相近的指令存在相关就很可能会导致冲突、引起停顿，如果系统中有多个功能部件就会因为没有指令而处于空闲状态</li>
<li>举例<br>![[截屏2024-06-05 15.42.15.png|275]]</li>
<li>SUB和DIV关于F4相关，但是流水线的停顿阻碍了本可以照常运行的ADD，这就是按序流入流出的局限性<ul>
<li>简单流水线中，结构冲突和数据冲突在ID段进行检测，当检测没有冲突的时候才会流出</li>
<li>改进方法：检测结构冲突、等待数据冲突消失<ul>
<li>只要检测到没有结构冲突就可以让指令流出（只要资源够用就先走，让下个人进来别挡道）</li>
<li>流出后的指令等待数据冲突消失，即一旦操作数就绪就可以立即执行</li>
<li>例子中的SUB会先流出ID段然后等待数据冲突，ADD就能进入ID段然后畅通无阻的抢先执行完毕</li>
</ul>
</li>
<li>修改后的流水线会乱序执行<ul>
<li>指令的执行顺序和程序顺序不相同</li>
<li>完成顺序也和程序顺序不相同</li>
</ul>
</li>
</ul>
</li>
<li>动态调度流水线改进：把译码段细分为两个段<ol>
<li>流出段：指令译码并检查是否存在结构冲突，不存在则指令流出</li>
<li>读操作数：等待数据冲突消失（如果有），然后读操作数</li>
</ol>
<ul>
<li><span style="background:#fff88f">WAR和WAW冲突</span><ul>
<li>新改进的流水线因为乱序可能会产生5段流水线不存在的新冲突<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2015.55.07.png" alt="|375"><ul>
<li>SUB和ADD会存在反相关（读后写WAR），如果流水线抢先完成了ADD，那么SUB读到的值就是错的</li>
<li>SUB和DIV会存在输出相关（写后写WAW），如果流水线抢先完成了SUB，DIV的结果就会覆盖掉SUB的结果</li>
</ul>
</li>
</ul>
</li>
<li>动态调度流水线<span style="background:#fff88f">支持多条指令同时处于执行当中</span><ul>
<li>要求具有多个功能部件</li>
</ul>
</li>
<li>异常处理<ul>
<li>指令乱序完成大大增加了异常处理的复杂度</li>
<li>一条异常只有在顺序执行时也会产生的异常才是真正的异常</li>
<li>保持了正常的异常行为仍然可能发生不精确异常<ul>
<li>指令i发生异常时，处理机的现场与严格按照程序顺序执行时i的现场不同</li>
<li>也就是说，不仅要求这个乱序异常要在顺序执行时也得发生，还要保证发生时的处理机现场和这个乱序异常的现场相同（1比1复刻），否则是一个不精确异常</li>
<li>产生原因：<ul>
<li>流水线执行完了指令i之后的指令</li>
<li>流水线还没执行指令i之前的指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">两种典型的动态调度算法</font>：<ul>
<li><font color="#d83931">计分牌算法和Tomasulo算法</font></li>
</ul>
</li>
<li>记分牌Scoreboard算法<ul>
<li>记分牌硬件维护了三张表<ul>
<li>记录指令的执行状态</li>
<li>功能部件状态</li>
<li>寄存器状态以及数据相关关系</li>
</ul>
</li>
<li>ID分为流出和读操作数</li>
<li>具有记分牌的MIPS处理器模型<ul>
<li>记分牌主要用于浮点部件</li>
<li>整数部件用来处理所有的存储器访问、分支处理和整数操作</li>
</ul>
</li>
<li>处理步骤![[截屏2024-06-14 09.59.24.png|500]]<ul>
<li>流出+读操作数+执行+写结果</li>
<li>流出<ul>
<li>如果当前流出指令所需的功能部件空闲<ul>
<li>排除结构相关</li>
</ul>
</li>
<li>所有其他正在执行的指令的目的寄存器不同<ul>
<li><span style="background:#fff88f">排除WAW冲突</span></li>
</ul>
</li>
<li>则记分牌向此功能部件流出该指令并修改记分牌内部记录表</li>
</ul>
</li>
<li>读操作数<ul>
<li>记分牌检测源操作数的可用性，一旦数据可用它就通知功能部件从寄存器读出源操作数并开始执行（<span style="background:#fff88f">动态解决RAW</span>），否则等待<ul>
<li>一写完立马读</li>
<li>数据可用：所有前面已流出且还在执行的指令都不对该寄存器进行写操作，该寄存器的数据是可用的</li>
</ul>
</li>
</ul>
</li>
<li>执行<ul>
<li>取到操作数后，功能部件开始执行，产生结果之后通知记分牌执行完成</li>
</ul>
</li>
<li>写结果<ul>
<li>记分牌一旦知道执行部件完成执行就会检测是否存在WAR冲突<ul>
<li>如果不存在WAR冲突或者WAR冲突已消失，则记分牌通知功能部件把结果写入目的寄存器并释放所有资源</li>
<li>如果检测到<span style="background:#fff88f">WAR冲突</span>就不允许该指令将结果写到目的寄存器<ul>
<li>说明前面还有某个指令（顺序流出）还没有读取目的寄存器的操作数，如果现在写会让它读错误数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>记分牌结构<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-14%2010.13.06.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-14%2010.26.50.png" alt="|500"></li>
<li>例子<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-14%2010.42.52.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-14%2010.43.01.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-14%2010.43.10.png"></li>
<li>特点<ul>
<li>可以实现顺序流出</li>
<li>WAW通过指令不流出解决</li>
<li>RAW通过指令不读操作数解决</li>
<li>WAR通过指令不写结果解决</li>
<li>无前瞻机制</li>
</ul>
</li>
<li>受限于<ul>
<li>代码中开发的并行性</li>
<li>记分牌的容量</li>
<li>功能部件的数目</li>
<li>名相关引发的冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-Tomasulo算法"><a href="#4-2-2-Tomasulo算法" class="headerlink" title="4.2.2 Tomasulo算法"></a>4.2.2 Tomasulo算法</h4><ul>
<li>基本思想<ul>
<li>记录和检测指令相关，操作数一旦就绪立即执行，把RAW冲突的可能性减少到最小（尽最快努力执行然后抢在Read之前赶紧Write）</li>
<li>通过寄存器换名来消除WAR和WAW冲突（让后面的Write去写另一个寄存器）</li>
<li>举例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2016.29.59.png"><ul>
<li>ADD和MUL对F6有输出相关WAW冲突，ADD和SUB对F8有反相关WAR冲突<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2016.31.21.png"></li>
<li>修改之后ADD写到S中，MUL还是写到F6，所以即使MUL抢先结束，最后留在F6中的仍然是MUL的结果</li>
<li>修改之后SUB写到T中，ADD取的还是F8，所以即使SUB抢先结束，也不会写进F8，ADD取得还是原始的F8值</li>
</ul>
</li>
</ul>
</li>
<li>基于Tomasulo算法的MIPS处理器浮点部件的基本结构<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2016.34.31.png"><ul>
<li>这里省略了整数运算器以及整数寄存器，他们会负责地址部分的计算</li>
<li>保留站<ul>
<li>保留站设置在运算部件的入口，浮点加法器入口有3个加法保留站Add1&#x2F;2&#x2F;3，浮点乘法器入口有两个乘法保留站Mult1&#x2F;2，每个保留站由唯一字段标识</li>
<li>每个保留站中保存一条已经流出并等待到本功能部件执行的指令，内容包括操作码、操作数、检测解决冲突信息</li>
<li>一条指令流出道保留站中后，如果源操作数已经就绪则从寄存器取到保留站中，如果还没算出来则保留站中将记录产生该操作数的保留站的标识</li>
</ul>
</li>
<li>公共数据总线CDB<ul>
<li>所有功能部件的计算结果都是送到CDB上，由它把这些结果直接播送到各个需要该结果的地方（包括存储器读出的数据）</li>
<li>CDB会连接除了load缓冲器以外所有的部件</li>
<li>浮点寄存器通过一对中线连接到功能部件（中间通过保留站），并通过CDB连接到store缓冲器的入口</li>
</ul>
</li>
<li>load缓冲器和store缓冲器<ul>
<li>分别存放读&#x2F;写存储器的数据或地址，功能类似于保留站（暂存即将load&#x2F;store的指令）</li>
<li>load&#x2F;store缓冲器的具体功能<ul>
<li>存放用于计算有效地址的分量</li>
<li>记录正在进行的load&#x2F;store访存，等待存储器响应取回&#x2F;数据到达</li>
<li>保存已经完成了的load的结果（存储器响应取来的数据）等待CDB传输&#x2F;保存本次store的地址和数据知道存储部件接受</li>
</ul>
</li>
</ul>
</li>
<li>浮点寄存器FP<ul>
<li>共有16个浮点寄存器F0、F2…F30</li>
</ul>
</li>
<li>指令队列<ul>
<li>指令部件送来的指令放入指令队列，指令队列中的指令按照先进先出的顺序流出</li>
</ul>
</li>
<li>运算部件<ul>
<li>浮点加法器完成加减法</li>
<li>浮点乘法器完成乘除法</li>
</ul>
</li>
<li><span style="background:#fff88f">寄存器换名的实现</span><ul>
<li>通过保留站和流出逻辑共同完成</li>
<li>如果指令流出时其操作数还没有计算出，则将该指令中<span style="background:#fff88f">相应的寄存器换名为即将产生这个操作数的保留站的标识</span></li>
<li>这时，每个指令流出到保留站后操作数寄存器号都变成了数据本身或者即将产生数据的保留站（相当于前面的Read将只聚焦于该数据&#x2F;产生该数据的地方，而不是聚焦于存该数据的寄存器，因为寄存器有可能被别的指令抢先修改），<span style="background:#fff88f">与寄存器脱钩</span>，也就避免了WAR冲突</li>
</ul>
</li>
<li>Tomasulo算法的基本思想<ul>
<li>首先一个指令流出到保留站<ul>
<li>如果所需要的操作数就绪，<ul>
<li>从对应的寄存器中取出，与寄存器脱钩</li>
<li>把结果对应的寄存器打上本保留站的标识，标识该寄存器的结果由本保留站提供</li>
<li>当结果生成时，把结果放到总线上广播，通知所有人算完啦，所有在等待的地方都会取走数据</li>
</ul>
</li>
<li>如果所需要的操作数未就绪<ul>
<li>把对应操作数的提供者存入保留站，等待提供者的结果</li>
<li>把结果对应的寄存器打上本保留站的标识，标识该寄存器的结果由本保留站提供</li>
<li>一旦等待到想要的操作数，立即执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分布的保留站的特点<ul>
<li>冲突检测和指令执行控制是分布的，每个功能部件的保留站中的信息决定了什么时候指令可以在该功能部件下开始执行</li>
<li>计算结果通过CDB直接<span style="background:#fff88f">从产生的保留站传送到所有需要的部件</span>，而不是先生成到一个寄存器其他地方再从寄存器取（更快而且不怕被覆盖）</li>
</ul>
</li>
</ul>
</li>
<li>指令执行的步骤<ul>
<li>流出<ul>
<li>指令队列头去一条指令，如果要求的保留站（加&#x2F;乘）有空闲则放入（假设放入r保留站）<ul>
<li>如果没有空闲保留站就不会流出，这里就是结构冲突了，流出段只处理结构冲突</li>
</ul>
</li>
<li>如果操作数就绪则取操作数进r，如果没有接续就把提供操作数的保留站送进r<ul>
<li>这一步实际完成了<span style="background:#fff88f">寄存器换名</span>和操作数缓冲，<span style="background:#fff88f">解决WAR冲突</span></li>
</ul>
</li>
<li>然后把<span style="background:#fff88f">目的寄存器打上r的标识</span><ul>
<li>实际提前完成了写操作，因为指令是按序流入，因此如果是写同一个寄存器不管是否完成也会按照流入的顺序提前先打上标识，因此最后留下的标识一定是最后一条写指令，这样乱序完成也不会影响结果，<span style="background:#fff88f">解决WAW冲</span>突</li>
</ul>
</li>
</ul>
</li>
<li>执行<ul>
<li>如果某个操作数没计算出来，保留站会一直监视CDB看有没有新鲜出炉的结果</li>
<li>一旦结果<span style="background:#fff88f">产生就会保留站立即获取</span>，两个操作数就绪之后就会送入功能部件执行规定的操作<ul>
<li>这里本质还是通过<span style="background:#fff88f">推迟执行来解决RAW</span>，后面需要读该结果的指令会一直等待前面写指令完成之后送给保留站再继续执行</li>
<li>不过数据一产生就立马送给了需要的地方，已经比放进寄存器再取快很多了，把RAW引起的停顿减到了最小</li>
</ul>
</li>
<li>举例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2017.33.58.png" alt="|600"><ul>
<li>MUL会通过ab产生结果，送到CDB，然后F0在等MUL结果，取到后给寄存器，ADD也在等MUL结果，取到后给保留站，参数就绪，ADD立即执行</li>
</ul>
</li>
<li>保留站中kennel会有多条指令同时就绪的情况，多个功能部件可以并行执行，一个功能部件可以采用随机的方法选择要执行的指令</li>
<li>load和store在执行阶段需要的步骤<ul>
<li>计算有效地址（等基地址寄存器就绪，偏移量肯定本来就就绪）</li>
<li><font color="#ff0000">把有效地址放入load&#x2F;store缓冲器</font></li>
<li>load执行需要存储器部件就绪</li>
<li>store执行需要存的数据到达</li>
<li>顺序进行有效地址计算来保证程序顺序有助于避免访问存储器冲突</li>
</ul>
</li>
</ul>
</li>
<li>写结果<ul>
<li>功能部件计算完毕会把计算结果放到CDB上，所有需要的地方从CDB上获取数据，store指令在这一步完成对于存储器的写入，当地址和数据都备齐时送给存储器部件、store指令完成</li>
<li>保留站、寄存器组、load&#x2F;store缓冲器都包涵附加标识信息用于检测和消除冲突</li>
</ul>
</li>
<li>保留站详解<ul>
<li>保留站的功能相当于拓展的虚拟寄存器</li>
<li>有一下八个字段<ul>
<li>Op：对源操作数进行的操作</li>
<li>Qj，Qk：源操作数的保留站号，0为已就绪&#x2F;不需要操作数</li>
<li>Vj，Vk：实际操作数的值：Q为0时实际的操作数就存在对应的V中，否则说明还没就绪</li>
<li>Busy：说明本保留站&#x2F;缓冲单元是否在忙</li>
<li>A（l&#x2F;s专有）：开始保存立即数，计算后存放有效地址</li>
<li>Qi：寄存器状态表，记录每个寄存器负责提供的保留站站号，为0则不需要提供&#x2F;已就绪</li>
</ul>
</li>
</ul>
</li>
<li>示例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.10.49.png"></li>
<li>优点（相比计分牌）<ul>
<li>冲突检测逻辑分布，可以同时让所有等待的结果的地方收到结果后同时执行，寄存器组就需要等待写入寄存器然后依次取读出</li>
<li>消除WAW和WAR停顿（通过保留站）</li>
</ul>
</li>
</ul>
</li>
<li>具体算法<ul>
<li>各符号含义<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.19.14.png"></li>
</ul>
<ol>
<li>指令流出（准备阶段）<ol>
<li>浮点运算指令流出(空闲保留站设为r)<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.21.10.png"></li>
<li>load&#x2F;stroe指令流出<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.23.34.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.23.42.png"></li>
</ol>
</li>
<li>执行<ol>
<li>浮点操作指令执行<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.27.58.png"></li>
<li>load&#x2F;store指令执行<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.28.34.png"><ul>
<li>注：l和s是自己计算有效地址的加法</li>
</ul>
</li>
</ol>
</li>
<li>写结果<ol>
<li>浮点操作指令&#x2F;load指令写结果<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.32.12.png"></li>
<li>store指令写结果<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2018.33.16.png"></li>
</ol>
</li>
</ol>
</li>
<li>算法分析：<ul>
<li>该算法有限制，如果流水线中还有分支指令没有执行，则指令不能进入执行阶段，因为流出阶段后的顺序无法保证，容易违反控制相关</li>
<li>如果能准确预测分支该算法将获得很高的性能</li>
<li>缺点是很复杂、需要大量硬件、并且性能会受到CDB总线的限制</li>
</ul>
</li>
</ul>
<h3 id="4-3-动态分支预测技术"><a href="#4-3-动态分支预测技术" class="headerlink" title="4.3 动态分支预测技术"></a>4.3 动态分支预测技术</h3><ul>
<li>ILP越高，控制相关的制约就越大，分支预测就需要有更高额准确度，尤其是对于每个时钟周期流出多条指令（n条称作n流出）<ul>
<li>在n流出的处理机中，遇到分支指令的可能性提升了n倍，要给处理器连续的提供指令，就必须预测分支结果</li>
<li>Amdahl定律可知，计算机的CPI越小，控制停顿的相对影响就越大</li>
</ul>
</li>
<li>静态处理分支指令的方法：预测成功&#x2F;失败&#x2F;延迟分支</li>
<li>分支预测的有效性不仅取决于准确性，还与预测正确和不正确的开销有关系（如果正确不正确都开销很小，那预测的很不准也无所谓）</li>
<li>硬件动态处理分支的方法：<span style="background:#fff88f">在程序运行时根据分支指令过去的表现来预测将来的行为</span>，分支发生变化也会改变预测的结果<ul>
<li>目的：预测分支是否成功、尽快找到分支目标地址</li>
<li>问题：如何记录分支历史信息、如果根据信息预测分支的去向（甚至取到指令）</li>
<li>注意：如果预测错误需要作废已经预取和分析的指令然后恢复现场，再去另一条分支重新去指令，因此还需要提前保存现场<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2019.51.44.png"></li>
</ul>
</li>
</ul>
<h4 id="4-3-1-采用分支历史表BHT"><a href="#4-3-1-采用分支历史表BHT" class="headerlink" title="4.3.1 采用分支历史表BHT"></a>4.3.1 采用分支历史表<font color="#d83931">BHT</font></h4><ul>
<li>有时也称作分支预测缓冲器</li>
<li>通过BHT来记录分支指令最近一次&#x2F;几次的执行情况（成功与否），并据此进行预测<ul>
<li>通过采用两位二进制记录历史来提高准确度<ul>
<li>研究表明两位与n位预测的性能差不多，所以够了</li>
<li>状态转换图<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2019.54.38.png"><ul>
<li>其实就是0&amp;1&amp;2&amp;3，0&#x2F;1预测会失败，2&#x2F;3预测会成功</li>
<li>同结果之间预测对了+1，错了-1</li>
<li>改变结果是+2或-2</li>
</ul>
</li>
</ul>
</li>
<li>分支指令到达ID时，如果BHT预测成功，取分支目标地址后续指令（预测失败类似）<ul>
<li>如果预测结果正确，继续执行不必断流，BHT为2则+1，为3则不变</li>
<li>如果预测失败，作废预处理指令恢复现场，BHT为2则-2，为3则-1</li>
</ul>
</li>
<li>BHT只预测了分支，并没有对目标地址有帮助，因此只有“判断分支是否成功需要的时间大于确定分支目标地址所需要的时间”的情况下才有意义，且判断分支和求目标地址都在ID段，因此BHT对流水线没有帮助</li>
</ul>
</li>
</ul>
<h4 id="4-3-2-采用分支目标缓冲期BTB"><a href="#4-3-2-采用分支目标缓冲期BTB" class="headerlink" title="4.3.2 采用分支目标缓冲期BTB"></a>4.3.2 采用分支目标缓冲期<font color="#d83931">BTB</font></h4><ul>
<li>在高性能&#x2F;多流出处理机中，不仅要准确的预测分支，还要提供足够的指令流（4～8条），这需要尽早知道分支是否成功，尽早知道分支目标地址，尽早获得分支目标指令</li>
<li>在5段流水+BHT中，分支目标地址在ID算出，顺序下一条地址在IF算出，如果IF段能都求出来，这样在ID决定的同时选择正确的地址作为下一个IF加入，就能让分支的开销减小为0</li>
<li>BTB：<span style="background:#fff88f">分支目标缓冲器</span>&#x2F;分支目标Cache<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2020.13.19.png"><ul>
<li>表格的每一项有两个字段：执行过的成功分支指令的地址和预测的分支目标地址</li>
<li>每次取指令的同时把指令与BTB第一个字段进行比较，如果有匹配的就知道该指令是预测成功过的分支指令，所以本次也预测分支成功，目标地址由第二个字段给出（如果没有匹配当作普通指令）</li>
<li>处理步骤<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2020.18.08.png"><ul>
<li>IF：来一个指令、找BTB匹配项<ul>
<li>ID：找到了就把第二字段送给PC让他下一跳取目标地址（这里取来正确的则无延迟）<ul>
<li>EX：预测正确（无延迟）</li>
<li>EX：预测错误，修改BTB的项选择另一个分支，此时取指令暂停（还是取不来）<ul>
<li>EX+1：根据另一个分支再取指令（这里才能取来，2延迟）</li>
</ul>
</li>
</ul>
</li>
<li>ID：没找到，按照普通指令装下一条（有可能取不来）<ul>
<li>EX：预测正确，添加BTB的项，此时取指令也暂停（还是取不来）<ul>
<li>EX+1：根据分支结果取指令（取来了，2延迟）</li>
</ul>
</li>
<li>EX：预测错误，按照普通指令反而装对了，直接执行，一般不是分支指令（无延迟）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-3-3-基于硬件的前瞻执行"><a href="#4-3-3-基于硬件的前瞻执行" class="headerlink" title="4.3.3 基于硬件的前瞻执行"></a>4.3.3 基于硬件的<font color="#d83931">前瞻执行</font></h4><ul>
<li>对于多流出处理机，大概率每个时钟周期都有分支指令，只准确预测分支不够</li>
<li>前瞻执行解决了控制相关的问题<ul>
<li>对于分支指令的结果进行猜测，并假设这个猜测总是对的，然后按照这个猜测继续取、流出、执行后续指令</li>
<li>执行指令的结果不是写回寄存器存储器，而是放到<font color="#d83931">ROB</font>中共等待相应指令确认说“<span style="background:#fff88f">你干的还真对</span>”之后，再把结果写回寄存器和存储器<ul>
<li>这样即使猜错也可以恢复现场</li>
</ul>
</li>
</ul>
</li>
<li>前瞻执行的思想<ul>
<li>动态分支预测来选择后续执行的指令</li>
<li>在控制相关的分支结果没出现之前提前去执行后续指令</li>
<li>用动态调度对基本块的各种组合进行跨基本块的调度</li>
</ul>
</li>
<li>改造Tomasulo来实现前瞻执行<ul>
<li>写结果→写结果+指令确认<ul>
<li>写结果段负责把前瞻执行结果写到ROB，并通过CDB进行广播，需要这个结果的指令也“前瞻”的用这个结果进行计算</li>
<li>指令确认段在分支指令的结果出来之后对于相应的前瞻执行给予确认<ul>
<li>预测正确则把ROB结果写入寄存器&#x2F;存储器</li>
<li>预测错误就不确认并从分支指令的另一条分支重新执行</li>
</ul>
</li>
<li><span style="background:#fff88f">前瞻执</span><span style="background:#fff88f">行允许指令乱序，但需要顺序确认</span>，不缺人之前不能做不可恢复操作（更新计算机状态&#x2F;发生异常）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2020.44.06.png"></p>
<ul>
<li>寄存器上增加了一个ROB，前瞻执行的指令也是ROB提供结果，此图中store缓冲器被合并进了ROB<ul>
<li>ROB由以下4个字段组成<ul>
<li>指令类型：分支、store、寄存器操作</li>
<li>目标地址：指令结果应写入的目标寄存器号（load&amp;ALU）&#x2F;存储器单元的地址（store）</li>
<li>数据值字段：保存前瞻执行的结果，直到被确认</li>
<li>就绪字段：指出指令是否已经完成且数据已就绪</li>
</ul>
</li>
<li>保留站换名功能由ROB来完成，保留站子需要保存操作码和操作数，因为每条指令确认前都对于ROB中的一项所以执行结果由ROB标识（而不是保留站编号），这就要求保留站中需要记录对应指令的ROB编号</li>
</ul>
</li>
<li>采用前瞻执行机制后指令执行步骤的修改<ul>
<li>流出<ul>
<li>指令队列的头部取一条指令，如果有空闲的保留站r和空闲的ROB单元b，则把该指令放入r和b（有一个没空闲则停止流出）</li>
<li>如果该指令需要的操作数已经在寄存器（确认之前）或者ROB（不确认但先用着）中，则也送入r之中</li>
<li>修改r和b，标志已被占用，b也要存入r，告诉r中的指令对应b</li>
</ul>
</li>
<li>执行<ul>
<li>操作数没有都就绪就等待，检测CDB</li>
<li>当操作数都就绪后执行该指令的操作，load依旧算地址+取数据，store只算地址</li>
</ul>
</li>
<li>写结果<ul>
<li>结果产生之后把结果+ROB编号b都放到CDB上，写到ROB以及所有等待改结果的保留站中，然后释放该结果的保留站</li>
<li>store与原先算法不同：如果要写入存储器的数据就绪，则把该数据写入对应的ROB中（不能往存储器写，不确定分支对不对）</li>
</ul>
</li>
<li>确认<ul>
<li>ROB本身是一个队列，先进先出</li>
<li>ROB本身做的事大部分和寄存器完全相同，只有在分支预测错误的时候会有问题，其他时间都与普通的Tomasulo完全一致</li>
<li>如果队列头是一个分支&#x2F;store以外的指令，直接执行就完了</li>
<li>如果队列头是一个store，直接写就完了</li>
<li>如果队列头是一个预测正确的分支，说明它以及它后面前瞻执行的指令都是对了，直接往后走</li>
<li>如果队列头是一个预测错误的分支，<span style="background:#fff88f">说明它以及它后面前瞻执行的指令都是错的，则清除ROB</span></li>
</ul>
</li>
<li>举例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2021.29.05.png"><ul>
<li>前瞻执行技术实现了顺序完成，因为最后确认是顺序确认的，所以即使是乱序的写结果也要顺序的确认，但是及时写结果不耽误后续的计算</li>
<li><span style="background:#fff88f">顺序确认就能够实现前瞻执行</span>+<font color="#d83931">精确异常</font>，这个是Tomasulo算法所做不到的</li>
</ul>
</li>
<li>缺点<ul>
<li>硬件太过于复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-4-多指令流出技术"><a href="#4-4-多指令流出技术" class="headerlink" title="4.4 多指令流出技术"></a>4.4 <font color="#d83931">多指令流出技术</font></h3><ul>
<li>如果想要CPI小于一，单流出是不可能实现的（一个周期最快也只能流出一个），想要进一步提升性能只能采用多流出技术，每个时钟周期流出多条指令</li>
<li>多流出处理机的两种基本风格<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2021.34.02.png"><ul>
<li><font color="#d83931">超标量</font>：<ul>
<li>在每个时钟周期流出的指令条数不固定，但上限为n（称为n-流出）</li>
<li>超标量处理机既可以编译器静态调度，也可以Tomasulo动态调度</li>
<li>&#x3D;&#x3D;静态超标量处理机按序执行，动态超标量处理机乱序执行&#x3D;&#x3D;</li>
</ul>
</li>
<li><font color="#d83931">超长指令字VLIW</font><ul>
<li>每个时钟流出的指令条数固定，多条指令构成一条长指令或者一个指令包</li>
<li>指令包中的指令的并行性通过指令显式的表示出来</li>
<li>&#x3D;&#x3D;处理机的指令调度是编译器静态完成的&#x3D;&#x3D;</li>
</ul>
</li>
<li>超标量比VLIM的优点<ul>
<li>超标量对于程序员透明，处理机自己能检测下一条指令是否能流出，不需要重新排列指令来满足指令的流出</li>
<li>即使是没有经过编译器针对超标量结构进行调度优化的代码或者旧编译器生成的代码也可以运行，不过运行效果没有使用动态超标量调度技术的好</li>
</ul>
</li>
<li>多流出技术举例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-05%2021.41.29.png"></li>
</ul>
</li>
</ul>
<h4 id="4-4-1-基于静态调度的多流出技术"><a href="#4-4-1-基于静态调度的多流出技术" class="headerlink" title="4.4.1 基于静态调度的多流出技术"></a>4.4.1 基于静态调度的多流出技术</h4><ul>
<li>典型的超标量处理机一个周期可以流出1～8条指令<ul>
<li>静态调度的超标量处理机中指令按序流出，冲突检测在流出时进行，硬件检测当前流出的指令是否冲入以及当前流出的指令是否和正在执行的指令冲突<ul>
<li>如果检测出有冲突则只流出冲突指令之前的指令</li>
<li>检测由流出部件完成而且十分复杂，往往会分为多个流水段来完成（比如一个用来只进行流出包内指令的冲突检测，一个用来进行“正在执行指令”的冲突检测</li>
</ul>
</li>
<li>提高指令流出速率时，指令流出段会成为流水线的瓶颈</li>
</ul>
</li>
<li>MIPS按照超标量方式工作<ul>
<li><span style="background:#fff88f">每个时钟周期一条整数型指令和一条浮点型指令</span>（load、store、分支也视作整数型指令）</li>
<li>为了实现双流出需要实现同时取2条指令、同时译码两条指令。</li>
<li>指令处理<ul>
<li>cache中取两条指令</li>
<li>确定哪几条指令可以流出</li>
<li>发送到相应的功能部件</li>
</ul>
</li>
<li>1整+1浮的流出方式消除了大多数流出包内的冲突，不过如果整数指令是浮点load、store、move时可能会征用浮点寄存器端口或有新RAW冲突<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-06%2010.13.24.png"></li>
<li>双流出超标量处理机大大提高了浮点指令流出的速率</li>
<li>1+1的并行流出方式对于硬件增加很好</li>
</ul>
</li>
<li>其他障碍<ul>
<li>load指令会有一个时钟周期的延迟（执行阶段并不会立刻产生结果，需要等到写结果段），这使得紧跟load且需要load结果的指令需要等待一个周期。而在双流出中，同一周期的另一浮点指令以及下一周期的两条指令都无法使用——load后续三条指令都不能用load的结果</li>
<li><span style="background:#fff88f">分支指令如果是流出包第一条则延迟</span>&#x3D;&#x3D;3条指令&#x3D;&#x3D;，如果是第二条指令则是&#x3D;&#x3D;两条指令&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h4 id="4-4-2-基于动态调度的多流出技术"><a href="#4-4-2-基于动态调度的多流出技术" class="headerlink" title="4.4.2 基于动态调度的多流出技术"></a>4.4.2 基于动态调度的多流出技术</h4><ul>
<li>动态调度可以提高性能，克服指令流出所受的限制</li>
<li>为了充分利用动态流水线但又不想乱序向保留站流出指令<ul>
<li>可以将整数的表结构和浮点的表结构完全分离</li>
<li>举例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-06%2011.02.35.png"></li>
<li>双流出动态调度流水线的性能受限于<ul>
<li>整数部件与浮点部件的工作负载不平衡</li>
<li>每个循环迭代中控制开销太大</li>
<li>必须等待分支指令的结果才能开始下一条LD<ul>
<li>前瞻执行可以解决</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-4-3-超长指令字技术"><a href="#4-4-3-超长指令字技术" class="headerlink" title="4.4.3 超长指令字技术"></a>4.4.3 超长指令字技术</h4><ul>
<li>与超标量不同，指令流出时不需要进行复杂的冲突检测，而是依靠编译器在编译时找出指令之间潜在的并行性，并且通过指令调度把可能出现的数据冲突减少到最少，最后把能并行执行的多条指令组装成一条很长的指令</li>
<li>处理机中有多个功能部件，一个指令含有多个字段，一个字段独立控制一个功能部件称为工作槽<ul>
<li>程序指令序列拥有足够的并行性，尽量填满每个操作槽</li>
<li>并行性由编译器来挖掘，编译器展开循环并调度</li>
<li>编译器负责所有的安排，控制硬件简单，因此流出宽度增加时优势明显</li>
</ul>
</li>
<li>VLIM的问题<ul>
<li>代码长度增加，每个工作槽不可能总能填满，空间浪费<ul>
<li>采用指令共享立即数字段解决</li>
</ul>
</li>
<li>锁歩机制，一个操作部件停顿则整个处理机停顿<ul>
<li>采用硬件动态监测机制解决</li>
</ul>
</li>
<li>机器代码不兼容，不同配置的VLIM差别很大<ul>
<li>采用机器代码翻译或仿真</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-4-4-多流出处理器收到的限制"><a href="#4-4-4-多流出处理器收到的限制" class="headerlink" title="4.4.4 多流出处理器收到的限制"></a>4.4.4 多流出处理器收到的限制</h4><ul>
<li>程序所固有的指令级并行性<ul>
<li>需要有大量的并行执行操作才能避免流水线停顿，比如浮点流水线延迟为五个时钟周期那就需要5条无相关浮点指令（无相关指令数&#x3D;流水线深度 * 同时工作部件数）</li>
</ul>
</li>
<li>硬件实现上的困难<ul>
<li>随着每个时钟周期流出指令数增加，需要的硬件、整数运算部件、浮点运算部件</li>
</ul>
</li>
<li>超标量和超长指令字处理器固有的技术限制<ul>
<li>如同前文所述</li>
</ul>
</li>
</ul>
<h4 id="4-4-5-超流水线处理机"><a href="#4-4-5-超流水线处理机" class="headerlink" title="4.4.5 超流水线处理机"></a>4.4.5<font color="#d83931"> </font><font color="#d83931">超流水线处理机</font></h4><ul>
<li>如果把5段流水的每个流水段进一步分解为两个延迟更短的流水段，那么一个指令执行需要经过10个流水段，并且各段都在处理各自的两条指令<ul>
<li>这种一个时钟周期内能分时流出多条指令的处理机称为超流水线处理机</li>
</ul>
</li>
<li>超流水线处理机<ul>
<li>只需要增加少量硬件，主要是通过各部分硬件重叠工作来提高性能（利用时间并行性）</li>
<li>n流出不是同时流出，而是1&#x2F;n周期流出一条指令</li>
<li>理论上就是压缩流水线的每一段变成“流水级”</li>
<li><blockquote>
<p>8级即可称为超流水线处理机<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-06%2011.27.27.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>R4000的8级流水线<ul>
<li>IF：取指令前半部，根据PC启动对指令Cache访问</li>
<li>IS取指令后半部，完成对Cache的访问</li>
<li>RF：指令译码、访问寄存器读操作时、冲突检测、判断Cache是否命中</li>
<li>EX：指令执行。有效地址计算、ALU操作、分支目标地址计算和条件码测试</li>
<li>DF：取数据的前半步，启动对数据Cache访问</li>
<li>DS：取数据的后半部，完成对数据Cache访问</li>
<li>TC：标识比较，判断对数据Cache的访问是否命中</li>
<li>WB：load或运算型指令把结果写回寄存器组<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-06%2011.39.03.png"><br>   <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-06%2011.44.47.png"><br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-06%2011.46.10.png"></li>
<li>load指令的结果在第六级DS结束后就可以使用了，本例中ADD就超前使用了LD的数据，此时LD第七级还没有验证是否命中，所以如果发现不命中之后流水线就要等待正确的数据同时回退一个时钟周期</li>
</ul>
</li>
</ul>
<h3 id="4-5-循环展开和指令调度"><a href="#4-5-循环展开和指令调度" class="headerlink" title="4.5 循环展开和指令调度"></a>4.5 循环展开和指令调度</h3><h4 id="4-5-1-循环展开和指令调度的基本方法"><a href="#4-5-1-循环展开和指令调度的基本方法" class="headerlink" title="4.5.1 循环展开和指令调度的基本方法"></a>4.5.1 循环展开和指令调度的基本方法</h4><ul>
<li>要想充分发挥流水线就必须想办法让它满负荷工作，需要充分寻找不相关的指令序列然后在流水线上重叠并行执行，其中最简单最常用的方法就是开发循环级并行性<ul>
<li>把循环展开后，通过重命名和指令调度来开发更多的并行性</li>
<li>编译器受限于两个特性：程序固有的指令集并行性以及流水线功能部件的执行延迟<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-06%2011.51.29.png"><ul>
<li>如果浮点load直接store，延迟可以为0</li>
</ul>
</li>
</ul>
</li>
<li>现状分析（5段流水线）<ul>
<li>如果遇到一个循环代码，转换成MIPS后</li>
<li>load停顿一周期，加法两周期，分支一周期</li>
<li>需要指令调度，减少等待的空转</li>
<li>但是空转再少依旧解决不了分支判断本身就有三条指令所占的三个周期</li>
<li>因此需要展开循环，减少分支判断的次数</li>
</ul>
</li>
<li>循环展开+寄存器重命名+指令调度可以有效的开展并行</li>
<li>循环展开和指令调度需要注意的问题<ul>
<li>保证正确性：循环控制、操作数偏移量的修改</li>
<li>注意有效性：只有能够找到不同循环体之间的无关性才能有效的使用循环展开（不是所有都能展）</li>
<li>使用不同寄存器：必须换名，不然会有新的冲突（遍数增多用到的寄存器肯定会变多）</li>
<li>删除多余的测试指令和分支指令，并对循环结束代码和新的循环体代码进行相应的修正</li>
<li>注意对于存储器数据的相关性分析（如果load&#x2F;store在不同迭代中访问的存储地址是不同的，那么它们就是相互独立的，可以互相对调</li>
<li>注意新的相关性</li>
</ul>
</li>
</ul>
<h4 id="4-5-2-静态超标量处理机中的循环展开"><a href="#4-5-2-静态超标量处理机中的循环展开" class="headerlink" title="4.5.2 静态超标量处理机中的循环展开"></a>4.5.2 静态超标量处理机中的循环展开</h4><ul>
<li>示例<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-07%2000.25.24.png"></li>
</ul>
<h2 id="第七章-互联网络（难点）"><a href="#第七章-互联网络（难点）" class="headerlink" title="第七章 互联网络（难点）"></a>第七章 互联网络（难点）</h2><blockquote>
<p>10%<br>简答题一道<br>大题（可能性较小）</p>
</blockquote>
<ul>
<li>互连网络：由开关元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中节点之间的互相连接<ul>
<li>节点可以是处理器、存储模块或者其他设备</li>
<li>互联网络是输入节点到输出节点的一组互连或者映像</li>
</ul>
</li>
<li>互联网络成了SIMD和MIMD计算机的关键组成部分<ul>
<li>多处理机和多计算机系统的规模越来越大，对于处理器之间或处理器和存储模块之间通信的速度和灵活性的要求也越来越高</li>
<li>对于计算机系统的性能价格比有决定性的影响</li>
</ul>
</li>
<li>互联网络的3大要素：互连结构、开关元件和控制方式</li>
</ul>
<h3 id="7-1-互连函数"><a href="#7-1-互连函数" class="headerlink" title="7.1 互连函数"></a>7.1 互连函数</h3><ul>
<li>互连网络是输入节点到输出节点之间的一组互连，这种互连可以用互连函数来表示<ul>
<li>假设互连网络有N个输入端和N个输出端（分别用0～N-1来表示），则互连函数表示了输入端号和输出端号的连接关系</li>
</ul>
</li>
</ul>
<h4 id="7-1-1-互连函数的表示方法"><a href="#7-1-1-互连函数的表示方法" class="headerlink" title="7.1.1 互连函数的表示方法"></a>7.1.1 互连函数的表示方法</h4><ul>
<li>x表示输入，f(x)表示输出</li>
<li>互连函数反映了网络输入端数组和输出端数组之间对应的置换关系或排列关系，互连函数有时也叫做置换函数&#x2F;排列函数<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.12.39.png"></li>
<li>有的互连函数f(x)可以采用循环表示法<ul>
<li>比如（x₀ x₁···x ⱼ₋₁）表示f(x₀)&#x3D;x₁…f(x ⱼ₋₁)&#x3D;x₀</li>
<li>即每个口连它下一个口</li>
</ul>
</li>
<li>可以用n为2进制来表示2ⁿ个输出端和输入端的二进制地址<ul>
<li>比如f(111)&#x3D;f(8)</li>
</ul>
</li>
</ul>
<h4 id="7-1-2-几种基本的互连函数"><a href="#7-1-2-几种基本的互连函数" class="headerlink" title="7.1.2 几种基本的互连函数"></a>7.1.2 <font color="#d83931">几种基本的互连函数</font></h4><ul>
<li><font color="#d83931">恒等函数</font><ul>
<li>实现的互连：同好输入端和输出端</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.20.33.png"></li>
</ul>
</li>
<li><font color="#d83931">交换函数</font><ul>
<li>实现的互连：二进制地址编码中第k位互反的输入端和输出端之间的函数<ul>
<li>相当于每个口和比自己大2ᵏ的口连</li>
</ul>
</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.23.07.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.23.07.png"></li>
<li>交换函数主要用于构造立方体&#x2F;超立方体互连网络，一共有n&#x3D;log ₂N种互连函数（二进制的每一位都可以变）</li>
<li>当N&#x3D;8，n&#x3D;3时就是常用的立方体互连函数<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.26.32.png"><ul>
<li>一共有三种，变哪位都行</li>
<li>变换图形<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.26.18.png" alt="|500"></li>
<li>结构<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.27.40.png"><ul>
<li>这里的本质其实是三个维度的互连，只要汉明距离为1的点就会互连（只相差一位），比如最低位不同可以视作第一维度的互连，也就是图中的y维度（左到右），第二维度和第三维度类似，一个维度的连接对应一个互连函数，三个互连函数同时作用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">均匀洗牌函数</font><ul>
<li>将输入端分成数目相等的两半，前一半和后一半按照类似均匀洗混扑克牌的方式交叉的连接到输出端（输出端类似混洗的结果）</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.38.51.png"><ul>
<li>即把输入端的二进制编号循环左移一位</li>
</ul>
</li>
<li>针对某些互连函数s，可以定义其第k个子函数（把s作用于输入端二进制编号的低k位）和第k个超函数（把s作用于输入端二进制编号的高k位）<ul>
<li>比如均匀洗牌函数的第k个子函数<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.41.34.png">     - 后k位循环左移</li>
<li>均匀洗牌函数的第k个超函数<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.42.10.png"><ul>
<li>高k位循环左移</li>
</ul>
</li>
<li>一些等式<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.44.24.png"><br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.44.24.png"></li>
</ul>
</li>
<li>逆函数：把函数操作给操作回去的函数<ul>
<li>左移一位的逆函数就是右移一位<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.45.38.png"></li>
<li>逆均匀洗牌和均匀洗牌的连接图互为镜像</li>
</ul>
</li>
<li>均匀洗牌和逆均匀洗牌是很有用的互连函数，用它们和交换开关多级组合起来构成了Omege网络和逆Omega网络</li>
<li>&#x3D;&#x3D;只用全混洗函数不能实现任意结点之间的互连，通常用全混洗函数与其他函数，如交换函数一起构成互连网络&#x3D;&#x3D;</li>
</ul>
</li>
<li><font color="#d83931">蝶式函数</font><ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.47.47.png"></li>
<li>把最高位和最低位互换<ul>
<li>可以粗糙的理解为“两个目标位相同的连自己，不同的小的+2ᵏ-1就是大的</li>
<li>k位超函数的话就是小的+2ⁿ⁻¹-2ⁿ⁻ᵏ⁻¹就是大的</li>
</ul>
</li>
<li>蝶式函数的第k位超函数<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.49.42.png"><ul>
<li>也就是高k位中的最高位和最低位互换</li>
</ul>
</li>
<li>一些等式<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.50.38.png">	</li>
<li>举例：N&#x3D;8时的交换图<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-07%2023.58.41.png"></li>
</ul>
</li>
<li><font color="#d83931">反位序函数</font><ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.18.03.png"></li>
<li>完全颠倒<ul>
<li>子函数和超函数自然是颠倒高位和低位</li>
</ul>
</li>
<li>一些等式<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.19.35.png"></li>
</ul>
</li>
<li><font color="#d83931">移数函数</font><ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.22.57.png"></li>
<li>输入端错开一定位置后连到输出端<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.23.41.png"></li>
</ul>
</li>
<li>PM2I<ul>
<li>P表示加，M表示减，2I表示2ⁱ，该函数又称加减2ⁱ函数</li>
<li>是特殊的移数函数，指错开“2ⁱ”的移数函数</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.25.48.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.28.29.png"></li>
<li>阵列机的基础，下图就是采用<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.30.39.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2010.29.51.png"></li>
</ul>
</li>
</ul>
<h3 id="7-2-互连网络的结构参数与性能指标"><a href="#7-2-互连网络的结构参数与性能指标" class="headerlink" title="7.2 互连网络的结构参数与性能指标"></a>7.2 互连网络的结构参数与性能指标</h3><h4 id="7-2-1-互连网络的结构参数"><a href="#7-2-1-互连网络的结构参数" class="headerlink" title="7.2.1 互连网络的结构参数"></a>7.2.1 互连网络的结构参数</h4><ol>
<li><font color="#d83931">网络规模N</font>：节点个数</li>
<li><font color="#d83931">节点度d</font>：节点所连接的边数，进入入度，流出出度</li>
<li><font color="#d83931">节点距离</font>：从一个节点出发到另一个节点终止所需要跨越的边数最小值</li>
<li><font color="#d83931">网络直径D</font>：任意两个节点间距离的最大值</li>
<li><font color="#d83931">等分宽度b</font>：把N个节点切成节点数相同的两半中，切口边数的最小值为等分宽度，如果乘上通道宽度（位）则是线等分宽度，反映网络的最大流量</li>
<li><font color="#d83931">对称性</font>：如果任意节点来看网络的结构相同，则称为对称网络，对称网络实现容易、编程容易</li>
</ol>
<h4 id="7-2-2-互连网络的性能指标"><a href="#7-2-2-互连网络的性能指标" class="headerlink" title="7.2.2 互连网络的性能指标"></a>7.2.2 互连网络的性能指标</h4><ol>
<li>通信时延：源节点到目的节点传送一条消息的总时间，由以下4部分组成<ol>
<li>软件开销：源节点和目的节点收发消息的软件所需的执行时间</li>
<li>通道时延：通过通道传送消息所花的时间。通路时延&#x3D;消息长度&#x2F;通道带宽</li>
<li>选路时延：消息在传送路径上所需的一系列选路决策所需的时间开销</li>
<li>竞争时延：多个消息同时在网络中传送时，会发生争用网络资源的冲突。为了避免或解决争用冲突所需要的时间就是竞争时延</li>
</ol>
<ul>
<li>软件开销取决于软件内核，通道时延由瓶颈链路的通道带宽决定，选路时延与传送路径的节点数成正比，竞争时延难预测，取决于网络传输的状态</li>
</ul>
</li>
<li>网络时延：通道时延与选路时延之和（上面的2+3），网络时延只有网络硬件的特征有关</li>
<li><font color="#d83931">端口带宽</font>：单位时间内从该端口传送到其他端口的最大信息量，对称网络各个端口带宽都是网络端口带宽，非对称网络端口带宽则是所有端口带宽的最小值</li>
<li><font color="#d83931">聚集带宽</font>：网络从一般节点到另一半节点单位时间内能够传送的最大信息量（理想的等分带宽，无视网络结构）</li>
<li>等分带宽：与等分宽度对应的切平面中，所有边合起来单位时间所能传送的最大信息量称为网络的等分带宽</li>
</ol>
<h3 id="7-3-静态互连网络"><a href="#7-3-静态互连网络" class="headerlink" title="7.3 静态互连网络"></a>7.3 <font color="#d83931">静态互连</font>网络</h3><ul>
<li>互连网络分为静态互连网络和动态互连网络<ul>
<li>静态指各个节点之间有固定的连接通路且运行中不能改变的网络</li>
<li>动态互连网络是由交换开关构成、可以按照运行程序的要求动态改变连接状态的网络</li>
</ul>
</li>
<li>静态互连网络适合于构造通信模式可预测&#x2F;可用静态连接实现的计算机<ul>
<li>一维：线性阵列结构</li>
<li>二维：环形、星形、树形、网格形</li>
<li>三维：立方体形</li>
<li>三维以上：超立方体形</li>
</ul>
</li>
<li>线性阵列<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.31.41.png" alt="|269"></li>
<li>数据<ul>
<li>N个节点用N-1条链路连成一行</li>
<li>内部节点度d&#x3D;2，段节点度d&#x3D;1</li>
<li>直径D&#x3D;N-1</li>
<li>等分宽度b&#x3D;1</li>
</ul>
</li>
<li>成本低、不对称、通信效率低</li>
<li>只适合N&#x3D;2&#x2F;3用</li>
<li>总线同时间只允许一对参数，线性阵列允许任何通路不重叠的节点对传输</li>
</ul>
</li>
<li>环和带弦环<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.35.36.png" alt="|300"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.37.44.png" alt="|212"></li>
<li>把线性阵列两个段节点连接即可成环</li>
<li>可以单向环也可以双向环</li>
<li>数据<ul>
<li>节点d&#x3D;2</li>
<li>直径D&#x3D;N&#x2F;2（双向环），N-1（单向环）</li>
<li>等分宽度b&#x3D;2</li>
</ul>
</li>
<li>带弦环<ul>
<li>带弦的环，增加的弦越多，节点的度越高，网络的直径就越小</li>
<li>环直径&#x3D;8、3度带弦环直径&#x3D;5、4度带弦环直径&#x3D;3</li>
<li>最极端的全连接网络度为15，直径为1<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.40.42.png" alt="|202"></li>
</ul>
</li>
</ul>
</li>
<li>循环移数网络<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.41.21.png" alt="|194"></li>
<li>通过环上增加以下链路而构成：每个节点到所有与其距离为2的整数幂的节点之间加一条链路(+2、+4、+8..)</li>
<li>数据<ul>
<li>节点度d&#x3D;2n-1</li>
<li>直径D&#x3D;n&#x2F;2</li>
<li>规模N&#x3D;2ⁿ</li>
</ul>
</li>
<li>与节点度较低的带弦环相比，循环移数网络都具有更好的连接特性，比如N&#x3D;16时，循环移数网络节点度为7，直径已经只有2了</li>
</ul>
</li>
<li>树形和星形<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.45.01.png" alt="|375"></li>
<li>k层的完全平衡二叉树有<ul>
<li>N&#x3D;2ᵏ⁻¹个节点</li>
<li>节点度d&#x3D;3，为常数，可拓展</li>
<li>直径D&#x3D;2（k-1）</li>
<li>等分宽度b&#x3D;1</li>
<li>缺点是直径比较长</li>
</ul>
</li>
<li>星形是一种具有两层的树<ul>
<li>节点度很高d&#x3D;N-1</li>
<li>直径D&#x3D;2较小</li>
<li>等分宽度b&#x3D;⌊N&#x2F;2⌋</li>
<li>缺点是可靠性较差，中心节点故障会完全瘫痪</li>
</ul>
</li>
</ul>
</li>
<li>胖树形<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.49.47.png" alt="|315"></li>
<li>解决了根部节点以及连接根部的链路负载较重而称为系统瓶颈的问题</li>
<li>越接近根部越粗</li>
</ul>
</li>
<li>网格形和环网形<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2011.51.21.png" alt="|500"></li>
<li>对于N&#x3D;n×n的二维网络<ul>
<li>内部节点度d&#x3D;4，边结点度d&#x3D;3，角节点度d&#x3D;2</li>
<li>网络直径D&#x3D;2（n-1）</li>
<li>等分宽度b&#x3D;n</li>
<li>不对称</li>
</ul>
</li>
<li>Illiac网络：把二维网格形网络每一列两段相连，所有行尾连下一行行头层一个大环<ul>
<li>节点度d&#x3D;4</li>
<li>直径D&#x3D;n-1，是网格形的一半</li>
<li>等分宽度b&#x3D;2n</li>
</ul>
</li>
<li>环形网络：每行每列两段都相连<ul>
<li>节点度d&#x3D;4</li>
<li>直径D&#x3D;2⌊n&#x2F;2⌋</li>
<li>等分宽度b&#x3D;2n</li>
<li>对称</li>
<li>是环形与网格形的组合，可以向高维拓展</li>
</ul>
</li>
</ul>
</li>
<li>超立方体<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2012.00.21.png" alt="|500"></li>
<li>二元n-立方体结构，由N&#x3D;2ⁿ组成，分布在n维上，每一维有两个节点</li>
<li>低维立方体复制一份+对应节点相连&#x3D;高维立方体<ul>
<li>节点度d&#x3D;n，会随着维度线性增加，所以很难扩展</li>
<li>直径D&#x3D;n</li>
<li>等分宽度b&#x3D;N&#x2F;2</li>
<li>对称</li>
</ul>
</li>
</ul>
</li>
<li>带环立方体<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2012.06.38.png" alt="|500"></li>
<li>带环k-立方体（简称k-CCC）网络，就是把k-立方体的每个节点换成一个k个节点环<ul>
<li>规模N&#x3D;k×2ᵏ</li>
<li>直径D&#x3D;2k-1+⌊k&#x2F;2⌋，比k-立方体直径大一倍</li>
<li>等分宽度b&#x3D;N&#x2F;2k</li>
</ul>
</li>
<li>好处是原来节点度为k，现在节点度永远是3（节点变多了），拥有较好的扩展性</li>
</ul>
</li>
<li>k元n-立方体网络<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2012.22.28.png" alt="|325"></li>
<li>n指几维，k指立方体的边长（基数）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2012.23.44.png"></li>
</ul>
</li>
<li>静态互连网络特征一览表<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2012.24.32.png"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2012.24.46.png"><ul>
<li>节点度不超过4时比较理想，全连接和星形的节点度太高，超立方体也是log₂N增加，N大的时候也会很高</li>
<li>直径小是优点，但不是严重的问题，高流水下通信延迟几乎不变（平均距离是更好的度量指标）</li>
<li>链路数影响网络成本</li>
<li>等分宽度影响网络带宽，越宽越好</li>
<li>对称性影响可扩放性和寻径效率</li>
</ul>
</li>
</ul>
<h3 id="7-4-动态互连网络"><a href="#7-4-动态互连网络" class="headerlink" title="7.4 动态互连网络"></a>7.4 <font color="#d83931">动态互连</font>网络</h3><h4 id="7-4-1-总线网络"><a href="#7-4-1-总线网络" class="headerlink" title="7.4.1 总线网络"></a>7.4.1 <font color="#d83931">总线网络</font></h4><ul>
<li>总线由一组导线和插座构成，经常被用来实现计算机系统中处理机模块、存储模块和外围设备之间的互连。每一次总线只能用于一个源到一个或者多个目的之间的数据传送</li>
<li>多个请求的情况下，总线仲裁逻辑只能按照一定的规则将总线分配给其中的一个请求，并且按照分时原则轮流为多个请求服务<ul>
<li>总线被称为各个模块之间的争用总线、时分总线</li>
</ul>
</li>
<li>总线相比于多级互连网络&#x2F;交叉开关网络来说，结构简单、实现成本低，但是由于多个模块分时共享，每次只能处理一个请求，所以很容易成为系统的瓶颈</li>
<li>系统总线通常设置在印刷电路板地板上，处理器板、存储器板和设备接口板都通过插座或电缆插入底板<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2015.47.29.png"></li>
<li>为了解决总线带宽较窄的问题可以采用多总线或者多层次的总线（一种是为不同功能设置专门的总线，一种是重复设置相同功能的总线）</li>
</ul>
<h4 id="7-4-2-交叉开关网络"><a href="#7-4-2-交叉开关网络" class="headerlink" title="7.4.2 交叉开关网络"></a>7.4.2<font color="#d83931"> </font><font color="#d83931">交叉开关网络</font></h4><ul>
<li>类似电话交换机一样的单极开关网络，开关可以动态的设置为“开”或者“关”，与其他的动态互连网络相比交叉开关网络的带宽和互连特性是最好的（对于n × n的交叉开关网络可以无阻塞实现n！种置换），但是需要n ²套交叉点开关以及大量的连线，n大的时候需要巨大数量的硬件，一般只有n ≤16的交叉开关网络会实际被使用</li>
<li>可以在处理机和存储器模块之间用交叉开关网络互连，构成一个共享存储器的多处理机<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2016.20.35.png%7C450"><ul>
<li>这里一个存储模块只能同时满足一台处理机请求，如果多个请求同时访问，交叉开关必须分解冲突，每列只能接通一个交叉点开关</li>
<li>如果想要支持并行存储器访问，可以在同一行中接通几个交叉点开关</li>
</ul>
</li>
<li>处理机之间的交叉开关可以实现处理机之间的置换连接，但这只是1对1的连接，因此nxn的交叉开关网络一次最多可以实现n个“源-目的”对的连接</li>
</ul>
<h4 id="7-4-3-多级互连网络"><a href="#7-4-3-多级互连网络" class="headerlink" title="7.4.3 多级互连网络"></a>7.4.3 <font color="#d83931">多级互连网络</font></h4><ul>
<li>多级互连网络的构成<ul>
<li>通用的多级互连网络结构<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2016.34.16.png"><ul>
<li>每一级都用多个axb开关，相邻各级开关之间都有固定的级间连接</li>
<li>一个axb开关模块有a个输入和b个输出，a和b可以不等，但实际上一般都是a&#x3D;b&#x3D;2ᵏ，k ≥1</li>
</ul>
</li>
<li>各种多级互连网络的区别在于开关模块、控制方式、级间互连模式的不同<ul>
<li>开关模块![[截屏2024-06-08 16.41.26.png]]<ul>
<li>2x2开关的4种连接方式![[截屏2024-06-08 16.41.53.png|400]]</li>
</ul>
</li>
<li>控制方式：对各个开关模块进行控制的方式<ul>
<li>级控制：每一级的所有开关之用一个控制信号进行控制，一列的所有开关处于一个状态</li>
<li>单元控制：每一个开关有一个单独的控制信号，可以处于不同状态</li>
<li>部分级控制：第i级的所有开关分别用i+1个信号控制</li>
</ul>
</li>
<li>级间互连模式：均匀洗牌、蝶式、多路洗牌、纵横交叉、立方体连接</li>
</ul>
</li>
</ul>
</li>
<li>多级立方体网络<ul>
<li>包括<span style="background:#fff88f">STARAN</span>网络和间接二进制n方体网络等，两者仅在控制方式上不同，都采用的是直送&amp;交换的2×2开关，当第i级交换开关处于交换状态的时候实现的就是Cubeᵢ互连函数（第i位反转）![[截屏2024-06-08 17.00.29.png|500]]<ul>
<li>一般来说N输入的多级立方体网络有log₂N级，一级N&#x2F;2个2×2开关，一共log₂NxN&#x2F;2个开关</li>
<li>这里专门就是依次把第一位相反的数、第二位相反的数、第三位相反的数拉到一个交换开关里，只要哪一级控制就对应着哪一位反转</li>
</ul>
</li>
<li>STARAN网络采用级控制和部分级控制，而间接二进制n方体网络则采用单元控制<ul>
<li>当STARAN网络采用级控制可以实现交换功能，采用部分级控制时可以实现移数功能</li>
<li>交换指将有序的元素首尾对称的进行交换（反转），还可以进行分组交换，如果组的范围是全部则称为全交换或镜像交换![[截屏2024-06-08 17.09.18.png]]<ul>
<li>4组二元相当于第一位反转，2组4位相当于前两位反转，1组8位相当于3位都反转</li>
</ul>
</li>
</ul>
</li>
<li>STARAN函数实现的函数交换功能（级控制）![[截屏2024-06-08 17.20.03.png]]<ul>
<li>两个控制信号异或就是对应的功能叠加（本身异或就是不进位的加法）反转再反转也会变回去</li>
</ul>
</li>
<li>STARAN实现移数网络（部分级控制）![[截屏2024-06-08 17.23.54.png]]<ul>
<li>A～L指的是前面结构图里的交换单元，1就是上面对应的交换单元开启交换功能，0就是直通</li>
</ul>
</li>
<li>STARAN被成功用在了STARAN计算机中，对于存储器中错位存放的数据在读出后和写入前进行重新对准和排列以适应处理部件对于数据正常位序的需要，利用交换和移数这两种基本的功能加上对数据位进行评比，还可以实现全混、展开、压缩等多种数据变换</li>
</ul>
</li>
<li><font color="#d83931">Omega网络</font><ul>
<li>![[截屏2024-06-08 17.33.17.png]]</li>
<li>N输入的Omega网络有log₂N级，每一级用N&#x2F;2个4功能的2×2开关模块，共需要log₂NxN&#x2F;2个开关，每个开关均采用单元控制方式</li>
<li>把STARAN中的开关F和G对调，能看出其与Omega网络是互逆的，因此当Omega网络采用2功能交换开关，则Omega网络和间接二进制n方体网络互为逆网络![[截屏2024-06-08 17.37.57.png|475]]</li>
</ul>
</li>
</ul>
<h4 id="7-4-4-动态互连网络的比较"><a href="#7-4-4-动态互连网络的比较" class="headerlink" title="7.4.4 动态互连网络的比较"></a>7.4.4 动态互连网络的比较</h4><p>![[截屏2024-06-08 17.38.20.png]]</p>
<ul>
<li>总线互连的复杂性最低、成本最低、带宽较窄</li>
<li>交叉开关的成本最高、硬件复杂性高、带宽和寻径性能最好</li>
<li>多级互连网络的复杂度和带宽介于其他两者之间，有点事模块化结构、可拓展性好，不过其时延随网络级数增加而上升，并且硬件复杂程度比总线还是高很多，成本较高</li>
</ul>
<h3 id="7-5-消息传递机制"><a href="#7-5-消息传递机制" class="headerlink" title="7.5 消息传递机制"></a>7.5 <font color="#d83931">消息传递</font>机制</h3><ul>
<li>在多处理器或者多计算机各个节点之间通信中消息传递机制很重要，处理器之间是通过发消息进行通信的，当某个处理机A要对远程存储器上的数据进行访问时，他就通过给相应的远程处理机B发送消息来请求数据，该消息可以看成是一个远程进程调用RPC，处理器B接收到消息以后会代替A对相应数据进行访问或执行操作，然后发送一个应答消息给处理器A，然后返回结果</li>
<li>如果源节点和目的节点之间没有直接的连接，这需要经过中间的节点进行传递，<font color="#d83931">寻径</font>就是用来实现这种传递的通信方法和算法</li>
</ul>
<h4 id="7-5-1-消息训径方案"><a href="#7-5-1-消息训径方案" class="headerlink" title="7.5.1 消息训径方案"></a>7.5.1 消息<font color="#d83931">训径方案</font></h4><ul>
<li>消息的格式<ul>
<li>消息是节点之间进行通信的逻辑单位，消息一般由若干个包组成，尽管包长度固定，但包的个数不固定，因此消息的长度也是不固定的![[截屏2024-06-08 18.15.04.png|500]]</li>
<li>包是包含寻径所需目的地址的基本单位，不同的包可能会乙部到达目的节点，因此一条消息中的各个包都被依次分配了一个序号以保证所有包到达后可以重新组装出消息</li>
<li>包可以进一步分成更小固定长度的单位片，寻径信息和包序列号形成头片，剩下的都是数据片</li>
<li>包的长度由寻径方案和网络的具体实现所决定，典型的长度是64～512位不等，片的长度经常受网络大小的影响，一个256个节点构成的网络要求片长度为8位（头片能够表示所有的节点），其他影响包长度和片长度的因素还有通道带宽、寻径设计、网络流量密度等</li>
</ul>
</li>
<li>4种寻径方式：消息训径方式可以分为线路交换和包交换，包交换又可以细分为存储转发、虚拟直通和虫蚀<ul>
<li><font color="#d83931">线路交换</font><ul>
<li>传递一个信息之前需要先建立一条源节点到目的节点的物理通路然后再传消息</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2018.22.44.png" alt="|180"><ul>
<li>L位信息包长度、L ₜ为建立路径所需要的小信息包长度，D为经过的中间节点个数，B为带宽</li>
<li>D个中间节点需要D+1个信息包来建立通路</li>
</ul>
</li>
<li>优点：传输带宽大、平均时延小、缓冲区小，适合具有动态和突发性的大规模并行处理数据的传送</li>
<li>缺点：<span style="background:#fff88f">需要频繁建立物理通路，时间开销大</span></li>
</ul>
</li>
<li><font color="#d83931">存储转发</font><ul>
<li>最简单的分组交换方式，包是信息传递的基本单位，包从源节点经过一系列的中间节点到达目的节点，存储转发要求所经过的每个中间节点时，该节点先存储然后在出口链路可用且对端包缓冲器也可用的时候传递给下一节点<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2018.28.53.png"></li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2018.29.11.png" alt="|190"><ul>
<li>相当于D+1段每段完整传输</li>
</ul>
</li>
<li>缺点：包缓冲区大，<span style="background:#fff88f">不利于VLSI（超大规模集成电路）</span>实现，网络时延大，与节点距离成正比</li>
</ul>
</li>
<li><font color="#d83931">虚拟直通</font><ul>
<li>对于存储转发的改进</li>
<li>不需要整个包都放入缓冲器之后再进行路由，只要<span style="background:#fff88f">接受一个头之后就开始路由</span>，如果链路空闲则剩下的包不用进缓冲器直接进入下一个节点</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2018.44.40.png" alt="|224"><ul>
<li>D+1段指读包头传输，整体没停只传输一整段</li>
</ul>
</li>
<li>此时通信时延与节点数无关</li>
<li>但如果出现寻径阻塞着还是需要整个包存储在节点，等到不阻塞再发出</li>
</ul>
</li>
<li><font color="#d83931">虫蚀方式</font><ul>
<li>把信息包切割成更小的单位片，让信息包中的各片按照流水方式进行，不仅减少缓冲器的容量还能缩短传送延迟</li>
<li>一个节点先把头片送到下一个节点，接下来一次把后面的片送出，一个节点一旦开始传送头片就必须把整个包送完</li>
<li>虫蚀和虚拟直通的本质是一样的，只是把单元切小了而已</li>
<li>对于一个阻塞的包，各个片会沿着通路分散在各个中间节点中，每当前面的片向前传送，后面的数据片就会跟着往前蠕动一个节点，就像一条虫子一样</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2018.53.32.png" alt="|400"><ul>
<li>感觉这里写错了应该也是D+1，不过都会忽略也无所谓<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2018.56.22.png"></li>
</ul>
</li>
<li>优点：缓冲器小，易于VLSI，较小的网络传输延迟，通道共享性好利用率高，易于实现选播和广播通信模式</li>
<li>缺点：<span style="background:#fff88f">一片被阻塞则所有片都会被阻塞，占用节点资源</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-5-2-死锁与虚拟通道"><a href="#7-5-2-死锁与虚拟通道" class="headerlink" title="7.5.2 死锁与虚拟通道"></a>7.5.2 死锁与虚拟通道</h4><ul>
<li>虚拟通道<ul>
<li>虚拟通道时两个节点间的逻辑连接，由原节点的片缓冲区、节点间的物理通道和接受节点的片缓冲区组成，下图中时4条虚拟通道共享一条物理通道的概念，物理通道被分配给了4对缓冲区<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2019.08.39.png" alt="|425"><ul>
<li>物理通道被四条虚拟通道分时共享，必须通过某些通道状态来区分不同的虚拟通道</li>
</ul>
</li>
</ul>
</li>
<li>避免死锁<ul>
<li>缓冲区或者通道上的循环等待会构成死锁，利用虚拟通道方法可以避免死锁<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2019.10.06.png"><ul>
<li>也就是把一条通道变成分时共享的两条通道</li>
</ul>
</li>
<li>增加虚拟通道可能会是的每个请求可用的有效通道带宽降低，数目很大的虚拟通道在实现的时候需要用高速的多路选择开关</li>
</ul>
</li>
</ul>
<h4 id="7-5-3-流控制策略"><a href="#7-5-3-流控制策略" class="headerlink" title="7.5.3 流控制策略"></a>7.5.3 流控制策略</h4><ul>
<li>在两个或者多个包处于同一个节点来竞争缓冲区或者通道资源的时候必须使用预先制定好的策略来解决冲突<ul>
<li>需要不会引起拥挤或者死锁，为一对一通信所设计的确定寻径算法和自适应寻径算法</li>
</ul>
</li>
<li>包冲突的解决<ul>
<li>为了通过通道在两个相邻节点之间传送一个片所需要的三个条件<ul>
<li>源缓冲区已经存有改片</li>
<li>通道已经分配好</li>
<li>接受缓冲区已经准备接受该片</li>
</ul>
</li>
<li>两个包到达同一个节点可能都在请求同一个接受缓冲器或者同一个输出通道，因此必须对两个问题进行仲裁<ul>
<li>把通道分配给哪个包？</li>
<li>如果处理被拒绝的包？</li>
</ul>
</li>
<li><span style="background:#fff88f">四种解决方案</span><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2019.22.03.png" alt="|475"><ul>
<li>第二个包暂存缓冲区<ul>
<li>一个包缓冲区一个片缓冲区</li>
<li>等到第一个包通过片缓冲区发完之后包缓冲区开始传输</li>
<li>优点：不会浪费已经分配的资源</li>
<li>缺点：缓冲器又要有包大小</li>
</ul>
</li>
<li>阻塞第二个包<ul>
<li>用门挡住第二个包</li>
</ul>
</li>
<li>丢弃第二个包<ul>
<li>第一个包送入缓冲区，第二个包丢弃</li>
</ul>
</li>
<li>绕道<ul>
<li>第一个包进入片缓冲区，第二个包导向其他通道</li>
</ul>
</li>
<li>上述方法中丢弃法会造成严重的资源浪费并要求重传和确认，已经很少使用因为传输率不稳定</li>
<li>绕道法更灵活但可能会话费超过实际需要的通道资源造成浪费</li>
</ul>
</li>
</ul>
</li>
<li>确定性寻径和自适应寻径<ul>
<li>确定性寻径<ul>
<li>通信路径完全由源节点地址和目的地址来决定，寻径路径是预先唯一确定好的与网络状态无关</li>
<li>两种确定性寻径<ul>
<li>都是建立在维序的概念上的，</li>
</ul>
<ol>
<li>E-cube寻径<ul>
<li>维序寻径要求对后继通道的选择是按照各维的顺序来进行，比如对于二维网格网络被称为X-Y寻径，因为需要先沿着×维寻径然后再沿y维寻径</li>
</ul>
</li>
<li>超立方体的E立方体寻径<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-07-07%2010.51.46.png"><ul>
<li>原理其实很简单，异或既是加也是减，第一步其实就是目标-起始，得到的r就是距离，也就是两者的差距，每一维度上如果是0就是没差距，1就是有差距</li>
<li>接下来就是从最低维度开始，如果是一就加一，如果是0就不变，也是从最低维度对齐之后逐维度上升，本质就是每个维度只有0&#x2F;1的E-cube寻径</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>自适应寻径<ul>
<li>通信的通路每一次需要根据资源或者网络的情况来选择，可以避免拥挤或者有故障的节点</li>
</ul>
</li>
<li>两种寻径都不希望发生死锁</li>
</ul>
</li>
</ul>
<h4 id="7-5-4-选播和广播寻径算法"><a href="#7-5-4-选播和广播寻径算法" class="headerlink" title="7.5.4 选播和广播寻径算法"></a>7.5.4 选播和广播寻径算法</h4><ul>
<li><font color="#d83931">四种通信模式</font><ul>
<li>单播：一对一的通信情况，一个源节点发一个目的节点</li>
<li>选播：一对多的通信情况，一个源节点发一个消息到多个目的节点</li>
<li>广播：一对全的通信情况，一个源节点发一个消息到全部节点</li>
<li>会议：多对多的通行情况</li>
</ul>
</li>
<li>通信流量和通信时延是常用的两个参数，通道流量可用传输有关的消息所使用的通道数来表示，通信时延则用包的最大传输时间来表示</li>
<li>优化寻径网络应能以最小流量和最小时延来实现相关的通信模式，但是到达一个指标最小的时候不一定能到达另一指标的最小<ul>
<li>这和使用的交换技术有关，在存储转发网络中时延是最重要的问题，而虫蚀网络中流量对于效率的影响更大</li>
</ul>
</li>
<li>以网格网络为例讨论广播和选播<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2020.34.14.png" alt="|425"><ul>
<li>a：正常五个单播实现选播</li>
<li>b、c：在一个中间节点上复制传送的包<ul>
<li>b适合存储转发模式</li>
<li>c适合虫蚀模式</li>
</ul>
</li>
<li>d：广播树，适合广播</li>
</ul>
</li>
</ul>
<h2 id="第八章-多处理机"><a href="#第八章-多处理机" class="headerlink" title="第八章 多处理机"></a>第八章 多处理机</h2><blockquote>
<p>10%<br>选填较多<br>简答题一道<br>大题（小概率）<br>ps：Cache一致性协议的状态转换图</p>
</blockquote>
<h3 id="8-1-引言"><a href="#8-1-引言" class="headerlink" title="8.1 引言"></a>8.1 引言</h3><h4 id="8-1-1-并行计算机系统结构的分类"><a href="#8-1-1-并行计算机系统结构的分类" class="headerlink" title="8.1.1 并行计算机系统结构的分类"></a>8.1.1 并行计算机系统结构的分类</h4><ul>
<li>按照Flynn分类法，计算机可以分为SISD、SIMD、MISD和MIMD四类，近年MIMD取代SIMD成为通用多处理器的性价比优势</li>
<li>计算机机群系统是一类被广泛采用的MIMD计算机，通常采用标准组件和标准网络技术</li>
<li>现有的MIMD计算机分为两类，每一类代表了一种存储器的结构和互连策略<ul>
<li><font color="#d83931">集中式共享存储器结构</font><ul>
<li>最多由几十个处理器构成</li>
<li>处理器个数较少、可以&#x3D;&#x3D;共享一个集中式物理存储器&#x3D;&#x3D;</li>
<li>因为只有单一的存储器因此对于各处理器的关系是对称的，因此经常称为“对称式共享存储器多处理机”<font color="#d83931">SMP</font>，系统结构也被称为<font color="#d83931">UMA</font>结构<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2021.14.03.png" alt="|325"><ul>
<li>连接一般是采用一条或者多条总线，或者采用交叉开关</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">分布式存储器多处理机</font><ul>
<li>存储器在物理上是分布的，支持规模较大的多处理机系统</li>
<li>存储器会分布到各个处理器上，否则不能满足较多处理器带来的带宽需求</li>
<li>处理器个数较多还要求有高带宽的互联网络，每个节点由处理器及其Cache、存储器、I&#x2F;O以及互连网络接口组成<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2021.16.53.png" alt="|475"></li>
<li>存储器分布到各个节点的优点<ul>
<li>大多数访存如果都是针对本地节点的存储器进行，则可以降低对存储器和互联网络的带宽需求</li>
<li>对于本地存储器的访问延迟时间小</li>
</ul>
</li>
<li>缺点：<ul>
<li>处理器之间的通信较为复杂</li>
<li>各处理器之间访问延迟较大</li>
</ul>
</li>
<li>I&#x2F;O通常和存储器一样也分布于多处理器的各节点中，每个节点可能还包含2～8个以另一种互连技术连接的处理器，这种多个处理器的节点称为“超级节点”<ul>
<li>超级节点对于计算机运行原理没有影响，计算机之间主要的差别在于通信方法和分布式存储器的逻辑结构方面</li>
<li>分析时每个节点都视作只有一个处理器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-1-2-存储器系统结构和通信机制"><a href="#8-1-2-存储器系统结构和通信机制" class="headerlink" title="8.1.2 存储器系统结构和通信机制"></a>8.1.2 存储器系统结构和通信机制</h4><ul>
<li>两种存储器系统结构和通信机制<ul>
<li><font color="#d83931">分布式共享存储器系统DSM</font><ul>
<li>把物理上分离的所有存储器视作一个统一的共享逻辑空间进行编制——任何一个处理器可以访问该共享空间的任何一个单元（有权限），不同处理器上的同一个物理地址指向同一个存储单元</li>
<li>共享指的是逻辑上共享</li>
<li>DSM计算机被称为非同一内存访问计算机<font color="#d83931">NUMA</font>，访存时间取决于数据在存储器中的存放位置</li>
</ul>
</li>
<li><font color="#d83931">私有存储器</font><ul>
<li>把每个节点中的存储器编址为一个独立的地址空间，不同节点中的地址空间相互独立，整个系统的地址空间是由多个独立的地址空间构成，每个节点的存储器只能由本地处理器访问，远程处理器不能直接访问</li>
<li>不同处理器的同一个物理地址指向不同的存储单元</li>
<li>每一个处理器-存储器模块是一台单独的计算机</li>
</ul>
</li>
<li><font color="#d83931">这两种系统分别有相应的通信机制</font><ul>
<li>共享地址空间的计算机系统采用<font color="#d83931">共享存储器通信机制</font>，处理器之间通过load和store对相同存储器地址进行读&#x2F;写操作来实现的</li>
<li>多独立地址空间的计算机系统需要通过在处理器之间显式的传递消息来完成，被称为消<font color="#d83931">息传递通信机制</font></li>
</ul>
</li>
<li>在消息传递的多处理器中，处理器之间通过发送消息来通信<ul>
<li>如果请求方处理器在发送一个请求消息之后要一直等到收到应答才能继续运行，则称为消息传递是同步的</li>
<li>如果数据发送方知道别的处理器需要数据，通信可以不经请求主动送往数据接收方，这样的消息传递往往是异步的，发送方发出消息后可以继续执行原来的程序</li>
<li>为了便于程序移植，人们提出了标准的消息传递库如MPI为编程人员实现消息传递提供了支持</li>
</ul>
</li>
</ul>
</li>
<li><span style="background:#fff88f">不同通信机制的优点</span><ul>
<li>共享存储器通信<ul>
<li>与常用的对称式多处理机中使用的通信机制兼容</li>
<li>当处理器之间通信方式复杂或者在执行过程中动态变化时，采用共享存储器通信编程容易，同时简化编译器设计</li>
<li>大家都熟悉共享存储器模型开发应用程序，重点可以放到解决对性能影响较大的数据访问上</li>
<li>当通信数据量较小的时候通信的开销较小、宽带利用较好</li>
<li>可以采用Cache减少远程通信频度，是通过对于所有数据进行Cache缓冲来实现<ul>
<li>Cache不仅能减少访问共享数据的延迟、还能减少对共享数据的访问冲突</li>
</ul>
</li>
</ul>
</li>
<li>消息传递通信<ul>
<li>对于硬件更简单，特别是与可扩放共享存储器实现方案相比</li>
<li>通信是显式的，容易搞清楚何时通信切通信开销</li>
<li>显示通信可以让编程者重点注意并行计算的主要通信开销，使之有可能开发出结构更好性能更高的并行成熟</li>
<li>同步很自然的与发送信息相关联，能减少不当的同步带来错误的可能性</li>
</ul>
</li>
<li>上述两种通信模式中，可以在任何一种通信机制的硬件基础上建立另外一种通信模式<ul>
<li>共享存储器上实现消息传递：很简单，发送一条消息可以通过将一部分的地址空间的内容复制到另一部分地址空间实现（反正有全部存储的访问权）</li>
<li>消息传递上实现共享存储器：很困难，所有对于共享存储器的访问都需要操作系统进行地址转换和存储保护，并把存储器访问转换为消息的发送和接受，而且load和store只能访问少量数据，这种方法实现共享存储器开销很大，基本不使用</li>
</ul>
</li>
</ul>
</li>
<li>发展过程<ul>
<li>最初分布式存储器计算机均采用消息传递，因为简单</li>
<li>后来几乎都支持共享存储器通信</li>
<li>现在通过总线连接的对称式共享存储器计算机占据主导地位</li>
<li>但从长远来看中等规模的分布式共享存储器计算机才是趋势</li>
</ul>
</li>
</ul>
<h4 id="8-1-3-并行处理面临的挑战"><a href="#8-1-3-并行处理面临的挑战" class="headerlink" title="8.1.3 并行处理面临的挑战"></a>8.1.3 并行处理面临的挑战</h4><ul>
<li>两个重要挑战<ul>
<li>程序中的并行性有限<ul>
<li>程序不能在完全并行或串行下运行，往往介于两者之间，因此加速比很难哟一个很大的提升</li>
</ul>
</li>
<li>相对较大的通信开销<ul>
<li>处理器之间数据通信大约要50～1000时钟周期，取决于通信机制、互连网络种类和机器规模<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-08%2022.16.53.png"></li>
</ul>
</li>
<li>解决方法<ul>
<li>并行性不足的问题采用并行性更好的算法来解决</li>
<li>减少远程访问延迟可以依靠系统结构来实现，也可以通过编程技术来实现，既可以用硬件如Cache来缓冲共享数据，也可以采用软件对于数据重新组织，让更多访问变为局部访问，还可以采用预取或者多线程技术来减少延迟的影响</li>
</ul>
</li>
</ul>
</li>
<li>并行处理中，负载平衡、同步和存储器访问延迟等影响性能的因素依赖于<span style="background:#fff88f">应用程序的高层特性</span>比如数据分配、并行算法的结构或者空间&#x2F;时间上对于数据的访问模式等，依据应用特点可以把多级工作负载大致分为两类：单个程序在多处理机上的并行工作负载和多个程序在多处理机上的并行工作负载</li>
<li>并行程序性能的一个重要度量是“<span style="background:#fff88f">计算&#x2F;通信比</span>”，如果比值较大表示应用程序中每次通信需要进行较多计算，越高的计算&#x2F;通信越好<ul>
<li>并行处理环境下，每增加一个处理器的数目或者增大所求问题的规模，或两者都的时候，都需要求计算&#x2F;通信比来分析</li>
<li>处理器增多，每个处理器计算量减少而通信量会增大</li>
<li>问题规模增大时通信量变化会更复杂，与算法有关</li>
<li>通常计算&#x2F;通信比会随着数据规模增大而增大，随着处理器数目增加而减少<ul>
<li>每当增加处理器都需要调整数据的规模来让通信比中保持不变</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-2-对称式共享存储器系统结构"><a href="#8-2-对称式共享存储器系统结构" class="headerlink" title="8.2 对称式共享存储器系统结构"></a>8.2 对称式共享存储器系统结构</h3><ul>
<li>对称式共享存储器系统结构一般都支持对共享数据和室友数据的Cache缓存<ul>
<li>私有数据值只供一个处理器使用的数据</li>
<li>共享数据指供多个处理器共同使用的数据</li>
</ul>
</li>
<li>私有数据进入Cache是的处理器对它们的访问可以在Cache中完成从而减少平均访存时间和减少对存储器带宽的要求</li>
<li>但允许共享数据进入Cache时，共享数据可能会在多个Cache中存在副本来方便处理器在自己的Cache中找到数据<ul>
<li>减少了访存时间以及对于存储器带宽的要求</li>
<li>减少多个处理器同时读取共享数据所产生的冲突</li>
</ul>
</li>
<li>但是共享数据也带来了Cache一致性的问题</li>
</ul>
<h4 id="8-2-1-多处理机Cache一致性"><a href="#8-2-1-多处理机Cache一致性" class="headerlink" title="8.2.1 多处理机Cache一致性"></a>8.2.1 多处理机Cache一致性</h4><ul>
<li><font color="#d83931">Cache一致性问题</font><ul>
<li>当多个处理器的Cache中都有同一存储块的副本，这时如果某个处理器对其Cache中的数据进行修改后就会使得其Cache中的数据与其他Cache中的数据不一致</li>
<li>对于一致性，如果对于某个数据项的任何读操作均可以得到其最新写入的值，则认为这个存储系统是一致的<ul>
<li>读操作得到的是什么值？</li>
<li>什么时候读操作才能得到新写入的值？</li>
</ul>
</li>
</ul>
</li>
<li>满足一致性的处理器P需要<ul>
<li>P在对存储单元X进行一次写之后又对X进行读，在这读和写字节没有其他处理器对X进行写，则P读到的值总是刚写进去的值<ul>
<li>保证程序顺序</li>
</ul>
</li>
<li>P在对存储单元X进行写之后另一处理器Q对X进行读，在这读和写之间没有其他对X的写，则Q读到的应该是是P写进去的值<ul>
<li>规定存储器一致性概念</li>
</ul>
</li>
<li>对于同一存储单元的写是串型化的，任意两个处理器对于同一个存储单元的两次写，从各个处理器的角度来看顺序都是相同的</li>
</ul>
</li>
<li>如何满足及时的获取写进去的值？<ul>
<li>写入处理器X的值很难立马出现在别的处理器上，肯定会有延迟</li>
<li>规定：<ul>
<li>直到所有的处理器均看到写的结果，写操作才算完成</li>
<li>处理器的任何访存都不能改变写的顺序，允许处理器对于读进行重排序，但必须以程序规定的顺序进行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-2-2-实现一致性的基本方案"><a href="#8-2-2-实现一致性的基本方案" class="headerlink" title="8.2.2 实现一致性的基本方案"></a>8.2.2 实现一致性的基本方案</h4><ul>
<li>必须实现<span style="background:#fff88f">共享数据的迁移&amp;复制</span><ul>
<li>迁移：<ul>
<li>把远程的共享数据复制一份，迁入本地的Cache供本地处理器使用</li>
<li>从而减少对于远程共享数据的访问延迟</li>
<li>也减少了共享存储器带宽的需求</li>
</ul>
</li>
<li>复制：<ul>
<li>把多个处理器需要同时读取的共享数据在这些处理器的本地Cache中各存放一个副本</li>
<li>减少了访问共享数据的延迟</li>
<li>减少了共享数据所产生的冲突</li>
</ul>
</li>
<li>迁移和复制对于提高访问共享数据的性能来说是非常重要的</li>
</ul>
</li>
<li>多个处理器中用来维护一致性的协议被称为Cache一致性协议，实现Cache一致性协议的关键是跟踪共享数据块的状态<ul>
<li><font color="#d83931">目录式协议</font>：<ul>
<li>物理存储器中数据块的<span style="background:#fff88f">共享状态被保存在一个称为目录的地方</span></li>
<li>目录式协议的实现开销比监听式协议的稍微大一些，但可用于实现更大规模的多处理机</li>
</ul>
</li>
<li><font color="#d83931">监听式协议</font>：<ul>
<li>当物理存储器中的数据块被调入Cache时，共享状态信息与该数据块会一起放在Cache中</li>
<li>系统中没有集中的状态表，但是Cache会都连在共享存储器的总线上，当某个Cache需要访问存储器时，它会把请求方道总线上广播出去，其他各个Cache通过监听总线来判断它们是否有总线上请求的数据块，如果有则进行相应的操作</li>
</ul>
</li>
<li>在多个微处理器且每个Cache都与单一共享存储器相连组成的多处理机中一般都采用监听协议<ul>
<li>这种协议可以利用已有的物理连接（连接到存储器的总线）</li>
</ul>
</li>
</ul>
</li>
<li>解决上述一致性问题的方法<ul>
<li>保证——<font color="#d83931">写作废协议</font>（监听&#x2F;目录都适用）<ul>
<li>在处理器对某个数据进行写入之前，它有对于该数据项唯一的访问权</li>
<li>具体做法就是在处理器P写入操作之前把其他Cache中的副本全部作废</li>
<li>唯一的访问权保证了在进行写入操作时其他处理器不存在任何副本</li>
<li>如果其他处理器要接着访问该数据，就会产生不命中，从而从存储器中取出新的数据副本（写直达）或者从P的Cache中获得新的数据（写回法）</li>
<li>要想保证唯一访问权，就必须禁止其他处理器和P同时进行写操作</li>
<li>如果两个同时进行写操作就会竞争，获胜者获得访问权，失败者的处理器副本会作废。竞争失败的处理器要想完成写操作就必须先获得一份新的数据副本，该副本已经包含了更新后的数据</li>
<li>保证了写操作的串型化<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-09%2019.37.42.png"></li>
</ul>
</li>
<li><font color="#d83931">写更新协议</font><ul>
<li>当一个处理器对于某个数据项进行写入的时候，把该新的数据广播给其他的Cache，其他Cache用新数据对于其中的副本进行更新<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-09%2019.56.54.png"></li>
</ul>
</li>
<li>两者性能差异<ul>
<li>对于同一个数据进行多次写操作而中间无读操作的时候，写更新协议需要进行多次写广播操作，写作废协议只需要一次作废操作</li>
<li>统一Cache进行多个字的写操作的情况下，写更新协议对于每一个写操作都要进行一次广播，写作废协议只需要第一次写时进行废操作即可，写作废以Cache块进行操作，写更新则是针对字进行</li>
<li>考虑一个处理器A进行写操作后到另一个处理器B能读到该写入数据之间的延迟时间<ul>
<li>写更新的延迟较小</li>
<li>写作废需要等待新的副本</li>
</ul>
</li>
<li>写作废协议耗费的总线和存储器带宽比较少</li>
</ul>
</li>
<li><font color="#d83931">写直达和写回</font><ul>
<li>写直达Cache：所有写入的数据都同时被写回主存，所以从主存中总可以取到最新值</li>
<li>写回法Cache：数据的最新值不一定会在主存中，可能会需要某个Cache来提供</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-2-3-监听协议的实现"><a href="#8-2-3-监听协议的实现" class="headerlink" title="8.2.3 监听协议的实现"></a>8.2.3 监听协议的实现</h4><ul>
<li>监听协议的基本实现技术<ul>
<li>处理器之间通过一个可以实现广播的互连机制相连，通常采用的是总线</li>
<li>当一个处理器的Cache相应本地CPU访问时，如果涉及全局操作，如需要访问共享存储器或者需要其他处理器中的Cache执行相应的操作（如作废），其Cache控制器就要在获得总线的控制权后在总线发相应消息</li>
<li>所有的处理器一直在监听总线，它们检测总线上的地址在它们的Cache中是否有副本，如果有就会响应该消息并进行相应的操作</li>
<li>获得总线控制权的顺序性保证了写操作的串型化</li>
<li>Cache发到总线上的消息主要有以下两种<ul>
<li>RdMiss——读不命中</li>
<li>WtMiss——写不命中</li>
<li>这两种分别表示本地CPU对于Cache进行读访问和写访问时不命中（被作废掉了），这时需要通过总线找到相应数据块的最新副本然后调入本地Cache中</li>
<li>尽管副本不一定在存储器中，但为了尽快获得一般是马上启动对于存储器相关块的访问</li>
<li>写直达法一定可以在存储器找到最新值</li>
<li>写回法则不一定写回了存储器，可能还在Cache中，就需要那个Cache项请求方处理器提供该块并终止Rd&#x2F;WtMiss对存储器的访问</li>
<li>有的监听协议还有Invalidate消息来通知其他各处理器作废其Cache中相应的副本，Invalidate和WtMiss的区别就是Invalidate不引起调块</li>
</ul>
</li>
<li>写回法的多Cache，每当一个数据进行写入的时候，这个块的修改位被置位，表示该块中保存的是整个系统中唯一的最新副本，存储器和其他Cache中的副本都是过时的<ul>
<li>每个处理器都会监听其他处理器方道总线上的地址，如果某个处理器发现它拥有被请求数据块的最新副本，就会把数据块发送给请求的处理器</li>
<li>写回法Cache需要的存储器带宽较低</li>
</ul>
</li>
<li>写作废+写回法是比较合理的方法组合</li>
<li>Cache本来就有标识可以直接用来实现监听，通过把总线上的地址和Cache内的标识进行比较，就能找到对应的Cache块，然后进行相应的处理<ul>
<li>每个块的有效位可以用来表示是否被作废</li>
<li>对于CPU读不命中的情况，只需要Cache控制器向总线发RdMiss消息，并且启动从主存的读块操作，准备调入Cache<ul>
<li>如果存储器的块不是最新的就要对应Cache提供数据，并终止对存储器的访问</li>
</ul>
</li>
<li>对于写操作来说，希望能够知道其他处理器中是否有该写入数据的副本，如果没有就不用把这个写操作放到总线上（不是敏感数据）从而减少所需要的带宽<ul>
<li>如果Cache块中的“共享位”为1则是被多个处理器所共享的，0则是被某个处理器独占的</li>
<li>当一个块处于独占状态时，写操作不必向总线提供，否则处于共享状态，写操作的时候需要向总线发Invalidate，作废所有其他Cache中的副本，同时把本地的块共享标识为0，因为自己此时独占“新版本”</li>
</ul>
</li>
</ul>
</li>
<li>每次总线的操作都会检查Cache中的地址表示，打扰到处理器对于Cache的访问，必须设法减少这种打扰，一种方法是设置两套标识分别处理CPU和总线的访问，但是命中和不命中都需要对两套标识进行操作<ul>
<li>多级Cache中可以把监听的操作请求交给第二级的Cache来处理，处理器只会在第一级Cache不命中的时候才会访问第二级Cache，且第一级的命中率很高，因此可以实现大部分的分离</li>
<li>不过如果监听命中了Cache的数据块，可能会去第一级修改对应的块</li>
</ul>
</li>
</ul>
</li>
<li>监听协议举例<ul>
<li>实时监听协议通常在每个节点内嵌入一个有限状态控制器，该控制器根据来自处理器或总线的请求以及Cache块的状态做相应的响应（改变Cache块状态&#x2F;通过总线访问存储器&#x2F;作废Cache）</li>
<li>简单的监听协议实例<ul>
<li>每个数据块的3种状态<ul>
<li>无效——I：表示Cache中该块的内容无效，还没有进入Cache</li>
<li>共享——S：表示该块处于共享状态，存在多个副本且与存储器中的相同<ul>
<li>共享中的块只能读不能写</li>
</ul>
</li>
<li>已修改——M：表示该块已经被修改且没写入存储器，此时该块是整个系统中唯一的副本<ul>
<li>已修改的块在共享前可读可写</li>
</ul>
</li>
</ul>
</li>
<li><font color="#d83931">各种情况下监听协议进行的操作</font><ul>
<li><font color="#d83931">响应处理器的请求</font>（CPU来活了）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-09%2021.23.38.png" alt="|500"><ul>
<li>不发生替换<ul>
<li>状态为I<ul>
<li>CPU要访问的时候对应的块未调入Cache，发生读不命中</li>
<li>向总线发送WtMiss</li>
<li>调入后修改为M，此副本变为最新副本</li>
</ul>
</li>
<li>状态为S<ul>
<li>CPU读访问时，如果命中则状态不变，否则需要替换</li>
<li>写访问的时候，如果命中需要修改状态为M，然后写入数据，同时向总线发Invalidate作废其他副本</li>
</ul>
</li>
<li>状态为M<ul>
<li>读&#x2F;写命中时状态不变，否则需要替换</li>
</ul>
</li>
</ul>
</li>
<li>发生替换<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-09%2021.49.39.png" alt="|500"><ul>
<li>上述规则CPU访问Cache不命中时要进行替换，根据替换算法在Cache中选择一个替换块，以下为旧块的状态</li>
<li>状态为S<ul>
<li>读不命中，发送RdMiss，调入一个新块替换旧块，并且状态依旧为S</li>
<li>写不命中，发送WtMiss，调入新块替换旧块，但是要修改状态成M</li>
</ul>
</li>
<li>状态为M<ul>
<li>读不命中，先把旧块写回存储器，然后替换旧块，状态改为S</li>
<li>写不命中，先把旧块写回存储器，然后替换旧块，状态不变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>响应来自总线的请求<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-09%2021.59.11.png" alt="|425"><ul>
<li>以下状态为本地Cache中块的状态</li>
<li>状态为S<ul>
<li>表示本块只是一个只读副本，</li>
<li>如果总线是RdMiss，是远程处理器读访问不命中是向周围求助，本地调出块之后不改变块状态</li>
<li>如果总线是WtMiss&#x2F;Invalidate，说明有人要更改该块内容，本地块需要作废，变为I</li>
</ul>
</li>
<li>状态为M<ul>
<li>本块是目前的独占最新版</li>
<li>如果总线是RdMiss，说明有别人要看这个最新版了，先把本块写回存储器并终止RdMiss对存储的请求，然后把状态改为S</li>
<li>如果总线是WtMiss，说明有人要写更新的版本，先把本块写回存储器并终止WtMiss对存储的请求，然后把状态改为I（别人要更新）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实际情况中无法保证上述操作的原子性，所以会更复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-3-分布式共享存储器系统结构"><a href="#8-3-分布式共享存储器系统结构" class="headerlink" title="8.3 分布式共享存储器系统结构"></a>8.3 分布式共享存储器系统结构</h3><h4 id="8-3-1-目录协议的基本思想"><a href="#8-3-1-目录协议的基本思想" class="headerlink" title="8.3.1 目录协议的基本思想"></a>8.3.1 目录协议的基本思想</h4><ul>
<li>监听协议中<ul>
<li>Cache不命中就会向其他Cache进行通信，其他Cache也需要实时监听</li>
<li>因为系统中没有一个集中的数据结构来记录Cache的状态，数据块的状态是保存在各自的Cache中</li>
<li>不命中时Cache就不知道其他Cache中那些拥有相应的副本</li>
<li>需要所有Cache协助来完成操作</li>
<li>一旦规模变大就会成为系统的瓶颈，并且可扩放性很差</li>
</ul>
</li>
<li>目录协议采用了一个集中的数据结构——目录<ul>
<li>对于存储器中每一个可以调入Cache的数据块，在目录中设置一条目录项，用于记录该块的状态以及哪些Cache中有副本信息</li>
<li>任何一个数据块都可以快速的在唯一一个位置中找到相关的信息</li>
<li>常用位向量来记录哪些Cache有副本<ul>
<li>一位对应一个处理器，1表示该位对应的处理器有副本，0表示没有</li>
<li>位向量的长度与处理器的个数成正比，位向量所指定“有对应副本的处理器们”称为共享集S</li>
</ul>
</li>
<li>目录协议根据项目中的信息以及当前要进行的访问操作，依次对相应的Cache发送控制消息，完成对目录项信息的修改，还要向请求处理器发送响应的信息</li>
<li>为了提高可扩放性，可以把存储器以及相应的目录分布到各个节点中每个节点的目录时对应于该节点中的数据块的，因此对于不同目录项的访问是可以在不同的节点中并行的进行<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-09%2022.28.40.png" alt="|475"></li>
</ul>
</li>
<li>目录法的实现<ul>
<li>最简单的方法就是对于存储器中的每一块都在目录中设置一项，目录中的信息量与M(所有存储块总数)xN(处理器个数)成正比（每个处理器都要准备一份），不过存储块总数也和处理器个数成正比，则目录中的信息量和N²成正比，可扩放性很差</li>
<li>需要只给进入Cache的块设置目录项，或者每个目录项位数固定</li>
<li>目录项中存储块的状态有三种<ul>
<li>未缓冲：块未被调入Cache，所有Cache都没有该块的副本</li>
<li>共享：该块在一&#x2F;多个处理机上都有副本且都相同</li>
<li>独占：仅有一个处理器拥有这个块的副本，且写操作后是最新的，存储器中的已经过时</li>
</ul>
</li>
<li>为了提高效率，每个Cache中还跟踪记录每个Cache块的状态</li>
<li><font color="#d83931">本地节点</font>、<font color="#d83931">宿主节点</font>、<font color="#d83931">远程节点</font><ul>
<li>本地节点指发出请求的节点</li>
<li>宿主节点指在“存储器”有请求单元以及目录项的节点</li>
<li>远程节点指拥有存储块副本的节点<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-09%2022.41.47.png" alt="|350"></li>
</ul>
</li>
</ul>
</li>
<li>目录法的消息<ul>
<li>本地节点发给宿主节点的消息<ul>
<li>RdMiss（P，K）<ul>
<li>P是发送请求的处理机的编号</li>
<li>K是要访问的地址</li>
<li>处理机P读K是不命中，请求宿主节点提供数据块并把P加入共享集</li>
</ul>
</li>
<li>WtMiss（P，K）<ul>
<li>处理器P写K时不命中，请求宿主节点提供数据块并且共享集中只留P（独占）</li>
</ul>
</li>
<li>Invalidate（K）<ul>
<li>请宿主节点向所有拥有该块的远程Cache发送作废副本信息（宿主才有目录）</li>
</ul>
</li>
</ul>
</li>
<li>宿主节点发送给远程<ul>
<li>Invalidate（K）<ul>
<li>作废远程Cache的K数据块副本</li>
</ul>
</li>
<li>Fetch（K）<ul>
<li>从远程Cache中取出K并送回宿主节点，把远程Cache的块状态改为共享</li>
<li>有人要读了</li>
</ul>
</li>
<li>Fetch&amp;Inv（K）<ul>
<li>从远程Cache中取出K并送回宿主节点，把远程Cache的块状态改为作废</li>
<li>有人要写了</li>
</ul>
</li>
</ul>
</li>
<li>宿主节点发送给本地节点的消息<ul>
<li>DReply（D）<ul>
<li>D表示数据内容</li>
<li>表示你要的数据我已经给你取回来了&#x2F;也可能是自己就有</li>
</ul>
</li>
</ul>
</li>
<li>远程节点发送给宿主节点的消息<ul>
<li>WtBack（K，D）<ul>
<li>把宿主节点要取回的K发送回去</li>
</ul>
</li>
</ul>
</li>
<li>本地节点发送给被替换块的宿主节点的消息<ul>
<li>MdSharer（P，K）<ul>
<li>代表这块我不用了，我要换掉了</li>
<li>本地节点没有修改过该块，发送给宿主节点请求它把P从共享集中删除</li>
<li>如果删完P后共享集为空，宿主节点要把该块的状态改变为“未缓存U”（没人要的东西）</li>
</ul>
</li>
<li>WtBack2（P，K，D）<ul>
<li>同样不用了，但是本地节点还进行了修改</li>
<li>先写回存储器，然后再执行MdSharer的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-3-2-目录协议实例"><a href="#8-3-2-目录协议实例" class="headerlink" title="8.3.2 目录协议实例"></a>8.3.2 目录协议实例</h4><ul>
<li><font color="#d83931">状态转换以及操作机制</font>（50%）<ul>
<li>响应本地CacheCPU请求时Cache块的状态转换图<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2012.09.45.png" alt="|575"><ul>
<li>解释实例：M在CPU写不命中时<ul>
<li>M指旧块是M</li>
<li>发生CPU不命中，因此要用新块替换旧块</li>
<li>那么向旧块的宿主发WtBack2，新块宿主发WtMiss</li>
</ul>
</li>
</ul>
</li>
<li>远程节点中Cache块响应宿主节点请求的状态转换图<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2012.15.28.png" alt="|575"><ul>
<li>远程节点就是被欺负的</li>
</ul>
</li>
</ul>
</li>
<li>目录结构的实现（50%）<ul>
<li>上面的状态都是基于目录已经实现的基础下的后一半</li>
<li>目录存储块的状态有未缓存、共享和独占，目录项还用位向量记录拥有其副本的处理器集合（共享集）</li>
<li>对于从本地节点发来的请求，目录所进行的操作包括<ul>
<li>向远程节点发送消息以完成相应的操作（共享集提供所有的远程节点）</li>
<li>修改目录中该块的状态</li>
<li>更新共享集合</li>
</ul>
</li>
<li>目录可能收到的请求<ul>
<li>读不命中、写不命中、数据写回</li>
</ul>
</li>
<li>目录&#x2F;宿主节点的状态转换图<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2012.21.41.png"></li>
</ul>
</li>
<li>可能遇到的问题<ul>
<li>操作的非原子性</li>
<li>有限的缓存</li>
</ul>
</li>
</ul>
<h4 id="8-3-3-目录的3种结构"><a href="#8-3-3-目录的3种结构" class="headerlink" title="8.3.3 目录的3种结构"></a>8.3.3 目录的3种结构</h4><ul>
<li>全映像目录<ul>
<li>每一个目录项包含一个N位的位向量，一位一个处理机<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2012.28.45.png" alt="|425"><ul>
<li>共享集就由位向量值为1的位对应的处理机组成</li>
</ul>
</li>
<li>处理简单、速度快</li>
<li>存储开销过大，目录占用空间和N²成正比，扩放性差</li>
</ul>
</li>
<li>有限映像目录<ul>
<li>采用位数固定的目录项目<ul>
<li>规定一个数据块最多m个副本，所以一行m项</li>
<li>每一项需要明确标识一个Cache，所以一项要有⌈log₂N⌉位</li>
<li>一共mx⌈log₂N⌉</li>
</ul>
</li>
<li>根据局部性原理，只有很集中的一些Cache会同时用一个副本，因此m&lt;&lt;N，可以大大减少规模</li>
<li>每个块依旧要有一个目录项，一共Nxmx⌈log₂N⌉<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2012.57.10.png" alt="|450"></li>
<li>缺点：<ul>
<li>如果出现一个数据的副本大于m则需要特殊处理</li>
<li>需要驱逐一个副本，也就要引入驱逐策略</li>
</ul>
</li>
</ul>
</li>
<li>链式目录<ul>
<li>用一个目录指针链表来表示共享集合，不限制副本个数且保持了可扩展性</li>
<li>两种实现方法<ul>
<li>单链法<ul>
<li>目录只包含一个元素就是表头指针<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2013.01.12.png"></li>
<li>新加入的插入表头</li>
<li>替换是需要删除对应的第i个元素（两种方法）<ul>
<li>沿着链表找到第i个，修改链表来跳过该元素</li>
<li>找到第i个元素之后作废它以及后面的所有元素对应的Cache副本</li>
</ul>
</li>
</ul>
</li>
<li>双链法：替换的时候不需要遍历整个链表，但是指针增加了一倍而且复杂了协议</li>
</ul>
</li>
<li>链式目录结构复杂但可扩展，空间也是和Nx⌈log₂N⌉成正比</li>
</ul>
</li>
</ul>
<h3 id="8-4-同步"><a href="#8-4-同步" class="headerlink" title="8.4 同步"></a>8.4 同步</h3><p>略</p>
<h3 id="8-5-同时多线程"><a href="#8-5-同时多线程" class="headerlink" title="8.5 同时多线程"></a>8.5 同时多线程</h3><ul>
<li>ILP的更高一级的并行——TLP线程级并行</li>
<li>实现多线程的两种主要方法<ul>
<li><span style="background:#fff88f">细粒度</span>多线程<ul>
<li>每条指令之间都能进行线程的切换，多个线程交替执行</li>
<li>通常以时间片轮转方式</li>
<li>CPU必须每个时钟周期进行线程切换，当一个线程停顿的时候CPU可以立即执行其他线程的指令，因此细粒度多线程可以隐藏长时间停顿引起的吞吐率损失，还能隐藏段时间停顿的损失</li>
<li>缺点：减慢了单个线程的执行，即使它没有停顿</li>
</ul>
</li>
<li><span style="background:#fff88f">粗粒度</span>多线程  <ul>
<li>粗粒度多线程之间的切换只发生在时间较长的停顿（比如第二级Cache不命中）出现的时候</li>
<li>粗粒度多线程不需要像细粒度那样自由切换，减少了切换次数</li>
<li>不会太降低单个线程的执行速度，因为只有线程发生时间较长的停顿时才会执行其他线程的指令</li>
<li>缺点：减少吞吐率损失的能力有限<ul>
<li>不能交叉执行多个线程，发生停顿时流水线需要排空后者暂停，新线程要重新填满</li>
</ul>
</li>
<li>对于减少长时间停顿带来的损失比较有效（建立排空的时间远小于停顿的时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-5-1-将线程级并行转换为ILP"><a href="#8-5-1-将线程级并行转换为ILP" class="headerlink" title="8.5.1 将线程级并行转换为ILP"></a>8.5.1 将线程级并行转换为ILP</h4><ul>
<li>同时多线程技术SMT是在多流出、动态调度的基础上同时开发TLP和ILP的技术，是多线程技术的改进<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2013.52.07.png"><ul>
<li>粗粒度：只有停顿的时候才切换</li>
<li>细粒度：一个时钟周期（一行）切换一次</li>
<li>SMT：即使在一个时钟周期也能切换线程，保证完全没有浪费</li>
</ul>
</li>
<li>SMT同时开发实现TLP和ILP，允许同一个时钟周期由多个线程同时使用流出槽<ul>
<li>理想情况下流出槽的利用率只受限于多个线程对资源的需求和可用资源间的不平衡，实际上还受限于活跃线程个数、缓冲大小限制、多个线程取多条指令能力、线程指令组合能同时流出等</li>
<li>只要位每个线程设置重命名表，分别设置各自的程序计数器，并为多个线程提供指令确认的能力，则多线程可以在一个乱序执行的处理器的基础上实现</li>
</ul>
</li>
</ul>
<h4 id="8-5-2-同时多线程处理器的设计"><a href="#8-5-2-同时多线程处理器的设计" class="headerlink" title="8.5.2 同时多线程处理器的设计"></a>8.5.2 同时多线程处理器的设计</h4><ul>
<li>粗粒度性能提高太小没有意义，细粒度可能对单个线程性能产生不利影响，因此需要通过采用优先线程的方法改进，既能保持多线程在性能上的优势，又能对单个线程性能的影响较小<ul>
<li>不过优先线程被停顿时处理器将丢失一些吞吐率，这是注重单线程和多线程此消彼长的矛盾</li>
</ul>
</li>
<li>单线程和多线程性能之间的平衡<ul>
<li>对于目前每个时钟周期流出4～8条指令的计算机来说，有几个活跃线程就够了，优先线程就更少了</li>
<li>只要有可能处理器就运行优先线程，优先线程取指缓冲区满了再为其他线程取指</li>
</ul>
</li>
<li>其他问题<ul>
<li>需要更大的寄存器组来保存多个线程的现场</li>
<li>不能影响时钟周期，特别是关键路径如指令流出的好指令完成<ul>
<li>指令流出时有更多的候选指令需要考虑</li>
<li>指令完成时选择那些指令提交变得困难</li>
</ul>
</li>
<li>需要保证由于并发执行多个线程带来的Cache冲突和TLB冲突不会导致明显的性能下降</li>
</ul>
</li>
</ul>
<h4 id="8-5-3-同时多线程的性能"><a href="#8-5-3-同时多线程的性能" class="headerlink" title="8.5.3 同时多线程的性能"></a>8.5.3 同时多线程的性能</h4><ul>
<li>对于性能的提高情况<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2014.18.38.png" alt="|500"><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2014.19.17.png" alt="|500"><ul>
<li>吞吐率提高显著，内部部件的利用率和命中率也大大提高</li>
<li>数据Cache性能不好可能是因为不够大，无法容纳多个线程的工作集</li>
</ul>
</li>
<li>特点<ul>
<li>超标量处理器本身功能强大，光ILP不能利用全部的硬件性能</li>
<li>需要结合超标量和同时多线程，在ILP的基础上进一步开发TLP，可以获得显著的性能提高</li>
</ul>
</li>
</ul>
<h3 id="8-6-大规模并行处理机"><a href="#8-6-大规模并行处理机" class="headerlink" title="8.6 大规模并行处理机"></a>8.6 大规模并行处理机</h3><h4 id="8-6-1-并行计算机系统结构"><a href="#8-6-1-并行计算机系统结构" class="headerlink" title="8.6.1 并行计算机系统结构"></a>8.6.1 并行计算机系统结构</h4><ul>
<li>并行向量处理机<span style="background:#fff88f">PVP</span><ul>
<li><span style="background:#fff88f">由若干台高性能向量处理机VP组成，有很高的向量处理性能</span></li>
<li>PVP中经常采用专门设计的高带宽的交叉开关网络，把各VP与共享存储器模块SM连接起来，这样的机器通常不使用Cache而是大量的向量寄存器和指令缓冲器<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2014.25.29.png" alt="|250"></li>
</ul>
</li>
<li><span style="background:#fff88f">对称式共享存储器多处理机SMP</span><ul>
<li>详见8.2，指有一个单独的大存储器</li>
</ul>
</li>
<li><span style="background:#fff88f">分布式共享存储器多处理机DSM</span><ul>
<li>详见8.3，指每个处理器单独有自己的存储器</li>
</ul>
</li>
<li><span style="background:#fff88f">大规模并行处理机MPP</span><ul>
<li>超大规模的计算机系统</li>
<li>优点<ul>
<li>处理节点使用商用微处理器且节点可以拥有多个微处理器</li>
<li>较好的可扩放性，可以拓展</li>
<li>分布非共享存储器，各个节点有自己的地址空间</li>
<li>专门设计和定制的高性能互连网络</li>
<li>消息传递的通信机制 <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2014.29.17.png" alt="|325"></li>
</ul>
</li>
</ul>
</li>
<li><span style="background:#fff88f">机群计算</span>机<ul>
<li><span style="background:#fff88f">价格低廉，易于构建，可扩放性极强</span></li>
<li>由多台同构&#x2F;异构的独立计算机通过<span style="background:#fff88f">高性能网络或局域网</span>互连在一起，协同完成特定的并行计算任务</li>
<li>主要特点<ul>
<li>每个节点是一台完整的计算机，有本地磁盘和操作系统，可以作为一个单独的计算资源供用户使用，节点可以是PC机、工作站甚至是对称多处理机</li>
<li>每个节点通过商品化网络连接在一起如以太网、FDDI、Myrinet等</li>
<li>网络接口NIC以松散耦合的方式连到节点I&#x2F;O总线<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2014.35.34.png"></li>
</ul>
</li>
</ul>
</li>
<li>五类计算机特征比较<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2014.36.06.png"></li>
</ul>
<h4 id="8-6-2-大规模并行处理机"><a href="#8-6-2-大规模并行处理机" class="headerlink" title="8.6.2 大规模并行处理机"></a>8.6.2 大规模并行处理机</h4><ul>
<li>略</li>
</ul>
<h2 id="第十三章-阵列机"><a href="#第十三章-阵列机" class="headerlink" title="第十三章 阵列机"></a>第十三章 阵列机</h2><blockquote>
<p>6%<br>选填较多<br>简答题（小概率）<br>大题（小概率）</p>
</blockquote>
<ul>
<li><font color="#d83931">阵列机的概念</font><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2015.00.07.png" alt="|500"></li>
<li><font color="#d83931">SIMD阵列处理机</font><ul>
<li>使用<span style="background:#fff88f">资源重复</span>的方法</li>
</ul>
</li>
<li>五元组表示阵列处理机SIMD&#x3D;{N,C,I,M,R}<ul>
<li>N：<span style="background:#fff88f">处理单元PE的个数</span></li>
<li>C：<span style="background:#fff88f">控制部件CU的</span>数量</li>
<li>I：<span style="background:#fff88f">CU广播字所有PE并行执行的指令集</span></li>
<li>M：<span style="background:#fff88f">屏蔽方案集</span></li>
<li>R：<span style="background:#fff88f">数据寻径功能集</span></li>
</ul>
</li>
<li>阵列机的特点<ul>
<li><span style="background:#fff88f">资源重复</span>，系统中设置多个相同的处理单元来开发并行性，利用并行性中的同时性，所有处理单元必须同时进行相同操作</li>
<li>阵列机的应用背景是<span style="background:#fff88f">一类算法的专用计算机</span>，因此会限定适用的求解算法类别</li>
<li>阵列机的研究必须与<span style="background:#fff88f">并行算法的研究密切结合</span></li>
<li>由于PE结构相同，属于<span style="background:#fff88f">同构性并行</span>机，控制器实质上是一个标量处理机，但是为了完成I&#x2F;O操作和操作系统管理，还是需要一个前端机，因此实际的阵列机系统是一个<span style="background:#fff88f">异构多处理机系统</span></li>
</ul>
</li>
<li>&#x3D;&#x3D;分布式存储阵列机&#x3D;&#x3D;<ul>
<li>典型例子：Illiac IV<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2016.07.04.png"></li>
<li>主机：程序编辑、编译、调试、程序和数据装入控制存储器</li>
<li>指令送到阵列控制部件进行译码，标量指令由标量处理机处理，向量指令通过广播总线播送到所有PE执行</li>
<li>数据集划分后通过数据总线放到PE的本地存储器LM</li>
<li>PE之间通过数据寻径网络进行通信</li>
<li>PE的同步在控制部件的控制下由硬件实现，PE在一个周期执行同一条指令</li>
<li>屏蔽逻辑控制某些PE在指定指令周期是否参与执行</li>
<li>主要区别在于数据寻径网络不同。IlliacIV：4 邻接网络、CM-2：嵌入网格的超立方体 等。</li>
<li>大部分的阵列处理机都是分布式存储器，易于构成MPP</li>
</ul>
</li>
<li>&#x3D;&#x3D;共享存储阵列机&#x3D;&#x3D;<ul>
<li>典型例子：BSP<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2016.11.58.png"></li>
<li>集中设置存储器：共享多体并行存储器SM–通过对准网络–连接PE</li>
<li>存储模块数量等于或略大于PE数目</li>
<li>必须减少访存冲突，适合PE较少的情况</li>
<li>所有阵列指令使用长度等于PE个数的向量操作数</li>
<li>类BSP机存储体分配（讨论一个含N个AE和M个存储体的情况）<ul>
<li>先将二维数组按照列&#x2F;行优先的顺序变换为一维数组，来形成一个一维线性地址空间，地址为A</li>
<li>然后将A变换为并行存储器地址（i，j）<ul>
<li>j为存储体体号，j&#x3D;A（mod M）</li>
<li>i是存储体内的地址，i&#x3D;⌊A&#x2F;N⌋<br>  <img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2016.19.56.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>阵列机计算举例<ul>
<li>矩阵加（8x8）<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2016.04.36.png"></li>
<li>递归折叠求和算法<img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2016.05.46.png"></li>
</ul>
</li>
<li><font color="#d83931">阵列处理机与流水线向量处理机对比</font><ul>
<li>均适合高速数值运算，阵列处理机有固定结构，<span style="background:#fff88f">与特定算法绑定</span></li>
<li>阵列机用大量的处理单元对各分量运算，个单元同时进行相同的操作，采用的是<span style="background:#fff88f">空间并行</span>，并行化程度高、潜力大</li>
<li>向量处理器基于流水线技术、时间并行性</li>
<li>阵列处理机每个单元负担多种处理功能，相当于向量机多功能流水部件，处理数据效率较低</li>
<li>互联网络设计与研究——阵列机研发重点</li>
<li>阵列机由一台标量处理机和一台前端机，向量处理部件是系统主体，机器性能主要取决于向量处理部分，也取决于标量运算速度和编译开销</li>
</ul>
</li>
<li>计算<ul>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2016.31.25.png"><ul>
<li>两次加法是因为每个处理器有两个Xᵢ，都需要+a</li>
<li>4个同时传给邻居–在邻居里乘</li>
<li>8→4→2→1最后得到结果</li>
</ul>
</li>
<li><img src="/../prtsc/%E6%88%AA%E5%B1%8F2024-06-10%2016.35.12.png"></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Alley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/07/%E5%A4%A7%E4%B8%89%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">http://example.com/2024/07/07/%E5%A4%A7%E4%B8%89%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%B8%89%E8%AF%BE%E7%A8%8B/">大三课程</a></div><div class="post_share"><div class="social-share" data-image="/images/touxiang1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/07/%E5%A4%A7%E4%B8%80%E5%A4%A7%E7%89%A9%E7%AC%94%E8%AE%B0/" title="大一大物笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">大一大物笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/07/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">大三算法笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/07/07/%E5%A4%A7%E4%B8%89%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/" title="大三交换原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">大三交换原理</div></div></a></div><div><a href="/2024/07/07/%E5%A4%A7%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="大三数据库笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">大三数据库笔记</div></div></a></div><div><a href="/2024/07/07/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="大三算法笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">大三算法笔记</div></div></a></div><div><a href="/2024/07/07/%E5%A4%A7%E4%B8%89%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="大三编译原理笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">大三编译原理笔记</div></div></a></div><div><a href="/2024/07/07/%E5%A4%A7%E4%B8%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%9F%E4%B8%AD%EF%BC%89/" title="大三操作系统笔记（期中）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">大三操作系统笔记（期中）</div></div></a></div><div><a href="/2024/07/07/%E5%A4%A7%E4%B8%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" title="大三软件工程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">大三软件工程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/touxiang1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alley</div><div class="author-info__description">我喜欢椎名立希</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Alley-wu"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">第一章 计算机系统结构的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 计算机系统结构的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 计算机系统的结构层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 计算机系统结构的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 计算机组成和计算机实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4 计算机系统结构的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 定量分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%9A%E9%87%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 计算机系统设计的定量原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 计算机系统的性能评测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 计算机系统结构的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 冯·诺伊曼结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E8%BD%AF%E4%BB%B6%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 软件对系统结构的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%99%A8%E4%BB%B6%E5%8F%91%E5%B1%95%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 器件发展对系统结构的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%BA%94%E7%94%A8%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4.4 应用对系统结构的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B9%B6%E8%A1%8C%E6%80%A7%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 计算机系统结构中并行性的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E5%B9%B6%E8%A1%8C%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 并行性的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E6%8F%90%E9%AB%98%E5%B9%B6%E8%A1%8C%E6%80%A7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%94%E5%BE%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2 提高并行性的技术途径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E5%8D%95%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B9%B6%E8%A1%8C%E6%80%A7%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.5.3 单机系统中并行性的发展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E5%A4%9A%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B9%B6%E8%A1%8C%E6%80%A7%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">1.5.4 多机系统中并行性的发展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">第二章 计算机指令集结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 指令集结构的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 指令集结构的功能设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-CISC%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 CISC指令集结构的功能设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-RISC%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 RISC指令集结构的功能设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 控制指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 操作数的类型和大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 指令格式的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-MIPS%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 MIPS指令集结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-MIPS%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.6.1.</span> <span class="toc-text">2.6.1 MIPS的寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-MIPS%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.6.2.</span> <span class="toc-text">2.6.2 MIPS的数据表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-MIPS%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.3.</span> <span class="toc-text">2.6.3 MIPS的数据寻址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-MIPS%E7%9A%84%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.6.4.</span> <span class="toc-text">2.6.4 MIPS的指令格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-5-MIPS%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.5.</span> <span class="toc-text">2.6.5 MIPS的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-6-MIPS%E7%9A%84%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">2.6.6.</span> <span class="toc-text">2.6.6 MIPS的控制指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-7-MIPS%E7%9A%84%E6%B5%AE%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.7.</span> <span class="toc-text">2.6.7 MIPS的浮点操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF-%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA"><span class="toc-number">3.</span> <span class="toc-text">第三章 流水线技术+向量处理机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 流水线的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 什么是流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 流水线的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 流水线的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%90%9E%E5%90%90%E7%8E%87"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 吞吐率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%8A%A0%E9%80%9F%E6%AF%94"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 加速比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%95%88%E7%8E%87"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 流水线性能分析举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5 流水线设计中的若干问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%86%B2%E7%AA%81"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 流水线的相关与冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%845%E6%AE%B5%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 一个经典的5段流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E7%9B%B8%E5%85%B3%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%B2%E7%AA%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 相关与流水线冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 流水线的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-MIPS%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 MIPS的一种简单实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%9F%BA%E6%9C%AC%E7%9A%84MIPS%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 基本的MIPS流水线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 向量处理机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 向量处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 向量处理机的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E6%8F%90%E9%AB%98%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 提高向量处理机性能的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 向量处理机的性能评价</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">第四章 指令级并行（难点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 指令级并行的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 指令的动态调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 动态调度的基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-Tomasulo%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 Tomasulo算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8A%A8%E6%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 动态分支预测技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E9%87%87%E7%94%A8%E5%88%86%E6%94%AF%E5%8E%86%E5%8F%B2%E8%A1%A8BHT"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 采用分支历史表BHT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E9%87%87%E7%94%A8%E5%88%86%E6%94%AF%E7%9B%AE%E6%A0%87%E7%BC%93%E5%86%B2%E6%9C%9FBTB"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 采用分支目标缓冲期BTB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%89%8D%E7%9E%BB%E6%89%A7%E8%A1%8C"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 基于硬件的前瞻执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%A4%9A%E6%8C%87%E4%BB%A4%E6%B5%81%E5%87%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 多指令流出技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E5%9F%BA%E4%BA%8E%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E7%9A%84%E5%A4%9A%E6%B5%81%E5%87%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 基于静态调度的多流出技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E7%9A%84%E5%A4%9A%E6%B5%81%E5%87%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2 基于动态调度的多流出技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3 超长指令字技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E5%A4%9A%E6%B5%81%E5%87%BA%E5%A4%84%E7%90%86%E5%99%A8%E6%94%B6%E5%88%B0%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">4.4.4.</span> <span class="toc-text">4.4.4 多流出处理器收到的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5-%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E6%9C%BA"><span class="toc-number">4.4.5.</span> <span class="toc-text">4.4.5 超流水线处理机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80%E5%92%8C%E6%8C%87%E4%BB%A4%E8%B0%83%E5%BA%A6"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 循环展开和指令调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80%E5%92%8C%E6%8C%87%E4%BB%A4%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1 循环展开和指令调度的基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E9%9D%99%E6%80%81%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2 静态超标量处理机中的循环展开</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">第七章 互联网络（难点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BA%92%E8%BF%9E%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">7.1 互连函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E4%BA%92%E8%BF%9E%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">7.1.1 互连函数的表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%92%E8%BF%9E%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">7.1.2 几种基本的互连函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%82%E6%95%B0%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">5.2.</span> <span class="toc-text">7.2 互连网络的结构参数与性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">7.2.1 互连网络的结构参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">5.2.2.</span> <span class="toc-text">7.2.2 互连网络的性能指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E9%9D%99%E6%80%81%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C"><span class="toc-number">5.3.</span> <span class="toc-text">7.3 静态互连网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%8A%A8%E6%80%81%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C"><span class="toc-number">5.4.</span> <span class="toc-text">7.4 动态互连网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-%E6%80%BB%E7%BA%BF%E7%BD%91%E7%BB%9C"><span class="toc-number">5.4.1.</span> <span class="toc-text">7.4.1 总线网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-%E4%BA%A4%E5%8F%89%E5%BC%80%E5%85%B3%E7%BD%91%E7%BB%9C"><span class="toc-number">5.4.2.</span> <span class="toc-text">7.4.2 交叉开关网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-%E5%A4%9A%E7%BA%A7%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C"><span class="toc-number">5.4.3.</span> <span class="toc-text">7.4.3 多级互连网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-%E5%8A%A8%E6%80%81%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">5.4.4.</span> <span class="toc-text">7.4.4 动态互连网络的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.</span> <span class="toc-text">7.5 消息传递机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-%E6%B6%88%E6%81%AF%E8%AE%AD%E5%BE%84%E6%96%B9%E6%A1%88"><span class="toc-number">5.5.1.</span> <span class="toc-text">7.5.1 消息训径方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-%E6%AD%BB%E9%94%81%E4%B8%8E%E8%99%9A%E6%8B%9F%E9%80%9A%E9%81%93"><span class="toc-number">5.5.2.</span> <span class="toc-text">7.5.2 死锁与虚拟通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3-%E6%B5%81%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">5.5.3.</span> <span class="toc-text">7.5.3 流控制策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-4-%E9%80%89%E6%92%AD%E5%92%8C%E5%B9%BF%E6%92%AD%E5%AF%BB%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">5.5.4.</span> <span class="toc-text">7.5.4 选播和广播寻径算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">第八章 多处理机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%BC%95%E8%A8%80"><span class="toc-number">6.1.</span> <span class="toc-text">8.1 引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">8.1.1 并行计算机系统结构的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.2.</span> <span class="toc-text">8.1.2 存储器系统结构和通信机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">6.1.3.</span> <span class="toc-text">8.1.3 并行处理面临的挑战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%AF%B9%E7%A7%B0%E5%BC%8F%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">8.2 对称式共享存储器系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BACache%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.2.1.</span> <span class="toc-text">8.2.1 多处理机Cache一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.2.</span> <span class="toc-text">8.2.2 实现一致性的基本方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E7%9B%91%E5%90%AC%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.3.</span> <span class="toc-text">8.2.3 监听协议的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">8.3 分布式共享存储器系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E7%9B%AE%E5%BD%95%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">6.3.1.</span> <span class="toc-text">8.3.1 目录协议的基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E7%9B%AE%E5%BD%95%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">8.3.2 目录协议实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-%E7%9B%AE%E5%BD%95%E7%9A%843%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.3.</span> <span class="toc-text">8.3.3 目录的3种结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%90%8C%E6%AD%A5"><span class="toc-number">6.4.</span> <span class="toc-text">8.4 同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.5.</span> <span class="toc-text">8.5 同时多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E5%B0%86%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%B9%B6%E8%A1%8C%E8%BD%AC%E6%8D%A2%E4%B8%BAILP"><span class="toc-number">6.5.1.</span> <span class="toc-text">8.5.1 将线程级并行转换为ILP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.5.2.</span> <span class="toc-text">8.5.2 同时多线程处理器的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">6.5.3.</span> <span class="toc-text">8.5.3 同时多线程的性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E6%9C%BA"><span class="toc-number">6.6.</span> <span class="toc-text">8.6 大规模并行处理机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">6.6.1.</span> <span class="toc-text">8.6.1 并行计算机系统结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E6%9C%BA"><span class="toc-number">6.6.2.</span> <span class="toc-text">8.6.2 大规模并行处理机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%98%B5%E5%88%97%E6%9C%BA"><span class="toc-number">7.</span> <span class="toc-text">第十三章 阵列机</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/%E5%A4%A7%E4%B8%80%E7%BA%BF%E4%BB%A3%E7%AC%94%E8%AE%B0/" title="大一线代笔记">大一线代笔记</a><time datetime="2024-07-07T14:17:14.000Z" title="Created 2024-07-07 22:17:14">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/%E5%A4%A7%E4%B8%80%E6%A8%A1%E7%94%B5%E7%AC%94%E8%AE%B0/" title="大一模电笔记">大一模电笔记</a><time datetime="2024-07-07T14:17:00.000Z" title="Created 2024-07-07 22:17:00">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/%E5%A4%A7%E4%B8%80%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/" title="大一高数笔记">大一高数笔记</a><time datetime="2024-07-07T14:16:44.000Z" title="Created 2024-07-07 22:16:44">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/%E5%A4%A7%E4%B8%80%E5%A4%A7%E7%89%A9%E7%AC%94%E8%AE%B0/" title="大一大物笔记">大一大物笔记</a><time datetime="2024-07-07T14:16:33.000Z" title="Created 2024-07-07 22:16:33">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/%E5%A4%A7%E4%B8%89%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="大三系统结构">大三系统结构</a><time datetime="2024-07-07T14:16:11.000Z" title="Created 2024-07-07 22:16:11">2024-07-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Alley</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/styles/fish.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>